// Code generated by github.com/Khan/genqlient, DO NOT EDIT.

package gql

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/Khan/genqlient/graphql"
	"github.com/turbot/steampipe-linear-genqlient-formatter/utils"
)

// Attachment collection filtering options.
type AttachmentCollectionFilter struct {
	// Compound filters, all of which need to be matched by the attachment.
	And []*AttachmentCollectionFilter `json:"and,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Filters that the attachments creator must satisfy.
	Creator *NullableUserFilter `json:"creator,omitempty"`
	// Filters that needs to be matched by all attachments.
	Every *AttachmentFilter `json:"every,omitempty"`
	// Comparator for the identifier.
	Id *IDComparator `json:"id,omitempty"`
	// Comparator for the collection length.
	Length *NumberComparator `json:"length,omitempty"`
	// Compound filters, one of which need to be matched by the attachment.
	Or []*AttachmentCollectionFilter `json:"or,omitempty"`
	// Filters that needs to be matched by some attachments.
	Some *AttachmentFilter `json:"some,omitempty"`
	// Comparator for the source type.
	SourceType *SourceTypeComparator `json:"sourceType,omitempty"`
	// Comparator for the subtitle.
	Subtitle *NullableStringComparator `json:"subtitle,omitempty"`
	// Comparator for the title.
	Title *StringComparator `json:"title,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the url.
	Url *StringComparator `json:"url,omitempty"`
}

// GetAnd returns AttachmentCollectionFilter.And, and is useful for accessing the field via an interface.
func (v *AttachmentCollectionFilter) GetAnd() []*AttachmentCollectionFilter { return v.And }

// GetCreatedAt returns AttachmentCollectionFilter.CreatedAt, and is useful for accessing the field via an interface.
func (v *AttachmentCollectionFilter) GetCreatedAt() *DateComparator { return v.CreatedAt }

// GetCreator returns AttachmentCollectionFilter.Creator, and is useful for accessing the field via an interface.
func (v *AttachmentCollectionFilter) GetCreator() *NullableUserFilter { return v.Creator }

// GetEvery returns AttachmentCollectionFilter.Every, and is useful for accessing the field via an interface.
func (v *AttachmentCollectionFilter) GetEvery() *AttachmentFilter { return v.Every }

// GetId returns AttachmentCollectionFilter.Id, and is useful for accessing the field via an interface.
func (v *AttachmentCollectionFilter) GetId() *IDComparator { return v.Id }

// GetLength returns AttachmentCollectionFilter.Length, and is useful for accessing the field via an interface.
func (v *AttachmentCollectionFilter) GetLength() *NumberComparator { return v.Length }

// GetOr returns AttachmentCollectionFilter.Or, and is useful for accessing the field via an interface.
func (v *AttachmentCollectionFilter) GetOr() []*AttachmentCollectionFilter { return v.Or }

// GetSome returns AttachmentCollectionFilter.Some, and is useful for accessing the field via an interface.
func (v *AttachmentCollectionFilter) GetSome() *AttachmentFilter { return v.Some }

// GetSourceType returns AttachmentCollectionFilter.SourceType, and is useful for accessing the field via an interface.
func (v *AttachmentCollectionFilter) GetSourceType() *SourceTypeComparator { return v.SourceType }

// GetSubtitle returns AttachmentCollectionFilter.Subtitle, and is useful for accessing the field via an interface.
func (v *AttachmentCollectionFilter) GetSubtitle() *NullableStringComparator { return v.Subtitle }

// GetTitle returns AttachmentCollectionFilter.Title, and is useful for accessing the field via an interface.
func (v *AttachmentCollectionFilter) GetTitle() *StringComparator { return v.Title }

// GetUpdatedAt returns AttachmentCollectionFilter.UpdatedAt, and is useful for accessing the field via an interface.
func (v *AttachmentCollectionFilter) GetUpdatedAt() *DateComparator { return v.UpdatedAt }

// GetUrl returns AttachmentCollectionFilter.Url, and is useful for accessing the field via an interface.
func (v *AttachmentCollectionFilter) GetUrl() *StringComparator { return v.Url }

// Attachment filtering options.
type AttachmentFilter struct {
	// Compound filters, all of which need to be matched by the attachment.
	And []*AttachmentFilter `json:"and,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Filters that the attachments creator must satisfy.
	Creator *NullableUserFilter `json:"creator,omitempty"`
	// Comparator for the identifier.
	Id *IDComparator `json:"id,omitempty"`
	// Compound filters, one of which need to be matched by the attachment.
	Or []*AttachmentFilter `json:"or,omitempty"`
	// Comparator for the source type.
	SourceType *SourceTypeComparator `json:"sourceType,omitempty"`
	// Comparator for the subtitle.
	Subtitle *NullableStringComparator `json:"subtitle,omitempty"`
	// Comparator for the title.
	Title *StringComparator `json:"title,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the url.
	Url *StringComparator `json:"url,omitempty"`
}

// GetAnd returns AttachmentFilter.And, and is useful for accessing the field via an interface.
func (v *AttachmentFilter) GetAnd() []*AttachmentFilter { return v.And }

// GetCreatedAt returns AttachmentFilter.CreatedAt, and is useful for accessing the field via an interface.
func (v *AttachmentFilter) GetCreatedAt() *DateComparator { return v.CreatedAt }

// GetCreator returns AttachmentFilter.Creator, and is useful for accessing the field via an interface.
func (v *AttachmentFilter) GetCreator() *NullableUserFilter { return v.Creator }

// GetId returns AttachmentFilter.Id, and is useful for accessing the field via an interface.
func (v *AttachmentFilter) GetId() *IDComparator { return v.Id }

// GetOr returns AttachmentFilter.Or, and is useful for accessing the field via an interface.
func (v *AttachmentFilter) GetOr() []*AttachmentFilter { return v.Or }

// GetSourceType returns AttachmentFilter.SourceType, and is useful for accessing the field via an interface.
func (v *AttachmentFilter) GetSourceType() *SourceTypeComparator { return v.SourceType }

// GetSubtitle returns AttachmentFilter.Subtitle, and is useful for accessing the field via an interface.
func (v *AttachmentFilter) GetSubtitle() *NullableStringComparator { return v.Subtitle }

// GetTitle returns AttachmentFilter.Title, and is useful for accessing the field via an interface.
func (v *AttachmentFilter) GetTitle() *StringComparator { return v.Title }

// GetUpdatedAt returns AttachmentFilter.UpdatedAt, and is useful for accessing the field via an interface.
func (v *AttachmentFilter) GetUpdatedAt() *DateComparator { return v.UpdatedAt }

// GetUrl returns AttachmentFilter.Url, and is useful for accessing the field via an interface.
func (v *AttachmentFilter) GetUrl() *StringComparator { return v.Url }

// Comparator for booleans.
type BooleanComparator struct {
	// Equals constraint.
	Eq *bool `json:"eq,omitempty"`
	// Not equals constraint.
	Neq *bool `json:"neq,omitempty"`
}

// GetEq returns BooleanComparator.Eq, and is useful for accessing the field via an interface.
func (v *BooleanComparator) GetEq() *bool { return v.Eq }

// GetNeq returns BooleanComparator.Neq, and is useful for accessing the field via an interface.
func (v *BooleanComparator) GetNeq() *bool { return v.Neq }

// Comment filtering options.
type CommentCollectionFilter struct {
	// Compound filters, all of which need to be matched by the comment.
	And []*CommentCollectionFilter `json:"and,omitempty"`
	// Comparator for the comments body.
	Body *StringComparator `json:"body,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Filters that needs to be matched by all comments.
	Every *CommentFilter `json:"every,omitempty"`
	// Comparator for the identifier.
	Id *IDComparator `json:"id,omitempty"`
	// Filters that the comments issue must satisfy.
	Issue *IssueFilter `json:"issue,omitempty"`
	// Comparator for the collection length.
	Length *NumberComparator `json:"length,omitempty"`
	// Compound filters, one of which need to be matched by the comment.
	Or []*CommentCollectionFilter `json:"or,omitempty"`
	// Filters that needs to be matched by some comments.
	Some *CommentFilter `json:"some,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Filters that the comments creator must satisfy.
	User *UserFilter `json:"user,omitempty"`
}

// GetAnd returns CommentCollectionFilter.And, and is useful for accessing the field via an interface.
func (v *CommentCollectionFilter) GetAnd() []*CommentCollectionFilter { return v.And }

// GetBody returns CommentCollectionFilter.Body, and is useful for accessing the field via an interface.
func (v *CommentCollectionFilter) GetBody() *StringComparator { return v.Body }

// GetCreatedAt returns CommentCollectionFilter.CreatedAt, and is useful for accessing the field via an interface.
func (v *CommentCollectionFilter) GetCreatedAt() *DateComparator { return v.CreatedAt }

// GetEvery returns CommentCollectionFilter.Every, and is useful for accessing the field via an interface.
func (v *CommentCollectionFilter) GetEvery() *CommentFilter { return v.Every }

// GetId returns CommentCollectionFilter.Id, and is useful for accessing the field via an interface.
func (v *CommentCollectionFilter) GetId() *IDComparator { return v.Id }

// GetIssue returns CommentCollectionFilter.Issue, and is useful for accessing the field via an interface.
func (v *CommentCollectionFilter) GetIssue() *IssueFilter { return v.Issue }

// GetLength returns CommentCollectionFilter.Length, and is useful for accessing the field via an interface.
func (v *CommentCollectionFilter) GetLength() *NumberComparator { return v.Length }

// GetOr returns CommentCollectionFilter.Or, and is useful for accessing the field via an interface.
func (v *CommentCollectionFilter) GetOr() []*CommentCollectionFilter { return v.Or }

// GetSome returns CommentCollectionFilter.Some, and is useful for accessing the field via an interface.
func (v *CommentCollectionFilter) GetSome() *CommentFilter { return v.Some }

// GetUpdatedAt returns CommentCollectionFilter.UpdatedAt, and is useful for accessing the field via an interface.
func (v *CommentCollectionFilter) GetUpdatedAt() *DateComparator { return v.UpdatedAt }

// GetUser returns CommentCollectionFilter.User, and is useful for accessing the field via an interface.
func (v *CommentCollectionFilter) GetUser() *UserFilter { return v.User }

// Comment filtering options.
type CommentFilter struct {
	// Compound filters, all of which need to be matched by the comment.
	And []*CommentFilter `json:"and,omitempty"`
	// Comparator for the comments body.
	Body *StringComparator `json:"body,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the identifier.
	Id *IDComparator `json:"id,omitempty"`
	// Filters that the comments issue must satisfy.
	Issue *IssueFilter `json:"issue,omitempty"`
	// Compound filters, one of which need to be matched by the comment.
	Or []*CommentFilter `json:"or,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Filters that the comments creator must satisfy.
	User *UserFilter `json:"user,omitempty"`
}

// GetAnd returns CommentFilter.And, and is useful for accessing the field via an interface.
func (v *CommentFilter) GetAnd() []*CommentFilter { return v.And }

// GetBody returns CommentFilter.Body, and is useful for accessing the field via an interface.
func (v *CommentFilter) GetBody() *StringComparator { return v.Body }

// GetCreatedAt returns CommentFilter.CreatedAt, and is useful for accessing the field via an interface.
func (v *CommentFilter) GetCreatedAt() *DateComparator { return v.CreatedAt }

// GetId returns CommentFilter.Id, and is useful for accessing the field via an interface.
func (v *CommentFilter) GetId() *IDComparator { return v.Id }

// GetIssue returns CommentFilter.Issue, and is useful for accessing the field via an interface.
func (v *CommentFilter) GetIssue() *IssueFilter { return v.Issue }

// GetOr returns CommentFilter.Or, and is useful for accessing the field via an interface.
func (v *CommentFilter) GetOr() []*CommentFilter { return v.Or }

// GetUpdatedAt returns CommentFilter.UpdatedAt, and is useful for accessing the field via an interface.
func (v *CommentFilter) GetUpdatedAt() *DateComparator { return v.UpdatedAt }

// GetUser returns CommentFilter.User, and is useful for accessing the field via an interface.
func (v *CommentFilter) GetUser() *UserFilter { return v.User }

// [Internal] Comparator for content.
type ContentComparator struct {
	// [Internal] Contains constraint.
	Contains *string `json:"contains,omitempty"`
	// [Internal] Not-contains constraint.
	NotContains *string `json:"notContains,omitempty"`
}

// GetContains returns ContentComparator.Contains, and is useful for accessing the field via an interface.
func (v *ContentComparator) GetContains() *string { return v.Contains }

// GetNotContains returns ContentComparator.NotContains, and is useful for accessing the field via an interface.
func (v *ContentComparator) GetNotContains() *string { return v.NotContains }

// Comparator for dates.
type DateComparator struct {
	// Equals constraint.
	Eq *time.Time `json:"-"`
	// Greater-than constraint. Matches any values that are greater than the given value.
	Gt *time.Time `json:"-"`
	// Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value.
	Gte *time.Time `json:"-"`
	// In-array constraint.
	In []*time.Time `json:"-"`
	// Less-than constraint. Matches any values that are less than the given value.
	Lt *time.Time `json:"-"`
	// Less-than-or-equal constraint. Matches any values that are less than or equal to the given value.
	Lte *time.Time `json:"-"`
	// Not-equals constraint.
	Neq *time.Time `json:"-"`
	// Not-in-array constraint.
	Nin []*time.Time `json:"-"`
}

// GetEq returns DateComparator.Eq, and is useful for accessing the field via an interface.
func (v *DateComparator) GetEq() *time.Time { return v.Eq }

// GetGt returns DateComparator.Gt, and is useful for accessing the field via an interface.
func (v *DateComparator) GetGt() *time.Time { return v.Gt }

// GetGte returns DateComparator.Gte, and is useful for accessing the field via an interface.
func (v *DateComparator) GetGte() *time.Time { return v.Gte }

// GetIn returns DateComparator.In, and is useful for accessing the field via an interface.
func (v *DateComparator) GetIn() []*time.Time { return v.In }

// GetLt returns DateComparator.Lt, and is useful for accessing the field via an interface.
func (v *DateComparator) GetLt() *time.Time { return v.Lt }

// GetLte returns DateComparator.Lte, and is useful for accessing the field via an interface.
func (v *DateComparator) GetLte() *time.Time { return v.Lte }

// GetNeq returns DateComparator.Neq, and is useful for accessing the field via an interface.
func (v *DateComparator) GetNeq() *time.Time { return v.Neq }

// GetNin returns DateComparator.Nin, and is useful for accessing the field via an interface.
func (v *DateComparator) GetNin() []*time.Time { return v.Nin }

func (v *DateComparator) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*DateComparator
		Eq  json.RawMessage   `json:"eq"`
		Gt  json.RawMessage   `json:"gt"`
		Gte json.RawMessage   `json:"gte"`
		In  []json.RawMessage `json:"in"`
		Lt  json.RawMessage   `json:"lt"`
		Lte json.RawMessage   `json:"lte"`
		Neq json.RawMessage   `json:"neq"`
		Nin []json.RawMessage `json:"nin"`
		graphql.NoUnmarshalJSON
	}
	firstPass.DateComparator = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.Eq
		src := firstPass.Eq
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal DateComparator.Eq: %w", err)
			}
		}
	}

	{
		dst := &v.Gt
		src := firstPass.Gt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal DateComparator.Gt: %w", err)
			}
		}
	}

	{
		dst := &v.Gte
		src := firstPass.Gte
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal DateComparator.Gte: %w", err)
			}
		}
	}

	{
		dst := &v.In
		src := firstPass.In
		*dst = make(
			[]*time.Time,
			len(src))
		for i, src := range src {
			dst := &(*dst)[i]
			if len(src) != 0 && string(src) != "null" {
				*dst = new(time.Time)
				err = utils.UnmarshalDateTime(
					src, *dst)
				if err != nil {
					return fmt.Errorf(
						"unable to unmarshal DateComparator.In: %w", err)
				}
			}
		}
	}

	{
		dst := &v.Lt
		src := firstPass.Lt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal DateComparator.Lt: %w", err)
			}
		}
	}

	{
		dst := &v.Lte
		src := firstPass.Lte
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal DateComparator.Lte: %w", err)
			}
		}
	}

	{
		dst := &v.Neq
		src := firstPass.Neq
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal DateComparator.Neq: %w", err)
			}
		}
	}

	{
		dst := &v.Nin
		src := firstPass.Nin
		*dst = make(
			[]*time.Time,
			len(src))
		for i, src := range src {
			dst := &(*dst)[i]
			if len(src) != 0 && string(src) != "null" {
				*dst = new(time.Time)
				err = utils.UnmarshalDateTime(
					src, *dst)
				if err != nil {
					return fmt.Errorf(
						"unable to unmarshal DateComparator.Nin: %w", err)
				}
			}
		}
	}
	return nil
}

type __premarshalDateComparator struct {
	Eq json.RawMessage `json:"eq,omitempty"`

	Gt json.RawMessage `json:"gt,omitempty"`

	Gte json.RawMessage `json:"gte,omitempty"`

	In []json.RawMessage `json:"in,omitempty"`

	Lt json.RawMessage `json:"lt,omitempty"`

	Lte json.RawMessage `json:"lte,omitempty"`

	Neq json.RawMessage `json:"neq,omitempty"`

	Nin []json.RawMessage `json:"nin,omitempty"`
}

func (v *DateComparator) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *DateComparator) __premarshalJSON() (*__premarshalDateComparator, error) {
	var retval __premarshalDateComparator

	{

		dst := &retval.Eq
		src := v.Eq
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal DateComparator.Eq: %w", err)
			}
		}
	}
	{

		dst := &retval.Gt
		src := v.Gt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal DateComparator.Gt: %w", err)
			}
		}
	}
	{

		dst := &retval.Gte
		src := v.Gte
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal DateComparator.Gte: %w", err)
			}
		}
	}
	{

		dst := &retval.In
		src := v.In
		*dst = make(
			[]json.RawMessage,
			len(src))
		for i, src := range src {
			dst := &(*dst)[i]
			if src != nil {
				var err error
				*dst, err = json.Marshal(
					src)
				if err != nil {
					return nil, fmt.Errorf(
						"unable to marshal DateComparator.In: %w", err)
				}
			}
		}
	}
	{

		dst := &retval.Lt
		src := v.Lt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal DateComparator.Lt: %w", err)
			}
		}
	}
	{

		dst := &retval.Lte
		src := v.Lte
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal DateComparator.Lte: %w", err)
			}
		}
	}
	{

		dst := &retval.Neq
		src := v.Neq
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal DateComparator.Neq: %w", err)
			}
		}
	}
	{

		dst := &retval.Nin
		src := v.Nin
		*dst = make(
			[]json.RawMessage,
			len(src))
		for i, src := range src {
			dst := &(*dst)[i]
			if src != nil {
				var err error
				*dst, err = json.Marshal(
					src)
				if err != nil {
					return nil, fmt.Errorf(
						"unable to marshal DateComparator.Nin: %w", err)
				}
			}
		}
	}
	return &retval, nil
}

// The day of the week.
type Day string

const (
	DayFriday    Day = "Friday"
	DayMonday    Day = "Monday"
	DaySaturday  Day = "Saturday"
	DaySunday    Day = "Sunday"
	DayThursday  Day = "Thursday"
	DayTuesday   Day = "Tuesday"
	DayWednesday Day = "Wednesday"
)

// Comparator for estimates.
type EstimateComparator struct {
	// Compound filters, one of which need to be matched by the estimate.
	And []*NullableNumberComparator `json:"and,omitempty"`
	// Equals constraint.
	Eq *float64 `json:"eq,omitempty"`
	// Greater-than constraint. Matches any values that are greater than the given value.
	Gt *float64 `json:"gt,omitempty"`
	// Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value.
	Gte *float64 `json:"gte,omitempty"`
	// In-array constraint.
	In []*float64 `json:"in,omitempty"`
	// Less-than constraint. Matches any values that are less than the given value.
	Lt *float64 `json:"lt,omitempty"`
	// Less-than-or-equal constraint. Matches any values that are less than or equal to the given value.
	Lte *float64 `json:"lte,omitempty"`
	// Not-equals constraint.
	Neq *float64 `json:"neq,omitempty"`
	// Not-in-array constraint.
	Nin []*float64 `json:"nin,omitempty"`
	// Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values.
	Null *bool `json:"null,omitempty"`
	// Compound filters, all of which need to be matched by the estimate.
	Or []*NullableNumberComparator `json:"or,omitempty"`
}

// GetAnd returns EstimateComparator.And, and is useful for accessing the field via an interface.
func (v *EstimateComparator) GetAnd() []*NullableNumberComparator { return v.And }

// GetEq returns EstimateComparator.Eq, and is useful for accessing the field via an interface.
func (v *EstimateComparator) GetEq() *float64 { return v.Eq }

// GetGt returns EstimateComparator.Gt, and is useful for accessing the field via an interface.
func (v *EstimateComparator) GetGt() *float64 { return v.Gt }

// GetGte returns EstimateComparator.Gte, and is useful for accessing the field via an interface.
func (v *EstimateComparator) GetGte() *float64 { return v.Gte }

// GetIn returns EstimateComparator.In, and is useful for accessing the field via an interface.
func (v *EstimateComparator) GetIn() []*float64 { return v.In }

// GetLt returns EstimateComparator.Lt, and is useful for accessing the field via an interface.
func (v *EstimateComparator) GetLt() *float64 { return v.Lt }

// GetLte returns EstimateComparator.Lte, and is useful for accessing the field via an interface.
func (v *EstimateComparator) GetLte() *float64 { return v.Lte }

// GetNeq returns EstimateComparator.Neq, and is useful for accessing the field via an interface.
func (v *EstimateComparator) GetNeq() *float64 { return v.Neq }

// GetNin returns EstimateComparator.Nin, and is useful for accessing the field via an interface.
func (v *EstimateComparator) GetNin() []*float64 { return v.Nin }

// GetNull returns EstimateComparator.Null, and is useful for accessing the field via an interface.
func (v *EstimateComparator) GetNull() *bool { return v.Null }

// GetOr returns EstimateComparator.Or, and is useful for accessing the field via an interface.
func (v *EstimateComparator) GetOr() []*NullableNumberComparator { return v.Or }

// Comparator for identifiers.
type IDComparator struct {
	// Equals constraint.
	Eq *string `json:"eq,omitempty"`
	// In-array constraint.
	In []*string `json:"in,omitempty"`
	// Not-equals constraint.
	Neq *string `json:"neq,omitempty"`
	// Not-in-array constraint.
	Nin []*string `json:"nin,omitempty"`
}

// GetEq returns IDComparator.Eq, and is useful for accessing the field via an interface.
func (v *IDComparator) GetEq() *string { return v.Eq }

// GetIn returns IDComparator.In, and is useful for accessing the field via an interface.
func (v *IDComparator) GetIn() []*string { return v.In }

// GetNeq returns IDComparator.Neq, and is useful for accessing the field via an interface.
func (v *IDComparator) GetNeq() *string { return v.Neq }

// GetNin returns IDComparator.Nin, and is useful for accessing the field via an interface.
func (v *IDComparator) GetNin() []*string { return v.Nin }

// Issue filtering options.
type IssueCollectionFilter struct {
	// Compound filters, all of which need to be matched by the issue.
	And []*IssueCollectionFilter `json:"and,omitempty"`
	// Filters that the issues assignee must satisfy.
	Assignee *NullableUserFilter `json:"assignee,omitempty"`
	// Filters that the issues attachments must satisfy.
	Attachments *AttachmentCollectionFilter `json:"attachments,omitempty"`
	// Comparator for the issues auto archived at date.
	AutoArchivedAt *NullableDateComparator `json:"autoArchivedAt,omitempty"`
	// Comparator for the issues auto closed at date.
	AutoClosedAt *NullableDateComparator `json:"autoClosedAt,omitempty"`
	// Comparator for the issues canceled at date.
	CanceledAt *NullableDateComparator `json:"canceledAt,omitempty"`
	// Filters that the child issues must satisfy.
	Children *IssueCollectionFilter `json:"children,omitempty"`
	// Filters that the issues comments must satisfy.
	Comments *CommentCollectionFilter `json:"comments,omitempty"`
	// Comparator for the issues completed at date.
	CompletedAt *NullableDateComparator `json:"completedAt,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Filters that the issues creator must satisfy.
	Creator *NullableUserFilter `json:"creator,omitempty"`
	// Filters that the issues cycle must satisfy.
	Cycle *NullableCycleFilter `json:"cycle,omitempty"`
	// Comparator for the issues description.
	Description *NullableStringComparator `json:"description,omitempty"`
	// Comparator for the issues due date.
	DueDate *NullableTimelessDateComparator `json:"dueDate,omitempty"`
	// Comparator for the issues estimate.
	Estimate *EstimateComparator `json:"estimate,omitempty"`
	// Filters that needs to be matched by all issues.
	Every *IssueFilter `json:"every,omitempty"`
	// Comparator for filtering issues which are blocked.
	HasBlockedByRelations *RelationExistsComparator `json:"hasBlockedByRelations,omitempty"`
	// Comparator for filtering issues which are blocking.
	HasBlockingRelations *RelationExistsComparator `json:"hasBlockingRelations,omitempty"`
	// Comparator for filtering issues which are duplicates.
	HasDuplicateRelations *RelationExistsComparator `json:"hasDuplicateRelations,omitempty"`
	// Comparator for filtering issues with relations.
	HasRelatedRelations *RelationExistsComparator `json:"hasRelatedRelations,omitempty"`
	// Comparator for the identifier.
	Id *IDComparator `json:"id,omitempty"`
	// Filters that issue labels must satisfy.
	Labels *IssueLabelCollectionFilter `json:"labels,omitempty"`
	// Comparator for the collection length.
	Length *NumberComparator `json:"length,omitempty"`
	// Comparator for the issues number.
	Number *NumberComparator `json:"number,omitempty"`
	// Compound filters, one of which need to be matched by the issue.
	Or []*IssueCollectionFilter `json:"or,omitempty"`
	// Filters that the issue parent must satisfy.
	Parent *NullableIssueFilter `json:"parent,omitempty"`
	// Comparator for the issues priority.
	Priority *NullableNumberComparator `json:"priority,omitempty"`
	// Filters that the issues project must satisfy.
	Project *NullableProjectFilter `json:"project,omitempty"`
	// Filters that the issues project milestone must satisfy.
	ProjectMilestone *NullableProjectMilestoneFilter `json:"projectMilestone,omitempty"`
	// [Internal] Comparator for the issues content.
	SearchableContent *ContentComparator `json:"searchableContent,omitempty"`
	// Comparator for the issues sla status.
	SlaStatus *SlaStatusComparator `json:"slaStatus,omitempty"`
	// Filters that the issues snoozer must satisfy.
	SnoozedBy *NullableUserFilter `json:"snoozedBy,omitempty"`
	// Comparator for the issues snoozed until date.
	SnoozedUntilAt *NullableDateComparator `json:"snoozedUntilAt,omitempty"`
	// Filters that needs to be matched by some issues.
	Some *IssueFilter `json:"some,omitempty"`
	// Comparator for the issues started at date.
	StartedAt *NullableDateComparator `json:"startedAt,omitempty"`
	// Filters that the issues state must satisfy.
	State *WorkflowStateFilter `json:"state,omitempty"`
	// Filters that issue subscribers must satisfy.
	Subscribers *UserCollectionFilter `json:"subscribers,omitempty"`
	// Filters that the issues team must satisfy.
	Team *TeamFilter `json:"team,omitempty"`
	// Comparator for the issues title.
	Title *StringComparator `json:"title,omitempty"`
	// Comparator for the issues triaged at date.
	TriagedAt *NullableDateComparator `json:"triagedAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
}

// GetAnd returns IssueCollectionFilter.And, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetAnd() []*IssueCollectionFilter { return v.And }

// GetAssignee returns IssueCollectionFilter.Assignee, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetAssignee() *NullableUserFilter { return v.Assignee }

// GetAttachments returns IssueCollectionFilter.Attachments, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetAttachments() *AttachmentCollectionFilter { return v.Attachments }

// GetAutoArchivedAt returns IssueCollectionFilter.AutoArchivedAt, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetAutoArchivedAt() *NullableDateComparator { return v.AutoArchivedAt }

// GetAutoClosedAt returns IssueCollectionFilter.AutoClosedAt, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetAutoClosedAt() *NullableDateComparator { return v.AutoClosedAt }

// GetCanceledAt returns IssueCollectionFilter.CanceledAt, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetCanceledAt() *NullableDateComparator { return v.CanceledAt }

// GetChildren returns IssueCollectionFilter.Children, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetChildren() *IssueCollectionFilter { return v.Children }

// GetComments returns IssueCollectionFilter.Comments, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetComments() *CommentCollectionFilter { return v.Comments }

// GetCompletedAt returns IssueCollectionFilter.CompletedAt, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetCompletedAt() *NullableDateComparator { return v.CompletedAt }

// GetCreatedAt returns IssueCollectionFilter.CreatedAt, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetCreatedAt() *DateComparator { return v.CreatedAt }

// GetCreator returns IssueCollectionFilter.Creator, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetCreator() *NullableUserFilter { return v.Creator }

// GetCycle returns IssueCollectionFilter.Cycle, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetCycle() *NullableCycleFilter { return v.Cycle }

// GetDescription returns IssueCollectionFilter.Description, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetDescription() *NullableStringComparator { return v.Description }

// GetDueDate returns IssueCollectionFilter.DueDate, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetDueDate() *NullableTimelessDateComparator { return v.DueDate }

// GetEstimate returns IssueCollectionFilter.Estimate, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetEstimate() *EstimateComparator { return v.Estimate }

// GetEvery returns IssueCollectionFilter.Every, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetEvery() *IssueFilter { return v.Every }

// GetHasBlockedByRelations returns IssueCollectionFilter.HasBlockedByRelations, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetHasBlockedByRelations() *RelationExistsComparator {
	return v.HasBlockedByRelations
}

// GetHasBlockingRelations returns IssueCollectionFilter.HasBlockingRelations, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetHasBlockingRelations() *RelationExistsComparator {
	return v.HasBlockingRelations
}

// GetHasDuplicateRelations returns IssueCollectionFilter.HasDuplicateRelations, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetHasDuplicateRelations() *RelationExistsComparator {
	return v.HasDuplicateRelations
}

// GetHasRelatedRelations returns IssueCollectionFilter.HasRelatedRelations, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetHasRelatedRelations() *RelationExistsComparator {
	return v.HasRelatedRelations
}

// GetId returns IssueCollectionFilter.Id, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetId() *IDComparator { return v.Id }

// GetLabels returns IssueCollectionFilter.Labels, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetLabels() *IssueLabelCollectionFilter { return v.Labels }

// GetLength returns IssueCollectionFilter.Length, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetLength() *NumberComparator { return v.Length }

// GetNumber returns IssueCollectionFilter.Number, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetNumber() *NumberComparator { return v.Number }

// GetOr returns IssueCollectionFilter.Or, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetOr() []*IssueCollectionFilter { return v.Or }

// GetParent returns IssueCollectionFilter.Parent, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetParent() *NullableIssueFilter { return v.Parent }

// GetPriority returns IssueCollectionFilter.Priority, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetPriority() *NullableNumberComparator { return v.Priority }

// GetProject returns IssueCollectionFilter.Project, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetProject() *NullableProjectFilter { return v.Project }

// GetProjectMilestone returns IssueCollectionFilter.ProjectMilestone, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetProjectMilestone() *NullableProjectMilestoneFilter {
	return v.ProjectMilestone
}

// GetSearchableContent returns IssueCollectionFilter.SearchableContent, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetSearchableContent() *ContentComparator { return v.SearchableContent }

// GetSlaStatus returns IssueCollectionFilter.SlaStatus, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetSlaStatus() *SlaStatusComparator { return v.SlaStatus }

// GetSnoozedBy returns IssueCollectionFilter.SnoozedBy, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetSnoozedBy() *NullableUserFilter { return v.SnoozedBy }

// GetSnoozedUntilAt returns IssueCollectionFilter.SnoozedUntilAt, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetSnoozedUntilAt() *NullableDateComparator { return v.SnoozedUntilAt }

// GetSome returns IssueCollectionFilter.Some, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetSome() *IssueFilter { return v.Some }

// GetStartedAt returns IssueCollectionFilter.StartedAt, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetStartedAt() *NullableDateComparator { return v.StartedAt }

// GetState returns IssueCollectionFilter.State, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetState() *WorkflowStateFilter { return v.State }

// GetSubscribers returns IssueCollectionFilter.Subscribers, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetSubscribers() *UserCollectionFilter { return v.Subscribers }

// GetTeam returns IssueCollectionFilter.Team, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetTeam() *TeamFilter { return v.Team }

// GetTitle returns IssueCollectionFilter.Title, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetTitle() *StringComparator { return v.Title }

// GetTriagedAt returns IssueCollectionFilter.TriagedAt, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetTriagedAt() *NullableDateComparator { return v.TriagedAt }

// GetUpdatedAt returns IssueCollectionFilter.UpdatedAt, and is useful for accessing the field via an interface.
func (v *IssueCollectionFilter) GetUpdatedAt() *DateComparator { return v.UpdatedAt }

// Issue filtering options.
type IssueFilter struct {
	// Compound filters, all of which need to be matched by the issue.
	And []*IssueFilter `json:"and,omitempty"`
	// Filters that the issues assignee must satisfy.
	Assignee *NullableUserFilter `json:"assignee,omitempty"`
	// Filters that the issues attachments must satisfy.
	Attachments *AttachmentCollectionFilter `json:"attachments,omitempty"`
	// Comparator for the issues auto archived at date.
	AutoArchivedAt *NullableDateComparator `json:"autoArchivedAt,omitempty"`
	// Comparator for the issues auto closed at date.
	AutoClosedAt *NullableDateComparator `json:"autoClosedAt,omitempty"`
	// Comparator for the issues canceled at date.
	CanceledAt *NullableDateComparator `json:"canceledAt,omitempty"`
	// Filters that the child issues must satisfy.
	Children *IssueCollectionFilter `json:"children,omitempty"`
	// Filters that the issues comments must satisfy.
	Comments *CommentCollectionFilter `json:"comments,omitempty"`
	// Comparator for the issues completed at date.
	CompletedAt *NullableDateComparator `json:"completedAt,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Filters that the issues creator must satisfy.
	Creator *NullableUserFilter `json:"creator,omitempty"`
	// Filters that the issues cycle must satisfy.
	Cycle *NullableCycleFilter `json:"cycle,omitempty"`
	// Comparator for the issues description.
	Description *NullableStringComparator `json:"description,omitempty"`
	// Comparator for the issues due date.
	DueDate *NullableTimelessDateComparator `json:"dueDate,omitempty"`
	// Comparator for the issues estimate.
	Estimate *EstimateComparator `json:"estimate,omitempty"`
	// Comparator for filtering issues which are blocked.
	HasBlockedByRelations *RelationExistsComparator `json:"hasBlockedByRelations,omitempty"`
	// Comparator for filtering issues which are blocking.
	HasBlockingRelations *RelationExistsComparator `json:"hasBlockingRelations,omitempty"`
	// Comparator for filtering issues which are duplicates.
	HasDuplicateRelations *RelationExistsComparator `json:"hasDuplicateRelations,omitempty"`
	// Comparator for filtering issues with relations.
	HasRelatedRelations *RelationExistsComparator `json:"hasRelatedRelations,omitempty"`
	// Comparator for the identifier.
	Id *IDComparator `json:"id,omitempty"`
	// Filters that issue labels must satisfy.
	Labels *IssueLabelCollectionFilter `json:"labels,omitempty"`
	// Comparator for the issues number.
	Number *NumberComparator `json:"number,omitempty"`
	// Compound filters, one of which need to be matched by the issue.
	Or []*IssueFilter `json:"or,omitempty"`
	// Filters that the issue parent must satisfy.
	Parent *NullableIssueFilter `json:"parent,omitempty"`
	// Comparator for the issues priority.
	Priority *NullableNumberComparator `json:"priority,omitempty"`
	// Filters that the issues project must satisfy.
	Project *NullableProjectFilter `json:"project,omitempty"`
	// Filters that the issues project milestone must satisfy.
	ProjectMilestone *NullableProjectMilestoneFilter `json:"projectMilestone,omitempty"`
	// [Internal] Comparator for the issues content.
	SearchableContent *ContentComparator `json:"searchableContent,omitempty"`
	// Comparator for the issues sla status.
	SlaStatus *SlaStatusComparator `json:"slaStatus,omitempty"`
	// Filters that the issues snoozer must satisfy.
	SnoozedBy *NullableUserFilter `json:"snoozedBy,omitempty"`
	// Comparator for the issues snoozed until date.
	SnoozedUntilAt *NullableDateComparator `json:"snoozedUntilAt,omitempty"`
	// Comparator for the issues started at date.
	StartedAt *NullableDateComparator `json:"startedAt,omitempty"`
	// Filters that the issues state must satisfy.
	State *WorkflowStateFilter `json:"state,omitempty"`
	// Filters that issue subscribers must satisfy.
	Subscribers *UserCollectionFilter `json:"subscribers,omitempty"`
	// Filters that the issues team must satisfy.
	Team *TeamFilter `json:"team,omitempty"`
	// Comparator for the issues title.
	Title *StringComparator `json:"title,omitempty"`
	// Comparator for the issues triaged at date.
	TriagedAt *NullableDateComparator `json:"triagedAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
}

// GetAnd returns IssueFilter.And, and is useful for accessing the field via an interface.
func (v *IssueFilter) GetAnd() []*IssueFilter { return v.And }

// GetAssignee returns IssueFilter.Assignee, and is useful for accessing the field via an interface.
func (v *IssueFilter) GetAssignee() *NullableUserFilter { return v.Assignee }

// GetAttachments returns IssueFilter.Attachments, and is useful for accessing the field via an interface.
func (v *IssueFilter) GetAttachments() *AttachmentCollectionFilter { return v.Attachments }

// GetAutoArchivedAt returns IssueFilter.AutoArchivedAt, and is useful for accessing the field via an interface.
func (v *IssueFilter) GetAutoArchivedAt() *NullableDateComparator { return v.AutoArchivedAt }

// GetAutoClosedAt returns IssueFilter.AutoClosedAt, and is useful for accessing the field via an interface.
func (v *IssueFilter) GetAutoClosedAt() *NullableDateComparator { return v.AutoClosedAt }

// GetCanceledAt returns IssueFilter.CanceledAt, and is useful for accessing the field via an interface.
func (v *IssueFilter) GetCanceledAt() *NullableDateComparator { return v.CanceledAt }

// GetChildren returns IssueFilter.Children, and is useful for accessing the field via an interface.
func (v *IssueFilter) GetChildren() *IssueCollectionFilter { return v.Children }

// GetComments returns IssueFilter.Comments, and is useful for accessing the field via an interface.
func (v *IssueFilter) GetComments() *CommentCollectionFilter { return v.Comments }

// GetCompletedAt returns IssueFilter.CompletedAt, and is useful for accessing the field via an interface.
func (v *IssueFilter) GetCompletedAt() *NullableDateComparator { return v.CompletedAt }

// GetCreatedAt returns IssueFilter.CreatedAt, and is useful for accessing the field via an interface.
func (v *IssueFilter) GetCreatedAt() *DateComparator { return v.CreatedAt }

// GetCreator returns IssueFilter.Creator, and is useful for accessing the field via an interface.
func (v *IssueFilter) GetCreator() *NullableUserFilter { return v.Creator }

// GetCycle returns IssueFilter.Cycle, and is useful for accessing the field via an interface.
func (v *IssueFilter) GetCycle() *NullableCycleFilter { return v.Cycle }

// GetDescription returns IssueFilter.Description, and is useful for accessing the field via an interface.
func (v *IssueFilter) GetDescription() *NullableStringComparator { return v.Description }

// GetDueDate returns IssueFilter.DueDate, and is useful for accessing the field via an interface.
func (v *IssueFilter) GetDueDate() *NullableTimelessDateComparator { return v.DueDate }

// GetEstimate returns IssueFilter.Estimate, and is useful for accessing the field via an interface.
func (v *IssueFilter) GetEstimate() *EstimateComparator { return v.Estimate }

// GetHasBlockedByRelations returns IssueFilter.HasBlockedByRelations, and is useful for accessing the field via an interface.
func (v *IssueFilter) GetHasBlockedByRelations() *RelationExistsComparator {
	return v.HasBlockedByRelations
}

// GetHasBlockingRelations returns IssueFilter.HasBlockingRelations, and is useful for accessing the field via an interface.
func (v *IssueFilter) GetHasBlockingRelations() *RelationExistsComparator {
	return v.HasBlockingRelations
}

// GetHasDuplicateRelations returns IssueFilter.HasDuplicateRelations, and is useful for accessing the field via an interface.
func (v *IssueFilter) GetHasDuplicateRelations() *RelationExistsComparator {
	return v.HasDuplicateRelations
}

// GetHasRelatedRelations returns IssueFilter.HasRelatedRelations, and is useful for accessing the field via an interface.
func (v *IssueFilter) GetHasRelatedRelations() *RelationExistsComparator {
	return v.HasRelatedRelations
}

// GetId returns IssueFilter.Id, and is useful for accessing the field via an interface.
func (v *IssueFilter) GetId() *IDComparator { return v.Id }

// GetLabels returns IssueFilter.Labels, and is useful for accessing the field via an interface.
func (v *IssueFilter) GetLabels() *IssueLabelCollectionFilter { return v.Labels }

// GetNumber returns IssueFilter.Number, and is useful for accessing the field via an interface.
func (v *IssueFilter) GetNumber() *NumberComparator { return v.Number }

// GetOr returns IssueFilter.Or, and is useful for accessing the field via an interface.
func (v *IssueFilter) GetOr() []*IssueFilter { return v.Or }

// GetParent returns IssueFilter.Parent, and is useful for accessing the field via an interface.
func (v *IssueFilter) GetParent() *NullableIssueFilter { return v.Parent }

// GetPriority returns IssueFilter.Priority, and is useful for accessing the field via an interface.
func (v *IssueFilter) GetPriority() *NullableNumberComparator { return v.Priority }

// GetProject returns IssueFilter.Project, and is useful for accessing the field via an interface.
func (v *IssueFilter) GetProject() *NullableProjectFilter { return v.Project }

// GetProjectMilestone returns IssueFilter.ProjectMilestone, and is useful for accessing the field via an interface.
func (v *IssueFilter) GetProjectMilestone() *NullableProjectMilestoneFilter {
	return v.ProjectMilestone
}

// GetSearchableContent returns IssueFilter.SearchableContent, and is useful for accessing the field via an interface.
func (v *IssueFilter) GetSearchableContent() *ContentComparator { return v.SearchableContent }

// GetSlaStatus returns IssueFilter.SlaStatus, and is useful for accessing the field via an interface.
func (v *IssueFilter) GetSlaStatus() *SlaStatusComparator { return v.SlaStatus }

// GetSnoozedBy returns IssueFilter.SnoozedBy, and is useful for accessing the field via an interface.
func (v *IssueFilter) GetSnoozedBy() *NullableUserFilter { return v.SnoozedBy }

// GetSnoozedUntilAt returns IssueFilter.SnoozedUntilAt, and is useful for accessing the field via an interface.
func (v *IssueFilter) GetSnoozedUntilAt() *NullableDateComparator { return v.SnoozedUntilAt }

// GetStartedAt returns IssueFilter.StartedAt, and is useful for accessing the field via an interface.
func (v *IssueFilter) GetStartedAt() *NullableDateComparator { return v.StartedAt }

// GetState returns IssueFilter.State, and is useful for accessing the field via an interface.
func (v *IssueFilter) GetState() *WorkflowStateFilter { return v.State }

// GetSubscribers returns IssueFilter.Subscribers, and is useful for accessing the field via an interface.
func (v *IssueFilter) GetSubscribers() *UserCollectionFilter { return v.Subscribers }

// GetTeam returns IssueFilter.Team, and is useful for accessing the field via an interface.
func (v *IssueFilter) GetTeam() *TeamFilter { return v.Team }

// GetTitle returns IssueFilter.Title, and is useful for accessing the field via an interface.
func (v *IssueFilter) GetTitle() *StringComparator { return v.Title }

// GetTriagedAt returns IssueFilter.TriagedAt, and is useful for accessing the field via an interface.
func (v *IssueFilter) GetTriagedAt() *NullableDateComparator { return v.TriagedAt }

// GetUpdatedAt returns IssueFilter.UpdatedAt, and is useful for accessing the field via an interface.
func (v *IssueFilter) GetUpdatedAt() *DateComparator { return v.UpdatedAt }

// Issue label filtering options.
type IssueLabelCollectionFilter struct {
	// Compound filters, all of which need to be matched by the label.
	And []*IssueLabelCollectionFilter `json:"and,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Filters that the issue labels creator must satisfy.
	Creator *NullableUserFilter `json:"creator,omitempty"`
	// Filters that needs to be matched by all issue labels.
	Every *IssueLabelFilter `json:"every,omitempty"`
	// Comparator for the identifier.
	Id *IDComparator `json:"id,omitempty"`
	// Comparator for the collection length.
	Length *NumberComparator `json:"length,omitempty"`
	// Comparator for the name.
	Name *StringComparator `json:"name,omitempty"`
	// Compound filters, one of which need to be matched by the label.
	Or []*IssueLabelCollectionFilter `json:"or,omitempty"`
	// Filters that the issue label's parent label must satisfy.
	Parent *IssueLabelFilter `json:"parent,omitempty"`
	// Filters that needs to be matched by some issue labels.
	Some *IssueLabelFilter `json:"some,omitempty"`
	// Filters that the issue labels team must satisfy.
	Team *TeamFilter `json:"team,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
}

// GetAnd returns IssueLabelCollectionFilter.And, and is useful for accessing the field via an interface.
func (v *IssueLabelCollectionFilter) GetAnd() []*IssueLabelCollectionFilter { return v.And }

// GetCreatedAt returns IssueLabelCollectionFilter.CreatedAt, and is useful for accessing the field via an interface.
func (v *IssueLabelCollectionFilter) GetCreatedAt() *DateComparator { return v.CreatedAt }

// GetCreator returns IssueLabelCollectionFilter.Creator, and is useful for accessing the field via an interface.
func (v *IssueLabelCollectionFilter) GetCreator() *NullableUserFilter { return v.Creator }

// GetEvery returns IssueLabelCollectionFilter.Every, and is useful for accessing the field via an interface.
func (v *IssueLabelCollectionFilter) GetEvery() *IssueLabelFilter { return v.Every }

// GetId returns IssueLabelCollectionFilter.Id, and is useful for accessing the field via an interface.
func (v *IssueLabelCollectionFilter) GetId() *IDComparator { return v.Id }

// GetLength returns IssueLabelCollectionFilter.Length, and is useful for accessing the field via an interface.
func (v *IssueLabelCollectionFilter) GetLength() *NumberComparator { return v.Length }

// GetName returns IssueLabelCollectionFilter.Name, and is useful for accessing the field via an interface.
func (v *IssueLabelCollectionFilter) GetName() *StringComparator { return v.Name }

// GetOr returns IssueLabelCollectionFilter.Or, and is useful for accessing the field via an interface.
func (v *IssueLabelCollectionFilter) GetOr() []*IssueLabelCollectionFilter { return v.Or }

// GetParent returns IssueLabelCollectionFilter.Parent, and is useful for accessing the field via an interface.
func (v *IssueLabelCollectionFilter) GetParent() *IssueLabelFilter { return v.Parent }

// GetSome returns IssueLabelCollectionFilter.Some, and is useful for accessing the field via an interface.
func (v *IssueLabelCollectionFilter) GetSome() *IssueLabelFilter { return v.Some }

// GetTeam returns IssueLabelCollectionFilter.Team, and is useful for accessing the field via an interface.
func (v *IssueLabelCollectionFilter) GetTeam() *TeamFilter { return v.Team }

// GetUpdatedAt returns IssueLabelCollectionFilter.UpdatedAt, and is useful for accessing the field via an interface.
func (v *IssueLabelCollectionFilter) GetUpdatedAt() *DateComparator { return v.UpdatedAt }

// Issue label filtering options.
type IssueLabelFilter struct {
	// Compound filters, all of which need to be matched by the label.
	And []*IssueLabelFilter `json:"and,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Filters that the issue labels creator must satisfy.
	Creator *NullableUserFilter `json:"creator,omitempty"`
	// Comparator for the identifier.
	Id *IDComparator `json:"id,omitempty"`
	// Comparator for the name.
	Name *StringComparator `json:"name,omitempty"`
	// Compound filters, one of which need to be matched by the label.
	Or []*IssueLabelFilter `json:"or,omitempty"`
	// Filters that the issue label's parent label must satisfy.
	Parent *IssueLabelFilter `json:"parent,omitempty"`
	// Filters that the issue labels team must satisfy.
	Team *TeamFilter `json:"team,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
}

// GetAnd returns IssueLabelFilter.And, and is useful for accessing the field via an interface.
func (v *IssueLabelFilter) GetAnd() []*IssueLabelFilter { return v.And }

// GetCreatedAt returns IssueLabelFilter.CreatedAt, and is useful for accessing the field via an interface.
func (v *IssueLabelFilter) GetCreatedAt() *DateComparator { return v.CreatedAt }

// GetCreator returns IssueLabelFilter.Creator, and is useful for accessing the field via an interface.
func (v *IssueLabelFilter) GetCreator() *NullableUserFilter { return v.Creator }

// GetId returns IssueLabelFilter.Id, and is useful for accessing the field via an interface.
func (v *IssueLabelFilter) GetId() *IDComparator { return v.Id }

// GetName returns IssueLabelFilter.Name, and is useful for accessing the field via an interface.
func (v *IssueLabelFilter) GetName() *StringComparator { return v.Name }

// GetOr returns IssueLabelFilter.Or, and is useful for accessing the field via an interface.
func (v *IssueLabelFilter) GetOr() []*IssueLabelFilter { return v.Or }

// GetParent returns IssueLabelFilter.Parent, and is useful for accessing the field via an interface.
func (v *IssueLabelFilter) GetParent() *IssueLabelFilter { return v.Parent }

// GetTeam returns IssueLabelFilter.Team, and is useful for accessing the field via an interface.
func (v *IssueLabelFilter) GetTeam() *TeamFilter { return v.Team }

// GetUpdatedAt returns IssueLabelFilter.UpdatedAt, and is useful for accessing the field via an interface.
func (v *IssueLabelFilter) GetUpdatedAt() *DateComparator { return v.UpdatedAt }

// Cycle filtering options.
type NullableCycleFilter struct {
	// Compound filters, one of which need to be matched by the cycle.
	And []*NullableCycleFilter `json:"and,omitempty"`
	// Comparator for the cycle completed at date.
	CompletedAt *DateComparator `json:"completedAt,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the cycle ends at date.
	EndsAt *DateComparator `json:"endsAt,omitempty"`
	// Comparator for the identifier.
	Id *IDComparator `json:"id,omitempty"`
	// Comparator for the filtering active cycle.
	IsActive *BooleanComparator `json:"isActive,omitempty"`
	// Comparator for the filtering future cycles.
	IsFuture *BooleanComparator `json:"isFuture,omitempty"`
	// Comparator for the filtering next cycle.
	IsNext *BooleanComparator `json:"isNext,omitempty"`
	// Comparator for the filtering past cycles.
	IsPast *BooleanComparator `json:"isPast,omitempty"`
	// Comparator for the filtering previous cycle.
	IsPrevious *BooleanComparator `json:"isPrevious,omitempty"`
	// Filters that the cycles issues must satisfy.
	Issues *IssueCollectionFilter `json:"issues,omitempty"`
	// Comparator for the cycle name.
	Name *StringComparator `json:"name,omitempty"`
	// Filter based on the existence of the relation.
	Null *bool `json:"null,omitempty"`
	// Comparator for the cycle number.
	Number *NumberComparator `json:"number,omitempty"`
	// Compound filters, one of which need to be matched by the cycle.
	Or []*NullableCycleFilter `json:"or,omitempty"`
	// Comparator for the cycle start date.
	StartsAt *DateComparator `json:"startsAt,omitempty"`
	// Filters that the cycles team must satisfy.
	Team *TeamFilter `json:"team,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
}

// GetAnd returns NullableCycleFilter.And, and is useful for accessing the field via an interface.
func (v *NullableCycleFilter) GetAnd() []*NullableCycleFilter { return v.And }

// GetCompletedAt returns NullableCycleFilter.CompletedAt, and is useful for accessing the field via an interface.
func (v *NullableCycleFilter) GetCompletedAt() *DateComparator { return v.CompletedAt }

// GetCreatedAt returns NullableCycleFilter.CreatedAt, and is useful for accessing the field via an interface.
func (v *NullableCycleFilter) GetCreatedAt() *DateComparator { return v.CreatedAt }

// GetEndsAt returns NullableCycleFilter.EndsAt, and is useful for accessing the field via an interface.
func (v *NullableCycleFilter) GetEndsAt() *DateComparator { return v.EndsAt }

// GetId returns NullableCycleFilter.Id, and is useful for accessing the field via an interface.
func (v *NullableCycleFilter) GetId() *IDComparator { return v.Id }

// GetIsActive returns NullableCycleFilter.IsActive, and is useful for accessing the field via an interface.
func (v *NullableCycleFilter) GetIsActive() *BooleanComparator { return v.IsActive }

// GetIsFuture returns NullableCycleFilter.IsFuture, and is useful for accessing the field via an interface.
func (v *NullableCycleFilter) GetIsFuture() *BooleanComparator { return v.IsFuture }

// GetIsNext returns NullableCycleFilter.IsNext, and is useful for accessing the field via an interface.
func (v *NullableCycleFilter) GetIsNext() *BooleanComparator { return v.IsNext }

// GetIsPast returns NullableCycleFilter.IsPast, and is useful for accessing the field via an interface.
func (v *NullableCycleFilter) GetIsPast() *BooleanComparator { return v.IsPast }

// GetIsPrevious returns NullableCycleFilter.IsPrevious, and is useful for accessing the field via an interface.
func (v *NullableCycleFilter) GetIsPrevious() *BooleanComparator { return v.IsPrevious }

// GetIssues returns NullableCycleFilter.Issues, and is useful for accessing the field via an interface.
func (v *NullableCycleFilter) GetIssues() *IssueCollectionFilter { return v.Issues }

// GetName returns NullableCycleFilter.Name, and is useful for accessing the field via an interface.
func (v *NullableCycleFilter) GetName() *StringComparator { return v.Name }

// GetNull returns NullableCycleFilter.Null, and is useful for accessing the field via an interface.
func (v *NullableCycleFilter) GetNull() *bool { return v.Null }

// GetNumber returns NullableCycleFilter.Number, and is useful for accessing the field via an interface.
func (v *NullableCycleFilter) GetNumber() *NumberComparator { return v.Number }

// GetOr returns NullableCycleFilter.Or, and is useful for accessing the field via an interface.
func (v *NullableCycleFilter) GetOr() []*NullableCycleFilter { return v.Or }

// GetStartsAt returns NullableCycleFilter.StartsAt, and is useful for accessing the field via an interface.
func (v *NullableCycleFilter) GetStartsAt() *DateComparator { return v.StartsAt }

// GetTeam returns NullableCycleFilter.Team, and is useful for accessing the field via an interface.
func (v *NullableCycleFilter) GetTeam() *TeamFilter { return v.Team }

// GetUpdatedAt returns NullableCycleFilter.UpdatedAt, and is useful for accessing the field via an interface.
func (v *NullableCycleFilter) GetUpdatedAt() *DateComparator { return v.UpdatedAt }

// Comparator for optional dates.
type NullableDateComparator struct {
	// Equals constraint.
	Eq *time.Time `json:"-"`
	// Greater-than constraint. Matches any values that are greater than the given value.
	Gt *time.Time `json:"-"`
	// Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value.
	Gte *time.Time `json:"-"`
	// In-array constraint.
	In []*time.Time `json:"-"`
	// Less-than constraint. Matches any values that are less than the given value.
	Lt *time.Time `json:"-"`
	// Less-than-or-equal constraint. Matches any values that are less than or equal to the given value.
	Lte *time.Time `json:"-"`
	// Not-equals constraint.
	Neq *time.Time `json:"-"`
	// Not-in-array constraint.
	Nin []*time.Time `json:"-"`
	// Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values.
	Null *bool `json:"null,omitempty"`
}

// GetEq returns NullableDateComparator.Eq, and is useful for accessing the field via an interface.
func (v *NullableDateComparator) GetEq() *time.Time { return v.Eq }

// GetGt returns NullableDateComparator.Gt, and is useful for accessing the field via an interface.
func (v *NullableDateComparator) GetGt() *time.Time { return v.Gt }

// GetGte returns NullableDateComparator.Gte, and is useful for accessing the field via an interface.
func (v *NullableDateComparator) GetGte() *time.Time { return v.Gte }

// GetIn returns NullableDateComparator.In, and is useful for accessing the field via an interface.
func (v *NullableDateComparator) GetIn() []*time.Time { return v.In }

// GetLt returns NullableDateComparator.Lt, and is useful for accessing the field via an interface.
func (v *NullableDateComparator) GetLt() *time.Time { return v.Lt }

// GetLte returns NullableDateComparator.Lte, and is useful for accessing the field via an interface.
func (v *NullableDateComparator) GetLte() *time.Time { return v.Lte }

// GetNeq returns NullableDateComparator.Neq, and is useful for accessing the field via an interface.
func (v *NullableDateComparator) GetNeq() *time.Time { return v.Neq }

// GetNin returns NullableDateComparator.Nin, and is useful for accessing the field via an interface.
func (v *NullableDateComparator) GetNin() []*time.Time { return v.Nin }

// GetNull returns NullableDateComparator.Null, and is useful for accessing the field via an interface.
func (v *NullableDateComparator) GetNull() *bool { return v.Null }

func (v *NullableDateComparator) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NullableDateComparator
		Eq  json.RawMessage   `json:"eq"`
		Gt  json.RawMessage   `json:"gt"`
		Gte json.RawMessage   `json:"gte"`
		In  []json.RawMessage `json:"in"`
		Lt  json.RawMessage   `json:"lt"`
		Lte json.RawMessage   `json:"lte"`
		Neq json.RawMessage   `json:"neq"`
		Nin []json.RawMessage `json:"nin"`
		graphql.NoUnmarshalJSON
	}
	firstPass.NullableDateComparator = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.Eq
		src := firstPass.Eq
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal NullableDateComparator.Eq: %w", err)
			}
		}
	}

	{
		dst := &v.Gt
		src := firstPass.Gt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal NullableDateComparator.Gt: %w", err)
			}
		}
	}

	{
		dst := &v.Gte
		src := firstPass.Gte
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal NullableDateComparator.Gte: %w", err)
			}
		}
	}

	{
		dst := &v.In
		src := firstPass.In
		*dst = make(
			[]*time.Time,
			len(src))
		for i, src := range src {
			dst := &(*dst)[i]
			if len(src) != 0 && string(src) != "null" {
				*dst = new(time.Time)
				err = utils.UnmarshalDateTime(
					src, *dst)
				if err != nil {
					return fmt.Errorf(
						"unable to unmarshal NullableDateComparator.In: %w", err)
				}
			}
		}
	}

	{
		dst := &v.Lt
		src := firstPass.Lt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal NullableDateComparator.Lt: %w", err)
			}
		}
	}

	{
		dst := &v.Lte
		src := firstPass.Lte
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal NullableDateComparator.Lte: %w", err)
			}
		}
	}

	{
		dst := &v.Neq
		src := firstPass.Neq
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal NullableDateComparator.Neq: %w", err)
			}
		}
	}

	{
		dst := &v.Nin
		src := firstPass.Nin
		*dst = make(
			[]*time.Time,
			len(src))
		for i, src := range src {
			dst := &(*dst)[i]
			if len(src) != 0 && string(src) != "null" {
				*dst = new(time.Time)
				err = utils.UnmarshalDateTime(
					src, *dst)
				if err != nil {
					return fmt.Errorf(
						"unable to unmarshal NullableDateComparator.Nin: %w", err)
				}
			}
		}
	}
	return nil
}

type __premarshalNullableDateComparator struct {
	Eq json.RawMessage `json:"eq,omitempty"`

	Gt json.RawMessage `json:"gt,omitempty"`

	Gte json.RawMessage `json:"gte,omitempty"`

	In []json.RawMessage `json:"in,omitempty"`

	Lt json.RawMessage `json:"lt,omitempty"`

	Lte json.RawMessage `json:"lte,omitempty"`

	Neq json.RawMessage `json:"neq,omitempty"`

	Nin []json.RawMessage `json:"nin,omitempty"`

	Null *bool `json:"null,omitempty"`
}

func (v *NullableDateComparator) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NullableDateComparator) __premarshalJSON() (*__premarshalNullableDateComparator, error) {
	var retval __premarshalNullableDateComparator

	{

		dst := &retval.Eq
		src := v.Eq
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal NullableDateComparator.Eq: %w", err)
			}
		}
	}
	{

		dst := &retval.Gt
		src := v.Gt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal NullableDateComparator.Gt: %w", err)
			}
		}
	}
	{

		dst := &retval.Gte
		src := v.Gte
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal NullableDateComparator.Gte: %w", err)
			}
		}
	}
	{

		dst := &retval.In
		src := v.In
		*dst = make(
			[]json.RawMessage,
			len(src))
		for i, src := range src {
			dst := &(*dst)[i]
			if src != nil {
				var err error
				*dst, err = json.Marshal(
					src)
				if err != nil {
					return nil, fmt.Errorf(
						"unable to marshal NullableDateComparator.In: %w", err)
				}
			}
		}
	}
	{

		dst := &retval.Lt
		src := v.Lt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal NullableDateComparator.Lt: %w", err)
			}
		}
	}
	{

		dst := &retval.Lte
		src := v.Lte
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal NullableDateComparator.Lte: %w", err)
			}
		}
	}
	{

		dst := &retval.Neq
		src := v.Neq
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal NullableDateComparator.Neq: %w", err)
			}
		}
	}
	{

		dst := &retval.Nin
		src := v.Nin
		*dst = make(
			[]json.RawMessage,
			len(src))
		for i, src := range src {
			dst := &(*dst)[i]
			if src != nil {
				var err error
				*dst, err = json.Marshal(
					src)
				if err != nil {
					return nil, fmt.Errorf(
						"unable to marshal NullableDateComparator.Nin: %w", err)
				}
			}
		}
	}
	retval.Null = v.Null
	return &retval, nil
}

// Issue filtering options.
type NullableIssueFilter struct {
	// Compound filters, all of which need to be matched by the issue.
	And []*NullableIssueFilter `json:"and,omitempty"`
	// Filters that the issues assignee must satisfy.
	Assignee *NullableUserFilter `json:"assignee,omitempty"`
	// Filters that the issues attachments must satisfy.
	Attachments *AttachmentCollectionFilter `json:"attachments,omitempty"`
	// Comparator for the issues auto archived at date.
	AutoArchivedAt *NullableDateComparator `json:"autoArchivedAt,omitempty"`
	// Comparator for the issues auto closed at date.
	AutoClosedAt *NullableDateComparator `json:"autoClosedAt,omitempty"`
	// Comparator for the issues canceled at date.
	CanceledAt *NullableDateComparator `json:"canceledAt,omitempty"`
	// Filters that the child issues must satisfy.
	Children *IssueCollectionFilter `json:"children,omitempty"`
	// Filters that the issues comments must satisfy.
	Comments *CommentCollectionFilter `json:"comments,omitempty"`
	// Comparator for the issues completed at date.
	CompletedAt *NullableDateComparator `json:"completedAt,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Filters that the issues creator must satisfy.
	Creator *NullableUserFilter `json:"creator,omitempty"`
	// Filters that the issues cycle must satisfy.
	Cycle *NullableCycleFilter `json:"cycle,omitempty"`
	// Comparator for the issues description.
	Description *NullableStringComparator `json:"description,omitempty"`
	// Comparator for the issues due date.
	DueDate *NullableTimelessDateComparator `json:"dueDate,omitempty"`
	// Comparator for the issues estimate.
	Estimate *EstimateComparator `json:"estimate,omitempty"`
	// Comparator for filtering issues which are blocked.
	HasBlockedByRelations *RelationExistsComparator `json:"hasBlockedByRelations,omitempty"`
	// Comparator for filtering issues which are blocking.
	HasBlockingRelations *RelationExistsComparator `json:"hasBlockingRelations,omitempty"`
	// Comparator for filtering issues which are duplicates.
	HasDuplicateRelations *RelationExistsComparator `json:"hasDuplicateRelations,omitempty"`
	// Comparator for filtering issues with relations.
	HasRelatedRelations *RelationExistsComparator `json:"hasRelatedRelations,omitempty"`
	// Comparator for the identifier.
	Id *IDComparator `json:"id,omitempty"`
	// Filters that issue labels must satisfy.
	Labels *IssueLabelCollectionFilter `json:"labels,omitempty"`
	// Filter based on the existence of the relation.
	Null *bool `json:"null,omitempty"`
	// Comparator for the issues number.
	Number *NumberComparator `json:"number,omitempty"`
	// Compound filters, one of which need to be matched by the issue.
	Or []*NullableIssueFilter `json:"or,omitempty"`
	// Filters that the issue parent must satisfy.
	Parent *NullableIssueFilter `json:"parent,omitempty"`
	// Comparator for the issues priority.
	Priority *NullableNumberComparator `json:"priority,omitempty"`
	// Filters that the issues project must satisfy.
	Project *NullableProjectFilter `json:"project,omitempty"`
	// Filters that the issues project milestone must satisfy.
	ProjectMilestone *NullableProjectMilestoneFilter `json:"projectMilestone,omitempty"`
	// [Internal] Comparator for the issues content.
	SearchableContent *ContentComparator `json:"searchableContent,omitempty"`
	// Comparator for the issues sla status.
	SlaStatus *SlaStatusComparator `json:"slaStatus,omitempty"`
	// Filters that the issues snoozer must satisfy.
	SnoozedBy *NullableUserFilter `json:"snoozedBy,omitempty"`
	// Comparator for the issues snoozed until date.
	SnoozedUntilAt *NullableDateComparator `json:"snoozedUntilAt,omitempty"`
	// Comparator for the issues started at date.
	StartedAt *NullableDateComparator `json:"startedAt,omitempty"`
	// Filters that the issues state must satisfy.
	State *WorkflowStateFilter `json:"state,omitempty"`
	// Filters that issue subscribers must satisfy.
	Subscribers *UserCollectionFilter `json:"subscribers,omitempty"`
	// Filters that the issues team must satisfy.
	Team *TeamFilter `json:"team,omitempty"`
	// Comparator for the issues title.
	Title *StringComparator `json:"title,omitempty"`
	// Comparator for the issues triaged at date.
	TriagedAt *NullableDateComparator `json:"triagedAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
}

// GetAnd returns NullableIssueFilter.And, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetAnd() []*NullableIssueFilter { return v.And }

// GetAssignee returns NullableIssueFilter.Assignee, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetAssignee() *NullableUserFilter { return v.Assignee }

// GetAttachments returns NullableIssueFilter.Attachments, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetAttachments() *AttachmentCollectionFilter { return v.Attachments }

// GetAutoArchivedAt returns NullableIssueFilter.AutoArchivedAt, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetAutoArchivedAt() *NullableDateComparator { return v.AutoArchivedAt }

// GetAutoClosedAt returns NullableIssueFilter.AutoClosedAt, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetAutoClosedAt() *NullableDateComparator { return v.AutoClosedAt }

// GetCanceledAt returns NullableIssueFilter.CanceledAt, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetCanceledAt() *NullableDateComparator { return v.CanceledAt }

// GetChildren returns NullableIssueFilter.Children, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetChildren() *IssueCollectionFilter { return v.Children }

// GetComments returns NullableIssueFilter.Comments, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetComments() *CommentCollectionFilter { return v.Comments }

// GetCompletedAt returns NullableIssueFilter.CompletedAt, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetCompletedAt() *NullableDateComparator { return v.CompletedAt }

// GetCreatedAt returns NullableIssueFilter.CreatedAt, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetCreatedAt() *DateComparator { return v.CreatedAt }

// GetCreator returns NullableIssueFilter.Creator, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetCreator() *NullableUserFilter { return v.Creator }

// GetCycle returns NullableIssueFilter.Cycle, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetCycle() *NullableCycleFilter { return v.Cycle }

// GetDescription returns NullableIssueFilter.Description, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetDescription() *NullableStringComparator { return v.Description }

// GetDueDate returns NullableIssueFilter.DueDate, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetDueDate() *NullableTimelessDateComparator { return v.DueDate }

// GetEstimate returns NullableIssueFilter.Estimate, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetEstimate() *EstimateComparator { return v.Estimate }

// GetHasBlockedByRelations returns NullableIssueFilter.HasBlockedByRelations, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetHasBlockedByRelations() *RelationExistsComparator {
	return v.HasBlockedByRelations
}

// GetHasBlockingRelations returns NullableIssueFilter.HasBlockingRelations, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetHasBlockingRelations() *RelationExistsComparator {
	return v.HasBlockingRelations
}

// GetHasDuplicateRelations returns NullableIssueFilter.HasDuplicateRelations, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetHasDuplicateRelations() *RelationExistsComparator {
	return v.HasDuplicateRelations
}

// GetHasRelatedRelations returns NullableIssueFilter.HasRelatedRelations, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetHasRelatedRelations() *RelationExistsComparator {
	return v.HasRelatedRelations
}

// GetId returns NullableIssueFilter.Id, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetId() *IDComparator { return v.Id }

// GetLabels returns NullableIssueFilter.Labels, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetLabels() *IssueLabelCollectionFilter { return v.Labels }

// GetNull returns NullableIssueFilter.Null, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetNull() *bool { return v.Null }

// GetNumber returns NullableIssueFilter.Number, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetNumber() *NumberComparator { return v.Number }

// GetOr returns NullableIssueFilter.Or, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetOr() []*NullableIssueFilter { return v.Or }

// GetParent returns NullableIssueFilter.Parent, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetParent() *NullableIssueFilter { return v.Parent }

// GetPriority returns NullableIssueFilter.Priority, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetPriority() *NullableNumberComparator { return v.Priority }

// GetProject returns NullableIssueFilter.Project, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetProject() *NullableProjectFilter { return v.Project }

// GetProjectMilestone returns NullableIssueFilter.ProjectMilestone, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetProjectMilestone() *NullableProjectMilestoneFilter {
	return v.ProjectMilestone
}

// GetSearchableContent returns NullableIssueFilter.SearchableContent, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetSearchableContent() *ContentComparator { return v.SearchableContent }

// GetSlaStatus returns NullableIssueFilter.SlaStatus, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetSlaStatus() *SlaStatusComparator { return v.SlaStatus }

// GetSnoozedBy returns NullableIssueFilter.SnoozedBy, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetSnoozedBy() *NullableUserFilter { return v.SnoozedBy }

// GetSnoozedUntilAt returns NullableIssueFilter.SnoozedUntilAt, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetSnoozedUntilAt() *NullableDateComparator { return v.SnoozedUntilAt }

// GetStartedAt returns NullableIssueFilter.StartedAt, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetStartedAt() *NullableDateComparator { return v.StartedAt }

// GetState returns NullableIssueFilter.State, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetState() *WorkflowStateFilter { return v.State }

// GetSubscribers returns NullableIssueFilter.Subscribers, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetSubscribers() *UserCollectionFilter { return v.Subscribers }

// GetTeam returns NullableIssueFilter.Team, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetTeam() *TeamFilter { return v.Team }

// GetTitle returns NullableIssueFilter.Title, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetTitle() *StringComparator { return v.Title }

// GetTriagedAt returns NullableIssueFilter.TriagedAt, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetTriagedAt() *NullableDateComparator { return v.TriagedAt }

// GetUpdatedAt returns NullableIssueFilter.UpdatedAt, and is useful for accessing the field via an interface.
func (v *NullableIssueFilter) GetUpdatedAt() *DateComparator { return v.UpdatedAt }

// Comparator for optional numbers.
type NullableNumberComparator struct {
	// Equals constraint.
	Eq *float64 `json:"eq,omitempty"`
	// Greater-than constraint. Matches any values that are greater than the given value.
	Gt *float64 `json:"gt,omitempty"`
	// Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value.
	Gte *float64 `json:"gte,omitempty"`
	// In-array constraint.
	In []*float64 `json:"in,omitempty"`
	// Less-than constraint. Matches any values that are less than the given value.
	Lt *float64 `json:"lt,omitempty"`
	// Less-than-or-equal constraint. Matches any values that are less than or equal to the given value.
	Lte *float64 `json:"lte,omitempty"`
	// Not-equals constraint.
	Neq *float64 `json:"neq,omitempty"`
	// Not-in-array constraint.
	Nin []*float64 `json:"nin,omitempty"`
	// Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values.
	Null *bool `json:"null,omitempty"`
}

// GetEq returns NullableNumberComparator.Eq, and is useful for accessing the field via an interface.
func (v *NullableNumberComparator) GetEq() *float64 { return v.Eq }

// GetGt returns NullableNumberComparator.Gt, and is useful for accessing the field via an interface.
func (v *NullableNumberComparator) GetGt() *float64 { return v.Gt }

// GetGte returns NullableNumberComparator.Gte, and is useful for accessing the field via an interface.
func (v *NullableNumberComparator) GetGte() *float64 { return v.Gte }

// GetIn returns NullableNumberComparator.In, and is useful for accessing the field via an interface.
func (v *NullableNumberComparator) GetIn() []*float64 { return v.In }

// GetLt returns NullableNumberComparator.Lt, and is useful for accessing the field via an interface.
func (v *NullableNumberComparator) GetLt() *float64 { return v.Lt }

// GetLte returns NullableNumberComparator.Lte, and is useful for accessing the field via an interface.
func (v *NullableNumberComparator) GetLte() *float64 { return v.Lte }

// GetNeq returns NullableNumberComparator.Neq, and is useful for accessing the field via an interface.
func (v *NullableNumberComparator) GetNeq() *float64 { return v.Neq }

// GetNin returns NullableNumberComparator.Nin, and is useful for accessing the field via an interface.
func (v *NullableNumberComparator) GetNin() []*float64 { return v.Nin }

// GetNull returns NullableNumberComparator.Null, and is useful for accessing the field via an interface.
func (v *NullableNumberComparator) GetNull() *bool { return v.Null }

// Project filtering options.
type NullableProjectFilter struct {
	// Compound filters, all of which need to be matched by the project.
	And []*NullableProjectFilter `json:"and,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Filters that the projects creator must satisfy.
	Creator *UserFilter `json:"creator,omitempty"`
	// Comparator for the identifier.
	Id *IDComparator `json:"id,omitempty"`
	// Filters that the projects issues must satisfy.
	Issues *IssueCollectionFilter `json:"issues,omitempty"`
	// Filters that the projects lead must satisfy.
	Lead *NullableUserFilter `json:"lead,omitempty"`
	// Filters that the projects members must satisfy.
	Members *UserFilter `json:"members,omitempty"`
	// Comparator for the project name.
	Name *StringComparator `json:"name,omitempty"`
	// Filter based on the existence of the relation.
	Null *bool `json:"null,omitempty"`
	// Compound filters, one of which need to be matched by the project.
	Or []*NullableProjectFilter `json:"or,omitempty"`
	// Filters that the projects roadmaps must satisfy.
	Roadmaps *RoadmapCollectionFilter `json:"roadmaps,omitempty"`
	// Comparator for the project slug ID.
	SlugId *StringComparator `json:"slugId,omitempty"`
	// Comparator for the project start date.
	StartDate *NullableDateComparator `json:"startDate,omitempty"`
	// Comparator for the project state.
	State *StringComparator `json:"state,omitempty"`
	// Comparator for the project target date.
	TargetDate *NullableDateComparator `json:"targetDate,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
}

// GetAnd returns NullableProjectFilter.And, and is useful for accessing the field via an interface.
func (v *NullableProjectFilter) GetAnd() []*NullableProjectFilter { return v.And }

// GetCreatedAt returns NullableProjectFilter.CreatedAt, and is useful for accessing the field via an interface.
func (v *NullableProjectFilter) GetCreatedAt() *DateComparator { return v.CreatedAt }

// GetCreator returns NullableProjectFilter.Creator, and is useful for accessing the field via an interface.
func (v *NullableProjectFilter) GetCreator() *UserFilter { return v.Creator }

// GetId returns NullableProjectFilter.Id, and is useful for accessing the field via an interface.
func (v *NullableProjectFilter) GetId() *IDComparator { return v.Id }

// GetIssues returns NullableProjectFilter.Issues, and is useful for accessing the field via an interface.
func (v *NullableProjectFilter) GetIssues() *IssueCollectionFilter { return v.Issues }

// GetLead returns NullableProjectFilter.Lead, and is useful for accessing the field via an interface.
func (v *NullableProjectFilter) GetLead() *NullableUserFilter { return v.Lead }

// GetMembers returns NullableProjectFilter.Members, and is useful for accessing the field via an interface.
func (v *NullableProjectFilter) GetMembers() *UserFilter { return v.Members }

// GetName returns NullableProjectFilter.Name, and is useful for accessing the field via an interface.
func (v *NullableProjectFilter) GetName() *StringComparator { return v.Name }

// GetNull returns NullableProjectFilter.Null, and is useful for accessing the field via an interface.
func (v *NullableProjectFilter) GetNull() *bool { return v.Null }

// GetOr returns NullableProjectFilter.Or, and is useful for accessing the field via an interface.
func (v *NullableProjectFilter) GetOr() []*NullableProjectFilter { return v.Or }

// GetRoadmaps returns NullableProjectFilter.Roadmaps, and is useful for accessing the field via an interface.
func (v *NullableProjectFilter) GetRoadmaps() *RoadmapCollectionFilter { return v.Roadmaps }

// GetSlugId returns NullableProjectFilter.SlugId, and is useful for accessing the field via an interface.
func (v *NullableProjectFilter) GetSlugId() *StringComparator { return v.SlugId }

// GetStartDate returns NullableProjectFilter.StartDate, and is useful for accessing the field via an interface.
func (v *NullableProjectFilter) GetStartDate() *NullableDateComparator { return v.StartDate }

// GetState returns NullableProjectFilter.State, and is useful for accessing the field via an interface.
func (v *NullableProjectFilter) GetState() *StringComparator { return v.State }

// GetTargetDate returns NullableProjectFilter.TargetDate, and is useful for accessing the field via an interface.
func (v *NullableProjectFilter) GetTargetDate() *NullableDateComparator { return v.TargetDate }

// GetUpdatedAt returns NullableProjectFilter.UpdatedAt, and is useful for accessing the field via an interface.
func (v *NullableProjectFilter) GetUpdatedAt() *DateComparator { return v.UpdatedAt }

// Project milestone filtering options.
type NullableProjectMilestoneFilter struct {
	// Compound filters, all of which need to be matched by the project milestone.
	And []*NullableProjectMilestoneFilter `json:"and,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the identifier.
	Id *IDComparator `json:"id,omitempty"`
	// Filter based on the existence of the relation.
	Null *bool `json:"null,omitempty"`
	// Compound filters, one of which need to be matched by the project milestone.
	Or []*NullableProjectMilestoneFilter `json:"or,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
}

// GetAnd returns NullableProjectMilestoneFilter.And, and is useful for accessing the field via an interface.
func (v *NullableProjectMilestoneFilter) GetAnd() []*NullableProjectMilestoneFilter { return v.And }

// GetCreatedAt returns NullableProjectMilestoneFilter.CreatedAt, and is useful for accessing the field via an interface.
func (v *NullableProjectMilestoneFilter) GetCreatedAt() *DateComparator { return v.CreatedAt }

// GetId returns NullableProjectMilestoneFilter.Id, and is useful for accessing the field via an interface.
func (v *NullableProjectMilestoneFilter) GetId() *IDComparator { return v.Id }

// GetNull returns NullableProjectMilestoneFilter.Null, and is useful for accessing the field via an interface.
func (v *NullableProjectMilestoneFilter) GetNull() *bool { return v.Null }

// GetOr returns NullableProjectMilestoneFilter.Or, and is useful for accessing the field via an interface.
func (v *NullableProjectMilestoneFilter) GetOr() []*NullableProjectMilestoneFilter { return v.Or }

// GetUpdatedAt returns NullableProjectMilestoneFilter.UpdatedAt, and is useful for accessing the field via an interface.
func (v *NullableProjectMilestoneFilter) GetUpdatedAt() *DateComparator { return v.UpdatedAt }

// Comparator for optional strings.
type NullableStringComparator struct {
	// Contains constraint. Matches any values that contain the given string.
	Contains *string `json:"contains,omitempty"`
	// Contains case insensitive constraint. Matches any values that contain the given string case insensitive.
	ContainsIgnoreCase *string `json:"containsIgnoreCase,omitempty"`
	// Ends with constraint. Matches any values that end with the given string.
	EndsWith *string `json:"endsWith,omitempty"`
	// Equals constraint.
	Eq *string `json:"eq,omitempty"`
	// Equals case insensitive. Matches any values that matches the given string case insensitive.
	EqIgnoreCase *string `json:"eqIgnoreCase,omitempty"`
	// In-array constraint.
	In []*string `json:"in,omitempty"`
	// Not-equals constraint.
	Neq *string `json:"neq,omitempty"`
	// Not-equals case insensitive. Matches any values that don't match the given string case insensitive.
	NeqIgnoreCase *string `json:"neqIgnoreCase,omitempty"`
	// Not-in-array constraint.
	Nin []*string `json:"nin,omitempty"`
	// Doesn't contain constraint. Matches any values that don't contain the given string.
	NotContains *string `json:"notContains,omitempty"`
	// Doesn't contain case insensitive constraint. Matches any values that don't contain the given string case insensitive.
	NotContainsIgnoreCase *string `json:"notContainsIgnoreCase,omitempty"`
	// Doesn't end with constraint. Matches any values that don't end with the given string.
	NotEndsWith *string `json:"notEndsWith,omitempty"`
	// Doesn't start with constraint. Matches any values that don't start with the given string.
	NotStartsWith *string `json:"notStartsWith,omitempty"`
	// Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values.
	Null *bool `json:"null,omitempty"`
	// Starts with constraint. Matches any values that start with the given string.
	StartsWith *string `json:"startsWith,omitempty"`
}

// GetContains returns NullableStringComparator.Contains, and is useful for accessing the field via an interface.
func (v *NullableStringComparator) GetContains() *string { return v.Contains }

// GetContainsIgnoreCase returns NullableStringComparator.ContainsIgnoreCase, and is useful for accessing the field via an interface.
func (v *NullableStringComparator) GetContainsIgnoreCase() *string { return v.ContainsIgnoreCase }

// GetEndsWith returns NullableStringComparator.EndsWith, and is useful for accessing the field via an interface.
func (v *NullableStringComparator) GetEndsWith() *string { return v.EndsWith }

// GetEq returns NullableStringComparator.Eq, and is useful for accessing the field via an interface.
func (v *NullableStringComparator) GetEq() *string { return v.Eq }

// GetEqIgnoreCase returns NullableStringComparator.EqIgnoreCase, and is useful for accessing the field via an interface.
func (v *NullableStringComparator) GetEqIgnoreCase() *string { return v.EqIgnoreCase }

// GetIn returns NullableStringComparator.In, and is useful for accessing the field via an interface.
func (v *NullableStringComparator) GetIn() []*string { return v.In }

// GetNeq returns NullableStringComparator.Neq, and is useful for accessing the field via an interface.
func (v *NullableStringComparator) GetNeq() *string { return v.Neq }

// GetNeqIgnoreCase returns NullableStringComparator.NeqIgnoreCase, and is useful for accessing the field via an interface.
func (v *NullableStringComparator) GetNeqIgnoreCase() *string { return v.NeqIgnoreCase }

// GetNin returns NullableStringComparator.Nin, and is useful for accessing the field via an interface.
func (v *NullableStringComparator) GetNin() []*string { return v.Nin }

// GetNotContains returns NullableStringComparator.NotContains, and is useful for accessing the field via an interface.
func (v *NullableStringComparator) GetNotContains() *string { return v.NotContains }

// GetNotContainsIgnoreCase returns NullableStringComparator.NotContainsIgnoreCase, and is useful for accessing the field via an interface.
func (v *NullableStringComparator) GetNotContainsIgnoreCase() *string { return v.NotContainsIgnoreCase }

// GetNotEndsWith returns NullableStringComparator.NotEndsWith, and is useful for accessing the field via an interface.
func (v *NullableStringComparator) GetNotEndsWith() *string { return v.NotEndsWith }

// GetNotStartsWith returns NullableStringComparator.NotStartsWith, and is useful for accessing the field via an interface.
func (v *NullableStringComparator) GetNotStartsWith() *string { return v.NotStartsWith }

// GetNull returns NullableStringComparator.Null, and is useful for accessing the field via an interface.
func (v *NullableStringComparator) GetNull() *bool { return v.Null }

// GetStartsWith returns NullableStringComparator.StartsWith, and is useful for accessing the field via an interface.
func (v *NullableStringComparator) GetStartsWith() *string { return v.StartsWith }

type NullableTimelessDateComparator struct {
	// Equals constraint.
	Eq *time.Time `json:"-"`
	// Greater-than constraint. Matches any values that are greater than the given value.
	Gt *time.Time `json:"-"`
	// Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value.
	Gte *time.Time `json:"-"`
	// In-array constraint.
	In []*time.Time `json:"-"`
	// Less-than constraint. Matches any values that are less than the given value.
	Lt *time.Time `json:"-"`
	// Less-than-or-equal constraint. Matches any values that are less than or equal to the given value.
	Lte *time.Time `json:"-"`
	// Not-equals constraint.
	Neq *time.Time `json:"-"`
	// Not-in-array constraint.
	Nin []*time.Time `json:"-"`
	// Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values.
	Null *bool `json:"null,omitempty"`
}

// GetEq returns NullableTimelessDateComparator.Eq, and is useful for accessing the field via an interface.
func (v *NullableTimelessDateComparator) GetEq() *time.Time { return v.Eq }

// GetGt returns NullableTimelessDateComparator.Gt, and is useful for accessing the field via an interface.
func (v *NullableTimelessDateComparator) GetGt() *time.Time { return v.Gt }

// GetGte returns NullableTimelessDateComparator.Gte, and is useful for accessing the field via an interface.
func (v *NullableTimelessDateComparator) GetGte() *time.Time { return v.Gte }

// GetIn returns NullableTimelessDateComparator.In, and is useful for accessing the field via an interface.
func (v *NullableTimelessDateComparator) GetIn() []*time.Time { return v.In }

// GetLt returns NullableTimelessDateComparator.Lt, and is useful for accessing the field via an interface.
func (v *NullableTimelessDateComparator) GetLt() *time.Time { return v.Lt }

// GetLte returns NullableTimelessDateComparator.Lte, and is useful for accessing the field via an interface.
func (v *NullableTimelessDateComparator) GetLte() *time.Time { return v.Lte }

// GetNeq returns NullableTimelessDateComparator.Neq, and is useful for accessing the field via an interface.
func (v *NullableTimelessDateComparator) GetNeq() *time.Time { return v.Neq }

// GetNin returns NullableTimelessDateComparator.Nin, and is useful for accessing the field via an interface.
func (v *NullableTimelessDateComparator) GetNin() []*time.Time { return v.Nin }

// GetNull returns NullableTimelessDateComparator.Null, and is useful for accessing the field via an interface.
func (v *NullableTimelessDateComparator) GetNull() *bool { return v.Null }

func (v *NullableTimelessDateComparator) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NullableTimelessDateComparator
		Eq  json.RawMessage   `json:"eq"`
		Gt  json.RawMessage   `json:"gt"`
		Gte json.RawMessage   `json:"gte"`
		In  []json.RawMessage `json:"in"`
		Lt  json.RawMessage   `json:"lt"`
		Lte json.RawMessage   `json:"lte"`
		Neq json.RawMessage   `json:"neq"`
		Nin []json.RawMessage `json:"nin"`
		graphql.NoUnmarshalJSON
	}
	firstPass.NullableTimelessDateComparator = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.Eq
		src := firstPass.Eq
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal NullableTimelessDateComparator.Eq: %w", err)
			}
		}
	}

	{
		dst := &v.Gt
		src := firstPass.Gt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal NullableTimelessDateComparator.Gt: %w", err)
			}
		}
	}

	{
		dst := &v.Gte
		src := firstPass.Gte
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal NullableTimelessDateComparator.Gte: %w", err)
			}
		}
	}

	{
		dst := &v.In
		src := firstPass.In
		*dst = make(
			[]*time.Time,
			len(src))
		for i, src := range src {
			dst := &(*dst)[i]
			if len(src) != 0 && string(src) != "null" {
				*dst = new(time.Time)
				err = utils.UnmarshalDateTime(
					src, *dst)
				if err != nil {
					return fmt.Errorf(
						"unable to unmarshal NullableTimelessDateComparator.In: %w", err)
				}
			}
		}
	}

	{
		dst := &v.Lt
		src := firstPass.Lt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal NullableTimelessDateComparator.Lt: %w", err)
			}
		}
	}

	{
		dst := &v.Lte
		src := firstPass.Lte
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal NullableTimelessDateComparator.Lte: %w", err)
			}
		}
	}

	{
		dst := &v.Neq
		src := firstPass.Neq
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal NullableTimelessDateComparator.Neq: %w", err)
			}
		}
	}

	{
		dst := &v.Nin
		src := firstPass.Nin
		*dst = make(
			[]*time.Time,
			len(src))
		for i, src := range src {
			dst := &(*dst)[i]
			if len(src) != 0 && string(src) != "null" {
				*dst = new(time.Time)
				err = utils.UnmarshalDateTime(
					src, *dst)
				if err != nil {
					return fmt.Errorf(
						"unable to unmarshal NullableTimelessDateComparator.Nin: %w", err)
				}
			}
		}
	}
	return nil
}

type __premarshalNullableTimelessDateComparator struct {
	Eq json.RawMessage `json:"eq,omitempty"`

	Gt json.RawMessage `json:"gt,omitempty"`

	Gte json.RawMessage `json:"gte,omitempty"`

	In []json.RawMessage `json:"in,omitempty"`

	Lt json.RawMessage `json:"lt,omitempty"`

	Lte json.RawMessage `json:"lte,omitempty"`

	Neq json.RawMessage `json:"neq,omitempty"`

	Nin []json.RawMessage `json:"nin,omitempty"`

	Null *bool `json:"null,omitempty"`
}

func (v *NullableTimelessDateComparator) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NullableTimelessDateComparator) __premarshalJSON() (*__premarshalNullableTimelessDateComparator, error) {
	var retval __premarshalNullableTimelessDateComparator

	{

		dst := &retval.Eq
		src := v.Eq
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal NullableTimelessDateComparator.Eq: %w", err)
			}
		}
	}
	{

		dst := &retval.Gt
		src := v.Gt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal NullableTimelessDateComparator.Gt: %w", err)
			}
		}
	}
	{

		dst := &retval.Gte
		src := v.Gte
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal NullableTimelessDateComparator.Gte: %w", err)
			}
		}
	}
	{

		dst := &retval.In
		src := v.In
		*dst = make(
			[]json.RawMessage,
			len(src))
		for i, src := range src {
			dst := &(*dst)[i]
			if src != nil {
				var err error
				*dst, err = json.Marshal(
					src)
				if err != nil {
					return nil, fmt.Errorf(
						"unable to marshal NullableTimelessDateComparator.In: %w", err)
				}
			}
		}
	}
	{

		dst := &retval.Lt
		src := v.Lt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal NullableTimelessDateComparator.Lt: %w", err)
			}
		}
	}
	{

		dst := &retval.Lte
		src := v.Lte
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal NullableTimelessDateComparator.Lte: %w", err)
			}
		}
	}
	{

		dst := &retval.Neq
		src := v.Neq
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal NullableTimelessDateComparator.Neq: %w", err)
			}
		}
	}
	{

		dst := &retval.Nin
		src := v.Nin
		*dst = make(
			[]json.RawMessage,
			len(src))
		for i, src := range src {
			dst := &(*dst)[i]
			if src != nil {
				var err error
				*dst, err = json.Marshal(
					src)
				if err != nil {
					return nil, fmt.Errorf(
						"unable to marshal NullableTimelessDateComparator.Nin: %w", err)
				}
			}
		}
	}
	retval.Null = v.Null
	return &retval, nil
}

// User filtering options.
type NullableUserFilter struct {
	// Comparator for the user's activity status.
	Active *BooleanComparator `json:"active,omitempty"`
	// Comparator for the user's admin status.
	Admin *BooleanComparator `json:"admin,omitempty"`
	// Compound filters, all of which need to be matched by the user.
	And []*NullableUserFilter `json:"and,omitempty"`
	// Filters that the users assigned issues must satisfy.
	AssignedIssues *IssueCollectionFilter `json:"assignedIssues,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the user's display name.
	DisplayName *StringComparator `json:"displayName,omitempty"`
	// Comparator for the user's email.
	Email *StringComparator `json:"email,omitempty"`
	// Comparator for the identifier.
	Id *IDComparator `json:"id,omitempty"`
	// Filter based on the currently authenticated user. Set to true to filter for the authenticated user, false for any other user.
	IsMe *BooleanComparator `json:"isMe,omitempty"`
	// Comparator for the user's name.
	Name *StringComparator `json:"name,omitempty"`
	// Filter based on the existence of the relation.
	Null *bool `json:"null,omitempty"`
	// Compound filters, one of which need to be matched by the user.
	Or []*NullableUserFilter `json:"or,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
}

// GetActive returns NullableUserFilter.Active, and is useful for accessing the field via an interface.
func (v *NullableUserFilter) GetActive() *BooleanComparator { return v.Active }

// GetAdmin returns NullableUserFilter.Admin, and is useful for accessing the field via an interface.
func (v *NullableUserFilter) GetAdmin() *BooleanComparator { return v.Admin }

// GetAnd returns NullableUserFilter.And, and is useful for accessing the field via an interface.
func (v *NullableUserFilter) GetAnd() []*NullableUserFilter { return v.And }

// GetAssignedIssues returns NullableUserFilter.AssignedIssues, and is useful for accessing the field via an interface.
func (v *NullableUserFilter) GetAssignedIssues() *IssueCollectionFilter { return v.AssignedIssues }

// GetCreatedAt returns NullableUserFilter.CreatedAt, and is useful for accessing the field via an interface.
func (v *NullableUserFilter) GetCreatedAt() *DateComparator { return v.CreatedAt }

// GetDisplayName returns NullableUserFilter.DisplayName, and is useful for accessing the field via an interface.
func (v *NullableUserFilter) GetDisplayName() *StringComparator { return v.DisplayName }

// GetEmail returns NullableUserFilter.Email, and is useful for accessing the field via an interface.
func (v *NullableUserFilter) GetEmail() *StringComparator { return v.Email }

// GetId returns NullableUserFilter.Id, and is useful for accessing the field via an interface.
func (v *NullableUserFilter) GetId() *IDComparator { return v.Id }

// GetIsMe returns NullableUserFilter.IsMe, and is useful for accessing the field via an interface.
func (v *NullableUserFilter) GetIsMe() *BooleanComparator { return v.IsMe }

// GetName returns NullableUserFilter.Name, and is useful for accessing the field via an interface.
func (v *NullableUserFilter) GetName() *StringComparator { return v.Name }

// GetNull returns NullableUserFilter.Null, and is useful for accessing the field via an interface.
func (v *NullableUserFilter) GetNull() *bool { return v.Null }

// GetOr returns NullableUserFilter.Or, and is useful for accessing the field via an interface.
func (v *NullableUserFilter) GetOr() []*NullableUserFilter { return v.Or }

// GetUpdatedAt returns NullableUserFilter.UpdatedAt, and is useful for accessing the field via an interface.
func (v *NullableUserFilter) GetUpdatedAt() *DateComparator { return v.UpdatedAt }

// Comparator for numbers.
type NumberComparator struct {
	// Equals constraint.
	Eq *float64 `json:"eq,omitempty"`
	// Greater-than constraint. Matches any values that are greater than the given value.
	Gt *float64 `json:"gt,omitempty"`
	// Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value.
	Gte *float64 `json:"gte,omitempty"`
	// In-array constraint.
	In []*float64 `json:"in,omitempty"`
	// Less-than constraint. Matches any values that are less than the given value.
	Lt *float64 `json:"lt,omitempty"`
	// Less-than-or-equal constraint. Matches any values that are less than or equal to the given value.
	Lte *float64 `json:"lte,omitempty"`
	// Not-equals constraint.
	Neq *float64 `json:"neq,omitempty"`
	// Not-in-array constraint.
	Nin []*float64 `json:"nin,omitempty"`
}

// GetEq returns NumberComparator.Eq, and is useful for accessing the field via an interface.
func (v *NumberComparator) GetEq() *float64 { return v.Eq }

// GetGt returns NumberComparator.Gt, and is useful for accessing the field via an interface.
func (v *NumberComparator) GetGt() *float64 { return v.Gt }

// GetGte returns NumberComparator.Gte, and is useful for accessing the field via an interface.
func (v *NumberComparator) GetGte() *float64 { return v.Gte }

// GetIn returns NumberComparator.In, and is useful for accessing the field via an interface.
func (v *NumberComparator) GetIn() []*float64 { return v.In }

// GetLt returns NumberComparator.Lt, and is useful for accessing the field via an interface.
func (v *NumberComparator) GetLt() *float64 { return v.Lt }

// GetLte returns NumberComparator.Lte, and is useful for accessing the field via an interface.
func (v *NumberComparator) GetLte() *float64 { return v.Lte }

// GetNeq returns NumberComparator.Neq, and is useful for accessing the field via an interface.
func (v *NumberComparator) GetNeq() *float64 { return v.Neq }

// GetNin returns NumberComparator.Nin, and is useful for accessing the field via an interface.
func (v *NumberComparator) GetNin() []*float64 { return v.Nin }

// Project filtering options.
type ProjectFilter struct {
	// Compound filters, all of which need to be matched by the project.
	And []*ProjectFilter `json:"and,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Filters that the projects creator must satisfy.
	Creator *UserFilter `json:"creator,omitempty"`
	// Comparator for the identifier.
	Id *IDComparator `json:"id,omitempty"`
	// Filters that the projects issues must satisfy.
	Issues *IssueCollectionFilter `json:"issues,omitempty"`
	// Filters that the projects lead must satisfy.
	Lead *NullableUserFilter `json:"lead,omitempty"`
	// Filters that the projects members must satisfy.
	Members *UserFilter `json:"members,omitempty"`
	// Comparator for the project name.
	Name *StringComparator `json:"name,omitempty"`
	// Compound filters, one of which need to be matched by the project.
	Or []*ProjectFilter `json:"or,omitempty"`
	// Filters that the projects roadmaps must satisfy.
	Roadmaps *RoadmapCollectionFilter `json:"roadmaps,omitempty"`
	// Comparator for the project slug ID.
	SlugId *StringComparator `json:"slugId,omitempty"`
	// Comparator for the project start date.
	StartDate *NullableDateComparator `json:"startDate,omitempty"`
	// Comparator for the project state.
	State *StringComparator `json:"state,omitempty"`
	// Comparator for the project target date.
	TargetDate *NullableDateComparator `json:"targetDate,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
}

// GetAnd returns ProjectFilter.And, and is useful for accessing the field via an interface.
func (v *ProjectFilter) GetAnd() []*ProjectFilter { return v.And }

// GetCreatedAt returns ProjectFilter.CreatedAt, and is useful for accessing the field via an interface.
func (v *ProjectFilter) GetCreatedAt() *DateComparator { return v.CreatedAt }

// GetCreator returns ProjectFilter.Creator, and is useful for accessing the field via an interface.
func (v *ProjectFilter) GetCreator() *UserFilter { return v.Creator }

// GetId returns ProjectFilter.Id, and is useful for accessing the field via an interface.
func (v *ProjectFilter) GetId() *IDComparator { return v.Id }

// GetIssues returns ProjectFilter.Issues, and is useful for accessing the field via an interface.
func (v *ProjectFilter) GetIssues() *IssueCollectionFilter { return v.Issues }

// GetLead returns ProjectFilter.Lead, and is useful for accessing the field via an interface.
func (v *ProjectFilter) GetLead() *NullableUserFilter { return v.Lead }

// GetMembers returns ProjectFilter.Members, and is useful for accessing the field via an interface.
func (v *ProjectFilter) GetMembers() *UserFilter { return v.Members }

// GetName returns ProjectFilter.Name, and is useful for accessing the field via an interface.
func (v *ProjectFilter) GetName() *StringComparator { return v.Name }

// GetOr returns ProjectFilter.Or, and is useful for accessing the field via an interface.
func (v *ProjectFilter) GetOr() []*ProjectFilter { return v.Or }

// GetRoadmaps returns ProjectFilter.Roadmaps, and is useful for accessing the field via an interface.
func (v *ProjectFilter) GetRoadmaps() *RoadmapCollectionFilter { return v.Roadmaps }

// GetSlugId returns ProjectFilter.SlugId, and is useful for accessing the field via an interface.
func (v *ProjectFilter) GetSlugId() *StringComparator { return v.SlugId }

// GetStartDate returns ProjectFilter.StartDate, and is useful for accessing the field via an interface.
func (v *ProjectFilter) GetStartDate() *NullableDateComparator { return v.StartDate }

// GetState returns ProjectFilter.State, and is useful for accessing the field via an interface.
func (v *ProjectFilter) GetState() *StringComparator { return v.State }

// GetTargetDate returns ProjectFilter.TargetDate, and is useful for accessing the field via an interface.
func (v *ProjectFilter) GetTargetDate() *NullableDateComparator { return v.TargetDate }

// GetUpdatedAt returns ProjectFilter.UpdatedAt, and is useful for accessing the field via an interface.
func (v *ProjectFilter) GetUpdatedAt() *DateComparator { return v.UpdatedAt }

// The frequency at which to send project update reminders.
type ProjectUpdateReminderFrequency string

const (
	ProjectUpdateReminderFrequencyNever    ProjectUpdateReminderFrequency = "never"
	ProjectUpdateReminderFrequencyTwoweeks ProjectUpdateReminderFrequency = "twoWeeks"
	ProjectUpdateReminderFrequencyWeek     ProjectUpdateReminderFrequency = "week"
)

// Comparator for relation existence.
type RelationExistsComparator struct {
	// Equals constraint.
	Eq *bool `json:"eq,omitempty"`
	// Not equals constraint.
	Neq *bool `json:"neq,omitempty"`
}

// GetEq returns RelationExistsComparator.Eq, and is useful for accessing the field via an interface.
func (v *RelationExistsComparator) GetEq() *bool { return v.Eq }

// GetNeq returns RelationExistsComparator.Neq, and is useful for accessing the field via an interface.
func (v *RelationExistsComparator) GetNeq() *bool { return v.Neq }

// Features release channel
type ReleaseChannel string

const (
	ReleaseChannelBeta       ReleaseChannel = "beta"
	ReleaseChannelInternal   ReleaseChannel = "internal"
	ReleaseChannelPrerelease ReleaseChannel = "preRelease"
	ReleaseChannelPublic     ReleaseChannel = "public"
)

// Roadmap collection filtering options.
type RoadmapCollectionFilter struct {
	// Compound filters, all of which need to be matched by the roadmap.
	And []*RoadmapCollectionFilter `json:"and,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Filters that the roadmap creator must satisfy.
	Creator *UserFilter `json:"creator,omitempty"`
	// Filters that needs to be matched by all roadmaps.
	Every *RoadmapFilter `json:"every,omitempty"`
	// Comparator for the identifier.
	Id *IDComparator `json:"id,omitempty"`
	// Comparator for the collection length.
	Length *NumberComparator `json:"length,omitempty"`
	// Comparator for the roadmap name.
	Name *StringComparator `json:"name,omitempty"`
	// Compound filters, one of which need to be matched by the roadmap.
	Or []*RoadmapCollectionFilter `json:"or,omitempty"`
	// Comparator for the roadmap slug ID.
	SlugId *StringComparator `json:"slugId,omitempty"`
	// Filters that needs to be matched by some roadmaps.
	Some *RoadmapFilter `json:"some,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
}

// GetAnd returns RoadmapCollectionFilter.And, and is useful for accessing the field via an interface.
func (v *RoadmapCollectionFilter) GetAnd() []*RoadmapCollectionFilter { return v.And }

// GetCreatedAt returns RoadmapCollectionFilter.CreatedAt, and is useful for accessing the field via an interface.
func (v *RoadmapCollectionFilter) GetCreatedAt() *DateComparator { return v.CreatedAt }

// GetCreator returns RoadmapCollectionFilter.Creator, and is useful for accessing the field via an interface.
func (v *RoadmapCollectionFilter) GetCreator() *UserFilter { return v.Creator }

// GetEvery returns RoadmapCollectionFilter.Every, and is useful for accessing the field via an interface.
func (v *RoadmapCollectionFilter) GetEvery() *RoadmapFilter { return v.Every }

// GetId returns RoadmapCollectionFilter.Id, and is useful for accessing the field via an interface.
func (v *RoadmapCollectionFilter) GetId() *IDComparator { return v.Id }

// GetLength returns RoadmapCollectionFilter.Length, and is useful for accessing the field via an interface.
func (v *RoadmapCollectionFilter) GetLength() *NumberComparator { return v.Length }

// GetName returns RoadmapCollectionFilter.Name, and is useful for accessing the field via an interface.
func (v *RoadmapCollectionFilter) GetName() *StringComparator { return v.Name }

// GetOr returns RoadmapCollectionFilter.Or, and is useful for accessing the field via an interface.
func (v *RoadmapCollectionFilter) GetOr() []*RoadmapCollectionFilter { return v.Or }

// GetSlugId returns RoadmapCollectionFilter.SlugId, and is useful for accessing the field via an interface.
func (v *RoadmapCollectionFilter) GetSlugId() *StringComparator { return v.SlugId }

// GetSome returns RoadmapCollectionFilter.Some, and is useful for accessing the field via an interface.
func (v *RoadmapCollectionFilter) GetSome() *RoadmapFilter { return v.Some }

// GetUpdatedAt returns RoadmapCollectionFilter.UpdatedAt, and is useful for accessing the field via an interface.
func (v *RoadmapCollectionFilter) GetUpdatedAt() *DateComparator { return v.UpdatedAt }

// Roadmap filtering options.
type RoadmapFilter struct {
	// Compound filters, all of which need to be matched by the roadmap.
	And []*RoadmapFilter `json:"and,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Filters that the roadmap creator must satisfy.
	Creator *UserFilter `json:"creator,omitempty"`
	// Comparator for the identifier.
	Id *IDComparator `json:"id,omitempty"`
	// Comparator for the roadmap name.
	Name *StringComparator `json:"name,omitempty"`
	// Compound filters, one of which need to be matched by the roadmap.
	Or []*RoadmapFilter `json:"or,omitempty"`
	// Comparator for the roadmap slug ID.
	SlugId *StringComparator `json:"slugId,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
}

// GetAnd returns RoadmapFilter.And, and is useful for accessing the field via an interface.
func (v *RoadmapFilter) GetAnd() []*RoadmapFilter { return v.And }

// GetCreatedAt returns RoadmapFilter.CreatedAt, and is useful for accessing the field via an interface.
func (v *RoadmapFilter) GetCreatedAt() *DateComparator { return v.CreatedAt }

// GetCreator returns RoadmapFilter.Creator, and is useful for accessing the field via an interface.
func (v *RoadmapFilter) GetCreator() *UserFilter { return v.Creator }

// GetId returns RoadmapFilter.Id, and is useful for accessing the field via an interface.
func (v *RoadmapFilter) GetId() *IDComparator { return v.Id }

// GetName returns RoadmapFilter.Name, and is useful for accessing the field via an interface.
func (v *RoadmapFilter) GetName() *StringComparator { return v.Name }

// GetOr returns RoadmapFilter.Or, and is useful for accessing the field via an interface.
func (v *RoadmapFilter) GetOr() []*RoadmapFilter { return v.Or }

// GetSlugId returns RoadmapFilter.SlugId, and is useful for accessing the field via an interface.
func (v *RoadmapFilter) GetSlugId() *StringComparator { return v.SlugId }

// GetUpdatedAt returns RoadmapFilter.UpdatedAt, and is useful for accessing the field via an interface.
func (v *RoadmapFilter) GetUpdatedAt() *DateComparator { return v.UpdatedAt }

type SlaStatus string

const (
	SlaStatusBreached   SlaStatus = "Breached"
	SlaStatusCompleted  SlaStatus = "Completed"
	SlaStatusFailed     SlaStatus = "Failed"
	SlaStatusHighrisk   SlaStatus = "HighRisk"
	SlaStatusLowrisk    SlaStatus = "LowRisk"
	SlaStatusMediumrisk SlaStatus = "MediumRisk"
)

// Comparator for sla status.
type SlaStatusComparator struct {
	// Equals constraint.
	Eq *SlaStatus `json:"eq,omitempty"`
	// In-array constraint.
	In []*SlaStatus `json:"in,omitempty"`
	// Not-equals constraint.
	Neq *SlaStatus `json:"neq,omitempty"`
	// Not-in-array constraint.
	Nin []*SlaStatus `json:"nin,omitempty"`
	// Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values.
	Null *bool `json:"null,omitempty"`
}

// GetEq returns SlaStatusComparator.Eq, and is useful for accessing the field via an interface.
func (v *SlaStatusComparator) GetEq() *SlaStatus { return v.Eq }

// GetIn returns SlaStatusComparator.In, and is useful for accessing the field via an interface.
func (v *SlaStatusComparator) GetIn() []*SlaStatus { return v.In }

// GetNeq returns SlaStatusComparator.Neq, and is useful for accessing the field via an interface.
func (v *SlaStatusComparator) GetNeq() *SlaStatus { return v.Neq }

// GetNin returns SlaStatusComparator.Nin, and is useful for accessing the field via an interface.
func (v *SlaStatusComparator) GetNin() []*SlaStatus { return v.Nin }

// GetNull returns SlaStatusComparator.Null, and is useful for accessing the field via an interface.
func (v *SlaStatusComparator) GetNull() *bool { return v.Null }

// Comparator for `sourceType` field.
type SourceTypeComparator struct {
	// Contains constraint. Matches any values that contain the given string.
	Contains *string `json:"contains,omitempty"`
	// Contains case insensitive constraint. Matches any values that contain the given string case insensitive.
	ContainsIgnoreCase *string `json:"containsIgnoreCase,omitempty"`
	// Ends with constraint. Matches any values that end with the given string.
	EndsWith *string `json:"endsWith,omitempty"`
	// Equals constraint.
	Eq *string `json:"eq,omitempty"`
	// Equals case insensitive. Matches any values that matches the given string case insensitive.
	EqIgnoreCase *string `json:"eqIgnoreCase,omitempty"`
	// In-array constraint.
	In []*string `json:"in,omitempty"`
	// Not-equals constraint.
	Neq *string `json:"neq,omitempty"`
	// Not-equals case insensitive. Matches any values that don't match the given string case insensitive.
	NeqIgnoreCase *string `json:"neqIgnoreCase,omitempty"`
	// Not-in-array constraint.
	Nin []*string `json:"nin,omitempty"`
	// Doesn't contain constraint. Matches any values that don't contain the given string.
	NotContains *string `json:"notContains,omitempty"`
	// Doesn't contain case insensitive constraint. Matches any values that don't contain the given string case insensitive.
	NotContainsIgnoreCase *string `json:"notContainsIgnoreCase,omitempty"`
	// Doesn't end with constraint. Matches any values that don't end with the given string.
	NotEndsWith *string `json:"notEndsWith,omitempty"`
	// Doesn't start with constraint. Matches any values that don't start with the given string.
	NotStartsWith *string `json:"notStartsWith,omitempty"`
	// Starts with constraint. Matches any values that start with the given string.
	StartsWith *string `json:"startsWith,omitempty"`
}

// GetContains returns SourceTypeComparator.Contains, and is useful for accessing the field via an interface.
func (v *SourceTypeComparator) GetContains() *string { return v.Contains }

// GetContainsIgnoreCase returns SourceTypeComparator.ContainsIgnoreCase, and is useful for accessing the field via an interface.
func (v *SourceTypeComparator) GetContainsIgnoreCase() *string { return v.ContainsIgnoreCase }

// GetEndsWith returns SourceTypeComparator.EndsWith, and is useful for accessing the field via an interface.
func (v *SourceTypeComparator) GetEndsWith() *string { return v.EndsWith }

// GetEq returns SourceTypeComparator.Eq, and is useful for accessing the field via an interface.
func (v *SourceTypeComparator) GetEq() *string { return v.Eq }

// GetEqIgnoreCase returns SourceTypeComparator.EqIgnoreCase, and is useful for accessing the field via an interface.
func (v *SourceTypeComparator) GetEqIgnoreCase() *string { return v.EqIgnoreCase }

// GetIn returns SourceTypeComparator.In, and is useful for accessing the field via an interface.
func (v *SourceTypeComparator) GetIn() []*string { return v.In }

// GetNeq returns SourceTypeComparator.Neq, and is useful for accessing the field via an interface.
func (v *SourceTypeComparator) GetNeq() *string { return v.Neq }

// GetNeqIgnoreCase returns SourceTypeComparator.NeqIgnoreCase, and is useful for accessing the field via an interface.
func (v *SourceTypeComparator) GetNeqIgnoreCase() *string { return v.NeqIgnoreCase }

// GetNin returns SourceTypeComparator.Nin, and is useful for accessing the field via an interface.
func (v *SourceTypeComparator) GetNin() []*string { return v.Nin }

// GetNotContains returns SourceTypeComparator.NotContains, and is useful for accessing the field via an interface.
func (v *SourceTypeComparator) GetNotContains() *string { return v.NotContains }

// GetNotContainsIgnoreCase returns SourceTypeComparator.NotContainsIgnoreCase, and is useful for accessing the field via an interface.
func (v *SourceTypeComparator) GetNotContainsIgnoreCase() *string { return v.NotContainsIgnoreCase }

// GetNotEndsWith returns SourceTypeComparator.NotEndsWith, and is useful for accessing the field via an interface.
func (v *SourceTypeComparator) GetNotEndsWith() *string { return v.NotEndsWith }

// GetNotStartsWith returns SourceTypeComparator.NotStartsWith, and is useful for accessing the field via an interface.
func (v *SourceTypeComparator) GetNotStartsWith() *string { return v.NotStartsWith }

// GetStartsWith returns SourceTypeComparator.StartsWith, and is useful for accessing the field via an interface.
func (v *SourceTypeComparator) GetStartsWith() *string { return v.StartsWith }

// Comparator for strings.
type StringComparator struct {
	// Contains constraint. Matches any values that contain the given string.
	Contains *string `json:"contains,omitempty"`
	// Contains case insensitive constraint. Matches any values that contain the given string case insensitive.
	ContainsIgnoreCase *string `json:"containsIgnoreCase,omitempty"`
	// Ends with constraint. Matches any values that end with the given string.
	EndsWith *string `json:"endsWith,omitempty"`
	// Equals constraint.
	Eq *string `json:"eq,omitempty"`
	// Equals case insensitive. Matches any values that matches the given string case insensitive.
	EqIgnoreCase *string `json:"eqIgnoreCase,omitempty"`
	// In-array constraint.
	In []*string `json:"in,omitempty"`
	// Not-equals constraint.
	Neq *string `json:"neq,omitempty"`
	// Not-equals case insensitive. Matches any values that don't match the given string case insensitive.
	NeqIgnoreCase *string `json:"neqIgnoreCase,omitempty"`
	// Not-in-array constraint.
	Nin []*string `json:"nin,omitempty"`
	// Doesn't contain constraint. Matches any values that don't contain the given string.
	NotContains *string `json:"notContains,omitempty"`
	// Doesn't contain case insensitive constraint. Matches any values that don't contain the given string case insensitive.
	NotContainsIgnoreCase *string `json:"notContainsIgnoreCase,omitempty"`
	// Doesn't end with constraint. Matches any values that don't end with the given string.
	NotEndsWith *string `json:"notEndsWith,omitempty"`
	// Doesn't start with constraint. Matches any values that don't start with the given string.
	NotStartsWith *string `json:"notStartsWith,omitempty"`
	// Starts with constraint. Matches any values that start with the given string.
	StartsWith *string `json:"startsWith,omitempty"`
}

// GetContains returns StringComparator.Contains, and is useful for accessing the field via an interface.
func (v *StringComparator) GetContains() *string { return v.Contains }

// GetContainsIgnoreCase returns StringComparator.ContainsIgnoreCase, and is useful for accessing the field via an interface.
func (v *StringComparator) GetContainsIgnoreCase() *string { return v.ContainsIgnoreCase }

// GetEndsWith returns StringComparator.EndsWith, and is useful for accessing the field via an interface.
func (v *StringComparator) GetEndsWith() *string { return v.EndsWith }

// GetEq returns StringComparator.Eq, and is useful for accessing the field via an interface.
func (v *StringComparator) GetEq() *string { return v.Eq }

// GetEqIgnoreCase returns StringComparator.EqIgnoreCase, and is useful for accessing the field via an interface.
func (v *StringComparator) GetEqIgnoreCase() *string { return v.EqIgnoreCase }

// GetIn returns StringComparator.In, and is useful for accessing the field via an interface.
func (v *StringComparator) GetIn() []*string { return v.In }

// GetNeq returns StringComparator.Neq, and is useful for accessing the field via an interface.
func (v *StringComparator) GetNeq() *string { return v.Neq }

// GetNeqIgnoreCase returns StringComparator.NeqIgnoreCase, and is useful for accessing the field via an interface.
func (v *StringComparator) GetNeqIgnoreCase() *string { return v.NeqIgnoreCase }

// GetNin returns StringComparator.Nin, and is useful for accessing the field via an interface.
func (v *StringComparator) GetNin() []*string { return v.Nin }

// GetNotContains returns StringComparator.NotContains, and is useful for accessing the field via an interface.
func (v *StringComparator) GetNotContains() *string { return v.NotContains }

// GetNotContainsIgnoreCase returns StringComparator.NotContainsIgnoreCase, and is useful for accessing the field via an interface.
func (v *StringComparator) GetNotContainsIgnoreCase() *string { return v.NotContainsIgnoreCase }

// GetNotEndsWith returns StringComparator.NotEndsWith, and is useful for accessing the field via an interface.
func (v *StringComparator) GetNotEndsWith() *string { return v.NotEndsWith }

// GetNotStartsWith returns StringComparator.NotStartsWith, and is useful for accessing the field via an interface.
func (v *StringComparator) GetNotStartsWith() *string { return v.NotStartsWith }

// GetStartsWith returns StringComparator.StartsWith, and is useful for accessing the field via an interface.
func (v *StringComparator) GetStartsWith() *string { return v.StartsWith }

// Team filtering options.
type TeamFilter struct {
	// Compound filters, all of which need to be matched by the team.
	And []*TeamFilter `json:"and,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the team description.
	Description *NullableStringComparator `json:"description,omitempty"`
	// Comparator for the identifier.
	Id *IDComparator `json:"id,omitempty"`
	// Filters that the teams issues must satisfy.
	Issues *IssueCollectionFilter `json:"issues,omitempty"`
	// Comparator for the team key.
	Key *StringComparator `json:"key,omitempty"`
	// Comparator for the team name.
	Name *StringComparator `json:"name,omitempty"`
	// Compound filters, one of which need to be matched by the team.
	Or []*TeamFilter `json:"or,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
}

// GetAnd returns TeamFilter.And, and is useful for accessing the field via an interface.
func (v *TeamFilter) GetAnd() []*TeamFilter { return v.And }

// GetCreatedAt returns TeamFilter.CreatedAt, and is useful for accessing the field via an interface.
func (v *TeamFilter) GetCreatedAt() *DateComparator { return v.CreatedAt }

// GetDescription returns TeamFilter.Description, and is useful for accessing the field via an interface.
func (v *TeamFilter) GetDescription() *NullableStringComparator { return v.Description }

// GetId returns TeamFilter.Id, and is useful for accessing the field via an interface.
func (v *TeamFilter) GetId() *IDComparator { return v.Id }

// GetIssues returns TeamFilter.Issues, and is useful for accessing the field via an interface.
func (v *TeamFilter) GetIssues() *IssueCollectionFilter { return v.Issues }

// GetKey returns TeamFilter.Key, and is useful for accessing the field via an interface.
func (v *TeamFilter) GetKey() *StringComparator { return v.Key }

// GetName returns TeamFilter.Name, and is useful for accessing the field via an interface.
func (v *TeamFilter) GetName() *StringComparator { return v.Name }

// GetOr returns TeamFilter.Or, and is useful for accessing the field via an interface.
func (v *TeamFilter) GetOr() []*TeamFilter { return v.Or }

// GetUpdatedAt returns TeamFilter.UpdatedAt, and is useful for accessing the field via an interface.
func (v *TeamFilter) GetUpdatedAt() *DateComparator { return v.UpdatedAt }

// User filtering options.
type UserCollectionFilter struct {
	// Comparator for the user's activity status.
	Active *BooleanComparator `json:"active,omitempty"`
	// Comparator for the user's admin status.
	Admin *BooleanComparator `json:"admin,omitempty"`
	// Compound filters, all of which need to be matched by the user.
	And []*UserCollectionFilter `json:"and,omitempty"`
	// Filters that the users assigned issues must satisfy.
	AssignedIssues *IssueCollectionFilter `json:"assignedIssues,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the user's display name.
	DisplayName *StringComparator `json:"displayName,omitempty"`
	// Comparator for the user's email.
	Email *StringComparator `json:"email,omitempty"`
	// Filters that needs to be matched by all users.
	Every *UserFilter `json:"every,omitempty"`
	// Comparator for the identifier.
	Id *IDComparator `json:"id,omitempty"`
	// Filter based on the currently authenticated user. Set to true to filter for the authenticated user, false for any other user.
	IsMe *BooleanComparator `json:"isMe,omitempty"`
	// Comparator for the collection length.
	Length *NumberComparator `json:"length,omitempty"`
	// Comparator for the user's name.
	Name *StringComparator `json:"name,omitempty"`
	// Compound filters, one of which need to be matched by the user.
	Or []*UserCollectionFilter `json:"or,omitempty"`
	// Filters that needs to be matched by some users.
	Some *UserFilter `json:"some,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
}

// GetActive returns UserCollectionFilter.Active, and is useful for accessing the field via an interface.
func (v *UserCollectionFilter) GetActive() *BooleanComparator { return v.Active }

// GetAdmin returns UserCollectionFilter.Admin, and is useful for accessing the field via an interface.
func (v *UserCollectionFilter) GetAdmin() *BooleanComparator { return v.Admin }

// GetAnd returns UserCollectionFilter.And, and is useful for accessing the field via an interface.
func (v *UserCollectionFilter) GetAnd() []*UserCollectionFilter { return v.And }

// GetAssignedIssues returns UserCollectionFilter.AssignedIssues, and is useful for accessing the field via an interface.
func (v *UserCollectionFilter) GetAssignedIssues() *IssueCollectionFilter { return v.AssignedIssues }

// GetCreatedAt returns UserCollectionFilter.CreatedAt, and is useful for accessing the field via an interface.
func (v *UserCollectionFilter) GetCreatedAt() *DateComparator { return v.CreatedAt }

// GetDisplayName returns UserCollectionFilter.DisplayName, and is useful for accessing the field via an interface.
func (v *UserCollectionFilter) GetDisplayName() *StringComparator { return v.DisplayName }

// GetEmail returns UserCollectionFilter.Email, and is useful for accessing the field via an interface.
func (v *UserCollectionFilter) GetEmail() *StringComparator { return v.Email }

// GetEvery returns UserCollectionFilter.Every, and is useful for accessing the field via an interface.
func (v *UserCollectionFilter) GetEvery() *UserFilter { return v.Every }

// GetId returns UserCollectionFilter.Id, and is useful for accessing the field via an interface.
func (v *UserCollectionFilter) GetId() *IDComparator { return v.Id }

// GetIsMe returns UserCollectionFilter.IsMe, and is useful for accessing the field via an interface.
func (v *UserCollectionFilter) GetIsMe() *BooleanComparator { return v.IsMe }

// GetLength returns UserCollectionFilter.Length, and is useful for accessing the field via an interface.
func (v *UserCollectionFilter) GetLength() *NumberComparator { return v.Length }

// GetName returns UserCollectionFilter.Name, and is useful for accessing the field via an interface.
func (v *UserCollectionFilter) GetName() *StringComparator { return v.Name }

// GetOr returns UserCollectionFilter.Or, and is useful for accessing the field via an interface.
func (v *UserCollectionFilter) GetOr() []*UserCollectionFilter { return v.Or }

// GetSome returns UserCollectionFilter.Some, and is useful for accessing the field via an interface.
func (v *UserCollectionFilter) GetSome() *UserFilter { return v.Some }

// GetUpdatedAt returns UserCollectionFilter.UpdatedAt, and is useful for accessing the field via an interface.
func (v *UserCollectionFilter) GetUpdatedAt() *DateComparator { return v.UpdatedAt }

// User filtering options.
type UserFilter struct {
	// Comparator for the user's activity status.
	Active *BooleanComparator `json:"active,omitempty"`
	// Comparator for the user's admin status.
	Admin *BooleanComparator `json:"admin,omitempty"`
	// Compound filters, all of which need to be matched by the user.
	And []*UserFilter `json:"and,omitempty"`
	// Filters that the users assigned issues must satisfy.
	AssignedIssues *IssueCollectionFilter `json:"assignedIssues,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the user's display name.
	DisplayName *StringComparator `json:"displayName,omitempty"`
	// Comparator for the user's email.
	Email *StringComparator `json:"email,omitempty"`
	// Comparator for the identifier.
	Id *IDComparator `json:"id,omitempty"`
	// Filter based on the currently authenticated user. Set to true to filter for the authenticated user, false for any other user.
	IsMe *BooleanComparator `json:"isMe,omitempty"`
	// Comparator for the user's name.
	Name *StringComparator `json:"name,omitempty"`
	// Compound filters, one of which need to be matched by the user.
	Or []*UserFilter `json:"or,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
}

// GetActive returns UserFilter.Active, and is useful for accessing the field via an interface.
func (v *UserFilter) GetActive() *BooleanComparator { return v.Active }

// GetAdmin returns UserFilter.Admin, and is useful for accessing the field via an interface.
func (v *UserFilter) GetAdmin() *BooleanComparator { return v.Admin }

// GetAnd returns UserFilter.And, and is useful for accessing the field via an interface.
func (v *UserFilter) GetAnd() []*UserFilter { return v.And }

// GetAssignedIssues returns UserFilter.AssignedIssues, and is useful for accessing the field via an interface.
func (v *UserFilter) GetAssignedIssues() *IssueCollectionFilter { return v.AssignedIssues }

// GetCreatedAt returns UserFilter.CreatedAt, and is useful for accessing the field via an interface.
func (v *UserFilter) GetCreatedAt() *DateComparator { return v.CreatedAt }

// GetDisplayName returns UserFilter.DisplayName, and is useful for accessing the field via an interface.
func (v *UserFilter) GetDisplayName() *StringComparator { return v.DisplayName }

// GetEmail returns UserFilter.Email, and is useful for accessing the field via an interface.
func (v *UserFilter) GetEmail() *StringComparator { return v.Email }

// GetId returns UserFilter.Id, and is useful for accessing the field via an interface.
func (v *UserFilter) GetId() *IDComparator { return v.Id }

// GetIsMe returns UserFilter.IsMe, and is useful for accessing the field via an interface.
func (v *UserFilter) GetIsMe() *BooleanComparator { return v.IsMe }

// GetName returns UserFilter.Name, and is useful for accessing the field via an interface.
func (v *UserFilter) GetName() *StringComparator { return v.Name }

// GetOr returns UserFilter.Or, and is useful for accessing the field via an interface.
func (v *UserFilter) GetOr() []*UserFilter { return v.Or }

// GetUpdatedAt returns UserFilter.UpdatedAt, and is useful for accessing the field via an interface.
func (v *UserFilter) GetUpdatedAt() *DateComparator { return v.UpdatedAt }

// Workflow state filtering options.
type WorkflowStateFilter struct {
	// Compound filters, all of which need to be matched by the workflow state.
	And []*WorkflowStateFilter `json:"and,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the workflow state description.
	Description *StringComparator `json:"description,omitempty"`
	// Comparator for the identifier.
	Id *IDComparator `json:"id,omitempty"`
	// Filters that the workflow states issues must satisfy.
	Issues *IssueCollectionFilter `json:"issues,omitempty"`
	// Comparator for the workflow state name.
	Name *StringComparator `json:"name,omitempty"`
	// Compound filters, one of which need to be matched by the workflow state.
	Or []*WorkflowStateFilter `json:"or,omitempty"`
	// Comparator for the workflow state position.
	Position *NumberComparator `json:"position,omitempty"`
	// Filters that the workflow states team must satisfy.
	Team *TeamFilter `json:"team,omitempty"`
	// Comparator for the workflow state type.
	Type *StringComparator `json:"type,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
}

// GetAnd returns WorkflowStateFilter.And, and is useful for accessing the field via an interface.
func (v *WorkflowStateFilter) GetAnd() []*WorkflowStateFilter { return v.And }

// GetCreatedAt returns WorkflowStateFilter.CreatedAt, and is useful for accessing the field via an interface.
func (v *WorkflowStateFilter) GetCreatedAt() *DateComparator { return v.CreatedAt }

// GetDescription returns WorkflowStateFilter.Description, and is useful for accessing the field via an interface.
func (v *WorkflowStateFilter) GetDescription() *StringComparator { return v.Description }

// GetId returns WorkflowStateFilter.Id, and is useful for accessing the field via an interface.
func (v *WorkflowStateFilter) GetId() *IDComparator { return v.Id }

// GetIssues returns WorkflowStateFilter.Issues, and is useful for accessing the field via an interface.
func (v *WorkflowStateFilter) GetIssues() *IssueCollectionFilter { return v.Issues }

// GetName returns WorkflowStateFilter.Name, and is useful for accessing the field via an interface.
func (v *WorkflowStateFilter) GetName() *StringComparator { return v.Name }

// GetOr returns WorkflowStateFilter.Or, and is useful for accessing the field via an interface.
func (v *WorkflowStateFilter) GetOr() []*WorkflowStateFilter { return v.Or }

// GetPosition returns WorkflowStateFilter.Position, and is useful for accessing the field via an interface.
func (v *WorkflowStateFilter) GetPosition() *NumberComparator { return v.Position }

// GetTeam returns WorkflowStateFilter.Team, and is useful for accessing the field via an interface.
func (v *WorkflowStateFilter) GetTeam() *TeamFilter { return v.Team }

// GetType returns WorkflowStateFilter.Type, and is useful for accessing the field via an interface.
func (v *WorkflowStateFilter) GetType() *StringComparator { return v.Type }

// GetUpdatedAt returns WorkflowStateFilter.UpdatedAt, and is useful for accessing the field via an interface.
func (v *WorkflowStateFilter) GetUpdatedAt() *DateComparator { return v.UpdatedAt }

// __getAttachmentInput is used internally by genqlient
type __getAttachmentInput struct {
	AttachmentId *string `json:"attachmentId"`
}

// GetAttachmentId returns __getAttachmentInput.AttachmentId, and is useful for accessing the field via an interface.
func (v *__getAttachmentInput) GetAttachmentId() *string { return v.AttachmentId }

// __getCommentInput is used internally by genqlient
type __getCommentInput struct {
	CommentId *string `json:"commentId"`
}

// GetCommentId returns __getCommentInput.CommentId, and is useful for accessing the field via an interface.
func (v *__getCommentInput) GetCommentId() *string { return v.CommentId }

// __getIntegrationInput is used internally by genqlient
type __getIntegrationInput struct {
	IntegrationId *string `json:"integrationId"`
}

// GetIntegrationId returns __getIntegrationInput.IntegrationId, and is useful for accessing the field via an interface.
func (v *__getIntegrationInput) GetIntegrationId() *string { return v.IntegrationId }

// __getIssueIdsInput is used internally by genqlient
type __getIssueIdsInput struct {
	IssueLabelId    *string `json:"issueLabelId"`
	First           int     `json:"first"`
	After           string  `json:"after"`
	IncludeArchived bool    `json:"includeArchived"`
}

// GetIssueLabelId returns __getIssueIdsInput.IssueLabelId, and is useful for accessing the field via an interface.
func (v *__getIssueIdsInput) GetIssueLabelId() *string { return v.IssueLabelId }

// GetFirst returns __getIssueIdsInput.First, and is useful for accessing the field via an interface.
func (v *__getIssueIdsInput) GetFirst() int { return v.First }

// GetAfter returns __getIssueIdsInput.After, and is useful for accessing the field via an interface.
func (v *__getIssueIdsInput) GetAfter() string { return v.After }

// GetIncludeArchived returns __getIssueIdsInput.IncludeArchived, and is useful for accessing the field via an interface.
func (v *__getIssueIdsInput) GetIncludeArchived() bool { return v.IncludeArchived }

// __getIssueInput is used internally by genqlient
type __getIssueInput struct {
	IssueId *string `json:"issueId"`
}

// GetIssueId returns __getIssueInput.IssueId, and is useful for accessing the field via an interface.
func (v *__getIssueInput) GetIssueId() *string { return v.IssueId }

// __getIssueLabelInput is used internally by genqlient
type __getIssueLabelInput struct {
	IssueLabelId    *string `json:"issueLabelId"`
	FirstIssue      int     `json:"firstIssue"`
	IncludeArchived bool    `json:"includeArchived"`
}

// GetIssueLabelId returns __getIssueLabelInput.IssueLabelId, and is useful for accessing the field via an interface.
func (v *__getIssueLabelInput) GetIssueLabelId() *string { return v.IssueLabelId }

// GetFirstIssue returns __getIssueLabelInput.FirstIssue, and is useful for accessing the field via an interface.
func (v *__getIssueLabelInput) GetFirstIssue() int { return v.FirstIssue }

// GetIncludeArchived returns __getIssueLabelInput.IncludeArchived, and is useful for accessing the field via an interface.
func (v *__getIssueLabelInput) GetIncludeArchived() bool { return v.IncludeArchived }

// __getProjectInput is used internally by genqlient
type __getProjectInput struct {
	ProjectId *string `json:"projectId"`
}

// GetProjectId returns __getProjectInput.ProjectId, and is useful for accessing the field via an interface.
func (v *__getProjectInput) GetProjectId() *string { return v.ProjectId }

// __getTeamInput is used internally by genqlient
type __getTeamInput struct {
	TeamId *string `json:"teamId"`
}

// GetTeamId returns __getTeamInput.TeamId, and is useful for accessing the field via an interface.
func (v *__getTeamInput) GetTeamId() *string { return v.TeamId }

// __getTeamMembershipInput is used internally by genqlient
type __getTeamMembershipInput struct {
	TeamMembershipId *string `json:"teamMembershipId"`
}

// GetTeamMembershipId returns __getTeamMembershipInput.TeamMembershipId, and is useful for accessing the field via an interface.
func (v *__getTeamMembershipInput) GetTeamMembershipId() *string { return v.TeamMembershipId }

// __getUserInput is used internally by genqlient
type __getUserInput struct {
	UserId *string `json:"userId"`
}

// GetUserId returns __getUserInput.UserId, and is useful for accessing the field via an interface.
func (v *__getUserInput) GetUserId() *string { return v.UserId }

// __listAttachmentsInput is used internally by genqlient
type __listAttachmentsInput struct {
	First           int               `json:"first,omitempty"`
	After           string            `json:"after,omitempty"`
	IncludeArchived bool              `json:"includeArchived,omitempty"`
	Filter          *AttachmentFilter `json:"filter,omitempty"`
}

// GetFirst returns __listAttachmentsInput.First, and is useful for accessing the field via an interface.
func (v *__listAttachmentsInput) GetFirst() int { return v.First }

// GetAfter returns __listAttachmentsInput.After, and is useful for accessing the field via an interface.
func (v *__listAttachmentsInput) GetAfter() string { return v.After }

// GetIncludeArchived returns __listAttachmentsInput.IncludeArchived, and is useful for accessing the field via an interface.
func (v *__listAttachmentsInput) GetIncludeArchived() bool { return v.IncludeArchived }

// GetFilter returns __listAttachmentsInput.Filter, and is useful for accessing the field via an interface.
func (v *__listAttachmentsInput) GetFilter() *AttachmentFilter { return v.Filter }

// __listCommentsInput is used internally by genqlient
type __listCommentsInput struct {
	First           int            `json:"first,omitempty"`
	After           string         `json:"after,omitempty"`
	IncludeArchived bool           `json:"includeArchived,omitempty"`
	Filter          *CommentFilter `json:"filter,omitempty"`
}

// GetFirst returns __listCommentsInput.First, and is useful for accessing the field via an interface.
func (v *__listCommentsInput) GetFirst() int { return v.First }

// GetAfter returns __listCommentsInput.After, and is useful for accessing the field via an interface.
func (v *__listCommentsInput) GetAfter() string { return v.After }

// GetIncludeArchived returns __listCommentsInput.IncludeArchived, and is useful for accessing the field via an interface.
func (v *__listCommentsInput) GetIncludeArchived() bool { return v.IncludeArchived }

// GetFilter returns __listCommentsInput.Filter, and is useful for accessing the field via an interface.
func (v *__listCommentsInput) GetFilter() *CommentFilter { return v.Filter }

// __listIntegrationsInput is used internally by genqlient
type __listIntegrationsInput struct {
	First           int    `json:"first,omitempty"`
	After           string `json:"after,omitempty"`
	IncludeArchived bool   `json:"includeArchived,omitempty"`
}

// GetFirst returns __listIntegrationsInput.First, and is useful for accessing the field via an interface.
func (v *__listIntegrationsInput) GetFirst() int { return v.First }

// GetAfter returns __listIntegrationsInput.After, and is useful for accessing the field via an interface.
func (v *__listIntegrationsInput) GetAfter() string { return v.After }

// GetIncludeArchived returns __listIntegrationsInput.IncludeArchived, and is useful for accessing the field via an interface.
func (v *__listIntegrationsInput) GetIncludeArchived() bool { return v.IncludeArchived }

// __listIssueLabelsInput is used internally by genqlient
type __listIssueLabelsInput struct {
	First           int               `json:"first,omitempty"`
	FirstIssue      int               `json:"firstIssue,omitempty"`
	After           string            `json:"after,omitempty"`
	IncludeArchived bool              `json:"includeArchived,omitempty"`
	Filter          *IssueLabelFilter `json:"filter,omitempty"`
}

// GetFirst returns __listIssueLabelsInput.First, and is useful for accessing the field via an interface.
func (v *__listIssueLabelsInput) GetFirst() int { return v.First }

// GetFirstIssue returns __listIssueLabelsInput.FirstIssue, and is useful for accessing the field via an interface.
func (v *__listIssueLabelsInput) GetFirstIssue() int { return v.FirstIssue }

// GetAfter returns __listIssueLabelsInput.After, and is useful for accessing the field via an interface.
func (v *__listIssueLabelsInput) GetAfter() string { return v.After }

// GetIncludeArchived returns __listIssueLabelsInput.IncludeArchived, and is useful for accessing the field via an interface.
func (v *__listIssueLabelsInput) GetIncludeArchived() bool { return v.IncludeArchived }

// GetFilter returns __listIssueLabelsInput.Filter, and is useful for accessing the field via an interface.
func (v *__listIssueLabelsInput) GetFilter() *IssueLabelFilter { return v.Filter }

// __listIssuesInput is used internally by genqlient
type __listIssuesInput struct {
	First           int          `json:"first,omitempty"`
	After           string       `json:"after,omitempty"`
	IncludeArchived bool         `json:"includeArchived,omitempty"`
	Filter          *IssueFilter `json:"filter,omitempty"`
}

// GetFirst returns __listIssuesInput.First, and is useful for accessing the field via an interface.
func (v *__listIssuesInput) GetFirst() int { return v.First }

// GetAfter returns __listIssuesInput.After, and is useful for accessing the field via an interface.
func (v *__listIssuesInput) GetAfter() string { return v.After }

// GetIncludeArchived returns __listIssuesInput.IncludeArchived, and is useful for accessing the field via an interface.
func (v *__listIssuesInput) GetIncludeArchived() bool { return v.IncludeArchived }

// GetFilter returns __listIssuesInput.Filter, and is useful for accessing the field via an interface.
func (v *__listIssuesInput) GetFilter() *IssueFilter { return v.Filter }

// __listProjectsInput is used internally by genqlient
type __listProjectsInput struct {
	First           int            `json:"first,omitempty"`
	After           string         `json:"after,omitempty"`
	IncludeArchived bool           `json:"includeArchived,omitempty"`
	Filter          *ProjectFilter `json:"filter,omitempty"`
}

// GetFirst returns __listProjectsInput.First, and is useful for accessing the field via an interface.
func (v *__listProjectsInput) GetFirst() int { return v.First }

// GetAfter returns __listProjectsInput.After, and is useful for accessing the field via an interface.
func (v *__listProjectsInput) GetAfter() string { return v.After }

// GetIncludeArchived returns __listProjectsInput.IncludeArchived, and is useful for accessing the field via an interface.
func (v *__listProjectsInput) GetIncludeArchived() bool { return v.IncludeArchived }

// GetFilter returns __listProjectsInput.Filter, and is useful for accessing the field via an interface.
func (v *__listProjectsInput) GetFilter() *ProjectFilter { return v.Filter }

// __listTeamMembershipsInput is used internally by genqlient
type __listTeamMembershipsInput struct {
	First           int    `json:"first,omitempty"`
	After           string `json:"after,omitempty"`
	IncludeArchived bool   `json:"includeArchived,omitempty"`
}

// GetFirst returns __listTeamMembershipsInput.First, and is useful for accessing the field via an interface.
func (v *__listTeamMembershipsInput) GetFirst() int { return v.First }

// GetAfter returns __listTeamMembershipsInput.After, and is useful for accessing the field via an interface.
func (v *__listTeamMembershipsInput) GetAfter() string { return v.After }

// GetIncludeArchived returns __listTeamMembershipsInput.IncludeArchived, and is useful for accessing the field via an interface.
func (v *__listTeamMembershipsInput) GetIncludeArchived() bool { return v.IncludeArchived }

// __listTeamsInput is used internally by genqlient
type __listTeamsInput struct {
	First           int         `json:"first,omitempty"`
	After           string      `json:"after,omitempty"`
	IncludeArchived bool        `json:"includeArchived,omitempty"`
	Filter          *TeamFilter `json:"filter,omitempty"`
}

// GetFirst returns __listTeamsInput.First, and is useful for accessing the field via an interface.
func (v *__listTeamsInput) GetFirst() int { return v.First }

// GetAfter returns __listTeamsInput.After, and is useful for accessing the field via an interface.
func (v *__listTeamsInput) GetAfter() string { return v.After }

// GetIncludeArchived returns __listTeamsInput.IncludeArchived, and is useful for accessing the field via an interface.
func (v *__listTeamsInput) GetIncludeArchived() bool { return v.IncludeArchived }

// GetFilter returns __listTeamsInput.Filter, and is useful for accessing the field via an interface.
func (v *__listTeamsInput) GetFilter() *TeamFilter { return v.Filter }

// __listUsersInput is used internally by genqlient
type __listUsersInput struct {
	First           int         `json:"first,omitempty"`
	After           string      `json:"after,omitempty"`
	IncludeArchived bool        `json:"includeArchived,omitempty"`
	Filter          *UserFilter `json:"filter,omitempty"`
}

// GetFirst returns __listUsersInput.First, and is useful for accessing the field via an interface.
func (v *__listUsersInput) GetFirst() int { return v.First }

// GetAfter returns __listUsersInput.After, and is useful for accessing the field via an interface.
func (v *__listUsersInput) GetAfter() string { return v.After }

// GetIncludeArchived returns __listUsersInput.IncludeArchived, and is useful for accessing the field via an interface.
func (v *__listUsersInput) GetIncludeArchived() bool { return v.IncludeArchived }

// GetFilter returns __listUsersInput.Filter, and is useful for accessing the field via an interface.
func (v *__listUsersInput) GetFilter() *UserFilter { return v.Filter }

// getAttachmentAttachment includes the requested fields of the GraphQL type Attachment.
// The GraphQL type's documentation follows.
//
// Issue attachment (e.g. support ticket, pull request).
type getAttachmentAttachment struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Indicates if attachments for the same source application should be grouped in the Linear UI.
	GroupBySource *bool `json:"groupBySource"`
	// Custom metadata related to the attachment.
	Metadata *json.RawMessage `json:"metadata"`
	// Information about the source which created the attachment.
	Source *json.RawMessage `json:"source"`
	// An accessor helper to source.type, defines the source type of the attachment.
	SourceType *string `json:"sourceType"`
	// Content for the subtitle line in the Linear attachment widget.
	Subtitle *string `json:"subtitle"`
	// Content for the title line in the Linear attachment widget.
	Title *string `json:"title"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// Location of the attachment which is also used as an identifier.
	Url *string `json:"url"`
	// The creator of the attachment.
	Creator *getAttachmentAttachmentCreatorUser `json:"creator"`
	// The issue this attachment belongs to.
	Issue *getAttachmentAttachmentIssue `json:"issue"`
}

// GetId returns getAttachmentAttachment.Id, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachment) GetId() *string { return v.Id }

// GetArchivedAt returns getAttachmentAttachment.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachment) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetCreatedAt returns getAttachmentAttachment.CreatedAt, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachment) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetGroupBySource returns getAttachmentAttachment.GroupBySource, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachment) GetGroupBySource() *bool { return v.GroupBySource }

// GetMetadata returns getAttachmentAttachment.Metadata, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachment) GetMetadata() *json.RawMessage { return v.Metadata }

// GetSource returns getAttachmentAttachment.Source, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachment) GetSource() *json.RawMessage { return v.Source }

// GetSourceType returns getAttachmentAttachment.SourceType, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachment) GetSourceType() *string { return v.SourceType }

// GetSubtitle returns getAttachmentAttachment.Subtitle, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachment) GetSubtitle() *string { return v.Subtitle }

// GetTitle returns getAttachmentAttachment.Title, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachment) GetTitle() *string { return v.Title }

// GetUpdatedAt returns getAttachmentAttachment.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachment) GetUpdatedAt() *time.Time { return v.UpdatedAt }

// GetUrl returns getAttachmentAttachment.Url, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachment) GetUrl() *string { return v.Url }

// GetCreator returns getAttachmentAttachment.Creator, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachment) GetCreator() *getAttachmentAttachmentCreatorUser { return v.Creator }

// GetIssue returns getAttachmentAttachment.Issue, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachment) GetIssue() *getAttachmentAttachmentIssue { return v.Issue }

func (v *getAttachmentAttachment) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getAttachmentAttachment
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getAttachmentAttachment = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getAttachmentAttachment.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getAttachmentAttachment.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getAttachmentAttachment.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetAttachmentAttachment struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	CreatedAt json.RawMessage `json:"createdAt"`

	GroupBySource *bool `json:"groupBySource"`

	Metadata *json.RawMessage `json:"metadata"`

	Source *json.RawMessage `json:"source"`

	SourceType *string `json:"sourceType"`

	Subtitle *string `json:"subtitle"`

	Title *string `json:"title"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	Url *string `json:"url"`

	Creator *getAttachmentAttachmentCreatorUser `json:"creator"`

	Issue *getAttachmentAttachmentIssue `json:"issue"`
}

func (v *getAttachmentAttachment) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getAttachmentAttachment) __premarshalJSON() (*__premarshalgetAttachmentAttachment, error) {
	var retval __premarshalgetAttachmentAttachment

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getAttachmentAttachment.ArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getAttachmentAttachment.CreatedAt: %w", err)
			}
		}
	}
	retval.GroupBySource = v.GroupBySource
	retval.Metadata = v.Metadata
	retval.Source = v.Source
	retval.SourceType = v.SourceType
	retval.Subtitle = v.Subtitle
	retval.Title = v.Title
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getAttachmentAttachment.UpdatedAt: %w", err)
			}
		}
	}
	retval.Url = v.Url
	retval.Creator = v.Creator
	retval.Issue = v.Issue
	return &retval, nil
}

// getAttachmentAttachmentCreatorUser includes the requested fields of the GraphQL type User.
// The GraphQL type's documentation follows.
//
// A user that has access to the the resources of an organization.
type getAttachmentAttachmentCreatorUser struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// Whether the user account is active or disabled (suspended).
	Active *bool `json:"active"`
	// Whether the user is an organization administrator.
	Admin *bool `json:"admin"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// An URL to the user's avatar image.
	AvatarUrl *string `json:"avatarUrl"`
	// [DEPRECATED] Hash for the user to be used in calendar URLs.
	CalendarHash *string `json:"calendarHash"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Number of issues created.
	CreatedIssueCount *int `json:"createdIssueCount"`
	// A short description of the user, either its title or bio.
	Description *string `json:"description"`
	// Reason why is the account disabled.
	DisableReason *string `json:"disableReason"`
	// The user's display (nick) name. Unique within each organization.
	DisplayName *string `json:"displayName"`
	// The user's email address.
	Email *string `json:"email"`
	// Whether the user is a guest in the workspace and limited to accessing a subset of teams.
	Guest *bool `json:"guest"`
	// Unique hash for the user to be used in invite URLs.
	InviteHash *string `json:"inviteHash"`
	// Whether the user is the currently authenticated user.
	IsMe *bool `json:"isMe"`
	// The last time the user was seen online. If null, the user is currently online.
	LastSeen *time.Time `json:"-"`
	// The user's full name.
	Name *string `json:"name"`
	// The emoji to represent the user current status.
	StatusEmoji *string `json:"statusEmoji"`
	// The label of the user current status.
	StatusLabel *string `json:"statusLabel"`
	// A date at which the user current status should be cleared.
	StatusUntilAt *time.Time `json:"-"`
	// The local timezone of the user.
	Timezone *string `json:"timezone"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// User's profile URL.
	Url *string `json:"url"`
}

// GetId returns getAttachmentAttachmentCreatorUser.Id, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentCreatorUser) GetId() *string { return v.Id }

// GetActive returns getAttachmentAttachmentCreatorUser.Active, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentCreatorUser) GetActive() *bool { return v.Active }

// GetAdmin returns getAttachmentAttachmentCreatorUser.Admin, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentCreatorUser) GetAdmin() *bool { return v.Admin }

// GetArchivedAt returns getAttachmentAttachmentCreatorUser.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentCreatorUser) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetAvatarUrl returns getAttachmentAttachmentCreatorUser.AvatarUrl, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentCreatorUser) GetAvatarUrl() *string { return v.AvatarUrl }

// GetCalendarHash returns getAttachmentAttachmentCreatorUser.CalendarHash, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentCreatorUser) GetCalendarHash() *string { return v.CalendarHash }

// GetCreatedAt returns getAttachmentAttachmentCreatorUser.CreatedAt, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentCreatorUser) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetCreatedIssueCount returns getAttachmentAttachmentCreatorUser.CreatedIssueCount, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentCreatorUser) GetCreatedIssueCount() *int { return v.CreatedIssueCount }

// GetDescription returns getAttachmentAttachmentCreatorUser.Description, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentCreatorUser) GetDescription() *string { return v.Description }

// GetDisableReason returns getAttachmentAttachmentCreatorUser.DisableReason, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentCreatorUser) GetDisableReason() *string { return v.DisableReason }

// GetDisplayName returns getAttachmentAttachmentCreatorUser.DisplayName, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentCreatorUser) GetDisplayName() *string { return v.DisplayName }

// GetEmail returns getAttachmentAttachmentCreatorUser.Email, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentCreatorUser) GetEmail() *string { return v.Email }

// GetGuest returns getAttachmentAttachmentCreatorUser.Guest, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentCreatorUser) GetGuest() *bool { return v.Guest }

// GetInviteHash returns getAttachmentAttachmentCreatorUser.InviteHash, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentCreatorUser) GetInviteHash() *string { return v.InviteHash }

// GetIsMe returns getAttachmentAttachmentCreatorUser.IsMe, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentCreatorUser) GetIsMe() *bool { return v.IsMe }

// GetLastSeen returns getAttachmentAttachmentCreatorUser.LastSeen, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentCreatorUser) GetLastSeen() *time.Time { return v.LastSeen }

// GetName returns getAttachmentAttachmentCreatorUser.Name, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentCreatorUser) GetName() *string { return v.Name }

// GetStatusEmoji returns getAttachmentAttachmentCreatorUser.StatusEmoji, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentCreatorUser) GetStatusEmoji() *string { return v.StatusEmoji }

// GetStatusLabel returns getAttachmentAttachmentCreatorUser.StatusLabel, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentCreatorUser) GetStatusLabel() *string { return v.StatusLabel }

// GetStatusUntilAt returns getAttachmentAttachmentCreatorUser.StatusUntilAt, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentCreatorUser) GetStatusUntilAt() *time.Time { return v.StatusUntilAt }

// GetTimezone returns getAttachmentAttachmentCreatorUser.Timezone, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentCreatorUser) GetTimezone() *string { return v.Timezone }

// GetUpdatedAt returns getAttachmentAttachmentCreatorUser.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentCreatorUser) GetUpdatedAt() *time.Time { return v.UpdatedAt }

// GetUrl returns getAttachmentAttachmentCreatorUser.Url, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentCreatorUser) GetUrl() *string { return v.Url }

func (v *getAttachmentAttachmentCreatorUser) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getAttachmentAttachmentCreatorUser
		ArchivedAt    json.RawMessage `json:"archivedAt"`
		CreatedAt     json.RawMessage `json:"createdAt"`
		LastSeen      json.RawMessage `json:"lastSeen"`
		StatusUntilAt json.RawMessage `json:"statusUntilAt"`
		UpdatedAt     json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getAttachmentAttachmentCreatorUser = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getAttachmentAttachmentCreatorUser.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getAttachmentAttachmentCreatorUser.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.LastSeen
		src := firstPass.LastSeen
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getAttachmentAttachmentCreatorUser.LastSeen: %w", err)
			}
		}
	}

	{
		dst := &v.StatusUntilAt
		src := firstPass.StatusUntilAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getAttachmentAttachmentCreatorUser.StatusUntilAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getAttachmentAttachmentCreatorUser.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetAttachmentAttachmentCreatorUser struct {
	Id *string `json:"id"`

	Active *bool `json:"active"`

	Admin *bool `json:"admin"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AvatarUrl *string `json:"avatarUrl"`

	CalendarHash *string `json:"calendarHash"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CreatedIssueCount *int `json:"createdIssueCount"`

	Description *string `json:"description"`

	DisableReason *string `json:"disableReason"`

	DisplayName *string `json:"displayName"`

	Email *string `json:"email"`

	Guest *bool `json:"guest"`

	InviteHash *string `json:"inviteHash"`

	IsMe *bool `json:"isMe"`

	LastSeen json.RawMessage `json:"lastSeen"`

	Name *string `json:"name"`

	StatusEmoji *string `json:"statusEmoji"`

	StatusLabel *string `json:"statusLabel"`

	StatusUntilAt json.RawMessage `json:"statusUntilAt"`

	Timezone *string `json:"timezone"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	Url *string `json:"url"`
}

func (v *getAttachmentAttachmentCreatorUser) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getAttachmentAttachmentCreatorUser) __premarshalJSON() (*__premarshalgetAttachmentAttachmentCreatorUser, error) {
	var retval __premarshalgetAttachmentAttachmentCreatorUser

	retval.Id = v.Id
	retval.Active = v.Active
	retval.Admin = v.Admin
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getAttachmentAttachmentCreatorUser.ArchivedAt: %w", err)
			}
		}
	}
	retval.AvatarUrl = v.AvatarUrl
	retval.CalendarHash = v.CalendarHash
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getAttachmentAttachmentCreatorUser.CreatedAt: %w", err)
			}
		}
	}
	retval.CreatedIssueCount = v.CreatedIssueCount
	retval.Description = v.Description
	retval.DisableReason = v.DisableReason
	retval.DisplayName = v.DisplayName
	retval.Email = v.Email
	retval.Guest = v.Guest
	retval.InviteHash = v.InviteHash
	retval.IsMe = v.IsMe
	{

		dst := &retval.LastSeen
		src := v.LastSeen
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getAttachmentAttachmentCreatorUser.LastSeen: %w", err)
			}
		}
	}
	retval.Name = v.Name
	retval.StatusEmoji = v.StatusEmoji
	retval.StatusLabel = v.StatusLabel
	{

		dst := &retval.StatusUntilAt
		src := v.StatusUntilAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getAttachmentAttachmentCreatorUser.StatusUntilAt: %w", err)
			}
		}
	}
	retval.Timezone = v.Timezone
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getAttachmentAttachmentCreatorUser.UpdatedAt: %w", err)
			}
		}
	}
	retval.Url = v.Url
	return &retval, nil
}

// getAttachmentAttachmentIssue includes the requested fields of the GraphQL type Issue.
// The GraphQL type's documentation follows.
//
// An issue.
type getAttachmentAttachmentIssue struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The issue's unique number.
	Number *float64 `json:"number"`
	// The issue's title.
	Title *string `json:"title"`
	// The issue's description in markdown format.
	Description *string `json:"description"`
	// The priority of the issue. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low.
	Priority *float64 `json:"priority"`
	// The estimate of the complexity of the issue..
	Estimate *float64 `json:"estimate"`
	// The order of the item in relation to other items in the organization.
	SortOrder *float64 `json:"sortOrder"`
	// The time at which the issue was moved into started state.
	StartedAt *time.Time `json:"-"`
	// The time at which the issue was moved into completed state.
	CompletedAt *time.Time `json:"-"`
	// The time at which the issue was moved into canceled state.
	CanceledAt *time.Time `json:"-"`
	// The time at which the issue was automatically closed by the auto pruning process.
	AutoClosedAt *time.Time `json:"-"`
	// The time at which the issue was automatically archived by the auto pruning process.
	AutoArchivedAt *time.Time `json:"-"`
	// The date at which the issue is due.
	DueDate *time.Time `json:"-"`
	// A flag that indicates whether the issue is in the trash bin.
	Trashed *bool `json:"trashed"`
	// The time until an issue will be snoozed in Triage view.
	SnoozedUntilAt *time.Time `json:"-"`
	// Previous identifiers of the issue if it has been moved between teams.
	PreviousIdentifiers []*string `json:"previousIdentifiers"`
	// The order of the item in the sub-issue list. Only set if the issue has a parent.
	SubIssueSortOrder *float64 `json:"subIssueSortOrder"`
	// Label for the priority.
	PriorityLabel *string `json:"priorityLabel"`
	// Issue's human readable identifier (e.g. ENG-123).
	Identifier *string `json:"identifier"`
	// Issue URL.
	Url *string `json:"url"`
	// Suggested branch name for the issue.
	BranchName *string `json:"branchName"`
	// Returns the number of Attachment resources which are created by customer support ticketing systems (e.g. Zendesk).
	CustomerTicketCount *int `json:"customerTicketCount"`
}

// GetId returns getAttachmentAttachmentIssue.Id, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentIssue) GetId() *string { return v.Id }

// GetCreatedAt returns getAttachmentAttachmentIssue.CreatedAt, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentIssue) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetUpdatedAt returns getAttachmentAttachmentIssue.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentIssue) GetUpdatedAt() *time.Time { return v.UpdatedAt }

// GetArchivedAt returns getAttachmentAttachmentIssue.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentIssue) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetNumber returns getAttachmentAttachmentIssue.Number, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentIssue) GetNumber() *float64 { return v.Number }

// GetTitle returns getAttachmentAttachmentIssue.Title, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentIssue) GetTitle() *string { return v.Title }

// GetDescription returns getAttachmentAttachmentIssue.Description, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentIssue) GetDescription() *string { return v.Description }

// GetPriority returns getAttachmentAttachmentIssue.Priority, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentIssue) GetPriority() *float64 { return v.Priority }

// GetEstimate returns getAttachmentAttachmentIssue.Estimate, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentIssue) GetEstimate() *float64 { return v.Estimate }

// GetSortOrder returns getAttachmentAttachmentIssue.SortOrder, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentIssue) GetSortOrder() *float64 { return v.SortOrder }

// GetStartedAt returns getAttachmentAttachmentIssue.StartedAt, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentIssue) GetStartedAt() *time.Time { return v.StartedAt }

// GetCompletedAt returns getAttachmentAttachmentIssue.CompletedAt, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentIssue) GetCompletedAt() *time.Time { return v.CompletedAt }

// GetCanceledAt returns getAttachmentAttachmentIssue.CanceledAt, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentIssue) GetCanceledAt() *time.Time { return v.CanceledAt }

// GetAutoClosedAt returns getAttachmentAttachmentIssue.AutoClosedAt, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentIssue) GetAutoClosedAt() *time.Time { return v.AutoClosedAt }

// GetAutoArchivedAt returns getAttachmentAttachmentIssue.AutoArchivedAt, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentIssue) GetAutoArchivedAt() *time.Time { return v.AutoArchivedAt }

// GetDueDate returns getAttachmentAttachmentIssue.DueDate, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentIssue) GetDueDate() *time.Time { return v.DueDate }

// GetTrashed returns getAttachmentAttachmentIssue.Trashed, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentIssue) GetTrashed() *bool { return v.Trashed }

// GetSnoozedUntilAt returns getAttachmentAttachmentIssue.SnoozedUntilAt, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentIssue) GetSnoozedUntilAt() *time.Time { return v.SnoozedUntilAt }

// GetPreviousIdentifiers returns getAttachmentAttachmentIssue.PreviousIdentifiers, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentIssue) GetPreviousIdentifiers() []*string {
	return v.PreviousIdentifiers
}

// GetSubIssueSortOrder returns getAttachmentAttachmentIssue.SubIssueSortOrder, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentIssue) GetSubIssueSortOrder() *float64 { return v.SubIssueSortOrder }

// GetPriorityLabel returns getAttachmentAttachmentIssue.PriorityLabel, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentIssue) GetPriorityLabel() *string { return v.PriorityLabel }

// GetIdentifier returns getAttachmentAttachmentIssue.Identifier, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentIssue) GetIdentifier() *string { return v.Identifier }

// GetUrl returns getAttachmentAttachmentIssue.Url, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentIssue) GetUrl() *string { return v.Url }

// GetBranchName returns getAttachmentAttachmentIssue.BranchName, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentIssue) GetBranchName() *string { return v.BranchName }

// GetCustomerTicketCount returns getAttachmentAttachmentIssue.CustomerTicketCount, and is useful for accessing the field via an interface.
func (v *getAttachmentAttachmentIssue) GetCustomerTicketCount() *int { return v.CustomerTicketCount }

func (v *getAttachmentAttachmentIssue) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getAttachmentAttachmentIssue
		CreatedAt      json.RawMessage `json:"createdAt"`
		UpdatedAt      json.RawMessage `json:"updatedAt"`
		ArchivedAt     json.RawMessage `json:"archivedAt"`
		StartedAt      json.RawMessage `json:"startedAt"`
		CompletedAt    json.RawMessage `json:"completedAt"`
		CanceledAt     json.RawMessage `json:"canceledAt"`
		AutoClosedAt   json.RawMessage `json:"autoClosedAt"`
		AutoArchivedAt json.RawMessage `json:"autoArchivedAt"`
		DueDate        json.RawMessage `json:"dueDate"`
		SnoozedUntilAt json.RawMessage `json:"snoozedUntilAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getAttachmentAttachmentIssue = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getAttachmentAttachmentIssue.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getAttachmentAttachmentIssue.UpdatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getAttachmentAttachmentIssue.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.StartedAt
		src := firstPass.StartedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getAttachmentAttachmentIssue.StartedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CompletedAt
		src := firstPass.CompletedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getAttachmentAttachmentIssue.CompletedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CanceledAt
		src := firstPass.CanceledAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getAttachmentAttachmentIssue.CanceledAt: %w", err)
			}
		}
	}

	{
		dst := &v.AutoClosedAt
		src := firstPass.AutoClosedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getAttachmentAttachmentIssue.AutoClosedAt: %w", err)
			}
		}
	}

	{
		dst := &v.AutoArchivedAt
		src := firstPass.AutoArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getAttachmentAttachmentIssue.AutoArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.DueDate
		src := firstPass.DueDate
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getAttachmentAttachmentIssue.DueDate: %w", err)
			}
		}
	}

	{
		dst := &v.SnoozedUntilAt
		src := firstPass.SnoozedUntilAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getAttachmentAttachmentIssue.SnoozedUntilAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetAttachmentAttachmentIssue struct {
	Id *string `json:"id"`

	CreatedAt json.RawMessage `json:"createdAt"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	Number *float64 `json:"number"`

	Title *string `json:"title"`

	Description *string `json:"description"`

	Priority *float64 `json:"priority"`

	Estimate *float64 `json:"estimate"`

	SortOrder *float64 `json:"sortOrder"`

	StartedAt json.RawMessage `json:"startedAt"`

	CompletedAt json.RawMessage `json:"completedAt"`

	CanceledAt json.RawMessage `json:"canceledAt"`

	AutoClosedAt json.RawMessage `json:"autoClosedAt"`

	AutoArchivedAt json.RawMessage `json:"autoArchivedAt"`

	DueDate json.RawMessage `json:"dueDate"`

	Trashed *bool `json:"trashed"`

	SnoozedUntilAt json.RawMessage `json:"snoozedUntilAt"`

	PreviousIdentifiers []*string `json:"previousIdentifiers"`

	SubIssueSortOrder *float64 `json:"subIssueSortOrder"`

	PriorityLabel *string `json:"priorityLabel"`

	Identifier *string `json:"identifier"`

	Url *string `json:"url"`

	BranchName *string `json:"branchName"`

	CustomerTicketCount *int `json:"customerTicketCount"`
}

func (v *getAttachmentAttachmentIssue) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getAttachmentAttachmentIssue) __premarshalJSON() (*__premarshalgetAttachmentAttachmentIssue, error) {
	var retval __premarshalgetAttachmentAttachmentIssue

	retval.Id = v.Id
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getAttachmentAttachmentIssue.CreatedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getAttachmentAttachmentIssue.UpdatedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getAttachmentAttachmentIssue.ArchivedAt: %w", err)
			}
		}
	}
	retval.Number = v.Number
	retval.Title = v.Title
	retval.Description = v.Description
	retval.Priority = v.Priority
	retval.Estimate = v.Estimate
	retval.SortOrder = v.SortOrder
	{

		dst := &retval.StartedAt
		src := v.StartedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getAttachmentAttachmentIssue.StartedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CompletedAt
		src := v.CompletedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getAttachmentAttachmentIssue.CompletedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CanceledAt
		src := v.CanceledAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getAttachmentAttachmentIssue.CanceledAt: %w", err)
			}
		}
	}
	{

		dst := &retval.AutoClosedAt
		src := v.AutoClosedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getAttachmentAttachmentIssue.AutoClosedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.AutoArchivedAt
		src := v.AutoArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getAttachmentAttachmentIssue.AutoArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.DueDate
		src := v.DueDate
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getAttachmentAttachmentIssue.DueDate: %w", err)
			}
		}
	}
	retval.Trashed = v.Trashed
	{

		dst := &retval.SnoozedUntilAt
		src := v.SnoozedUntilAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getAttachmentAttachmentIssue.SnoozedUntilAt: %w", err)
			}
		}
	}
	retval.PreviousIdentifiers = v.PreviousIdentifiers
	retval.SubIssueSortOrder = v.SubIssueSortOrder
	retval.PriorityLabel = v.PriorityLabel
	retval.Identifier = v.Identifier
	retval.Url = v.Url
	retval.BranchName = v.BranchName
	retval.CustomerTicketCount = v.CustomerTicketCount
	return &retval, nil
}

// getAttachmentResponse is returned by getAttachment on success.
type getAttachmentResponse struct {
	// One specific issue attachment.
	// [Deprecated] 'url' can no longer be used as the 'id' parameter. Use 'attachmentsForUrl' instead
	Attachment *getAttachmentAttachment `json:"attachment"`
}

// GetAttachment returns getAttachmentResponse.Attachment, and is useful for accessing the field via an interface.
func (v *getAttachmentResponse) GetAttachment() *getAttachmentAttachment { return v.Attachment }

// getCommentComment includes the requested fields of the GraphQL type Comment.
// The GraphQL type's documentation follows.
//
// A comment associated with an issue.
type getCommentComment struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The comment content in markdown format.
	Body *string `json:"body"`
	// The comment content as a Prosemirror document.
	BodyData *string `json:"bodyData"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// The time user edited the comment.
	EditedAt *time.Time `json:"-"`
	// Emoji reaction summary, grouped by emoji type
	ReactionData *json.RawMessage `json:"reactionData"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// Comment's URL.
	Url *string `json:"url"`
	// The user who wrote the comment.
	User *getCommentCommentUser `json:"user"`
	// The parent comment under which the current comment is nested.
	Parent *getCommentCommentParentComment `json:"parent"`
	// The issue that the comment is associated with.
	Issue *getCommentCommentIssue `json:"issue"`
}

// GetId returns getCommentComment.Id, and is useful for accessing the field via an interface.
func (v *getCommentComment) GetId() *string { return v.Id }

// GetArchivedAt returns getCommentComment.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getCommentComment) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetBody returns getCommentComment.Body, and is useful for accessing the field via an interface.
func (v *getCommentComment) GetBody() *string { return v.Body }

// GetBodyData returns getCommentComment.BodyData, and is useful for accessing the field via an interface.
func (v *getCommentComment) GetBodyData() *string { return v.BodyData }

// GetCreatedAt returns getCommentComment.CreatedAt, and is useful for accessing the field via an interface.
func (v *getCommentComment) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetEditedAt returns getCommentComment.EditedAt, and is useful for accessing the field via an interface.
func (v *getCommentComment) GetEditedAt() *time.Time { return v.EditedAt }

// GetReactionData returns getCommentComment.ReactionData, and is useful for accessing the field via an interface.
func (v *getCommentComment) GetReactionData() *json.RawMessage { return v.ReactionData }

// GetUpdatedAt returns getCommentComment.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getCommentComment) GetUpdatedAt() *time.Time { return v.UpdatedAt }

// GetUrl returns getCommentComment.Url, and is useful for accessing the field via an interface.
func (v *getCommentComment) GetUrl() *string { return v.Url }

// GetUser returns getCommentComment.User, and is useful for accessing the field via an interface.
func (v *getCommentComment) GetUser() *getCommentCommentUser { return v.User }

// GetParent returns getCommentComment.Parent, and is useful for accessing the field via an interface.
func (v *getCommentComment) GetParent() *getCommentCommentParentComment { return v.Parent }

// GetIssue returns getCommentComment.Issue, and is useful for accessing the field via an interface.
func (v *getCommentComment) GetIssue() *getCommentCommentIssue { return v.Issue }

func (v *getCommentComment) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getCommentComment
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		EditedAt   json.RawMessage `json:"editedAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getCommentComment = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getCommentComment.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getCommentComment.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.EditedAt
		src := firstPass.EditedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getCommentComment.EditedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getCommentComment.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetCommentComment struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	Body *string `json:"body"`

	BodyData *string `json:"bodyData"`

	CreatedAt json.RawMessage `json:"createdAt"`

	EditedAt json.RawMessage `json:"editedAt"`

	ReactionData *json.RawMessage `json:"reactionData"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	Url *string `json:"url"`

	User *getCommentCommentUser `json:"user"`

	Parent *getCommentCommentParentComment `json:"parent"`

	Issue *getCommentCommentIssue `json:"issue"`
}

func (v *getCommentComment) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getCommentComment) __premarshalJSON() (*__premarshalgetCommentComment, error) {
	var retval __premarshalgetCommentComment

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getCommentComment.ArchivedAt: %w", err)
			}
		}
	}
	retval.Body = v.Body
	retval.BodyData = v.BodyData
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getCommentComment.CreatedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.EditedAt
		src := v.EditedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getCommentComment.EditedAt: %w", err)
			}
		}
	}
	retval.ReactionData = v.ReactionData
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getCommentComment.UpdatedAt: %w", err)
			}
		}
	}
	retval.Url = v.Url
	retval.User = v.User
	retval.Parent = v.Parent
	retval.Issue = v.Issue
	return &retval, nil
}

// getCommentCommentIssue includes the requested fields of the GraphQL type Issue.
// The GraphQL type's documentation follows.
//
// An issue.
type getCommentCommentIssue struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The issue's unique number.
	Number *float64 `json:"number"`
	// The issue's title.
	Title *string `json:"title"`
	// The issue's description in markdown format.
	Description *string `json:"description"`
	// The priority of the issue. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low.
	Priority *float64 `json:"priority"`
	// The estimate of the complexity of the issue..
	Estimate *float64 `json:"estimate"`
	// The order of the item in relation to other items in the organization.
	SortOrder *float64 `json:"sortOrder"`
	// The time at which the issue was moved into started state.
	StartedAt *time.Time `json:"-"`
	// The time at which the issue was moved into completed state.
	CompletedAt *time.Time `json:"-"`
	// The time at which the issue was moved into canceled state.
	CanceledAt *time.Time `json:"-"`
	// The time at which the issue was automatically closed by the auto pruning process.
	AutoClosedAt *time.Time `json:"-"`
	// The time at which the issue was automatically archived by the auto pruning process.
	AutoArchivedAt *time.Time `json:"-"`
	// The date at which the issue is due.
	DueDate *time.Time `json:"-"`
	// A flag that indicates whether the issue is in the trash bin.
	Trashed *bool `json:"trashed"`
	// The time until an issue will be snoozed in Triage view.
	SnoozedUntilAt *time.Time `json:"-"`
	// Previous identifiers of the issue if it has been moved between teams.
	PreviousIdentifiers []*string `json:"previousIdentifiers"`
	// The order of the item in the sub-issue list. Only set if the issue has a parent.
	SubIssueSortOrder *float64 `json:"subIssueSortOrder"`
	// Label for the priority.
	PriorityLabel *string `json:"priorityLabel"`
	// Issue's human readable identifier (e.g. ENG-123).
	Identifier *string `json:"identifier"`
	// Issue URL.
	Url *string `json:"url"`
	// Suggested branch name for the issue.
	BranchName *string `json:"branchName"`
	// Returns the number of Attachment resources which are created by customer support ticketing systems (e.g. Zendesk).
	CustomerTicketCount *int `json:"customerTicketCount"`
}

// GetId returns getCommentCommentIssue.Id, and is useful for accessing the field via an interface.
func (v *getCommentCommentIssue) GetId() *string { return v.Id }

// GetCreatedAt returns getCommentCommentIssue.CreatedAt, and is useful for accessing the field via an interface.
func (v *getCommentCommentIssue) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetUpdatedAt returns getCommentCommentIssue.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getCommentCommentIssue) GetUpdatedAt() *time.Time { return v.UpdatedAt }

// GetArchivedAt returns getCommentCommentIssue.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getCommentCommentIssue) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetNumber returns getCommentCommentIssue.Number, and is useful for accessing the field via an interface.
func (v *getCommentCommentIssue) GetNumber() *float64 { return v.Number }

// GetTitle returns getCommentCommentIssue.Title, and is useful for accessing the field via an interface.
func (v *getCommentCommentIssue) GetTitle() *string { return v.Title }

// GetDescription returns getCommentCommentIssue.Description, and is useful for accessing the field via an interface.
func (v *getCommentCommentIssue) GetDescription() *string { return v.Description }

// GetPriority returns getCommentCommentIssue.Priority, and is useful for accessing the field via an interface.
func (v *getCommentCommentIssue) GetPriority() *float64 { return v.Priority }

// GetEstimate returns getCommentCommentIssue.Estimate, and is useful for accessing the field via an interface.
func (v *getCommentCommentIssue) GetEstimate() *float64 { return v.Estimate }

// GetSortOrder returns getCommentCommentIssue.SortOrder, and is useful for accessing the field via an interface.
func (v *getCommentCommentIssue) GetSortOrder() *float64 { return v.SortOrder }

// GetStartedAt returns getCommentCommentIssue.StartedAt, and is useful for accessing the field via an interface.
func (v *getCommentCommentIssue) GetStartedAt() *time.Time { return v.StartedAt }

// GetCompletedAt returns getCommentCommentIssue.CompletedAt, and is useful for accessing the field via an interface.
func (v *getCommentCommentIssue) GetCompletedAt() *time.Time { return v.CompletedAt }

// GetCanceledAt returns getCommentCommentIssue.CanceledAt, and is useful for accessing the field via an interface.
func (v *getCommentCommentIssue) GetCanceledAt() *time.Time { return v.CanceledAt }

// GetAutoClosedAt returns getCommentCommentIssue.AutoClosedAt, and is useful for accessing the field via an interface.
func (v *getCommentCommentIssue) GetAutoClosedAt() *time.Time { return v.AutoClosedAt }

// GetAutoArchivedAt returns getCommentCommentIssue.AutoArchivedAt, and is useful for accessing the field via an interface.
func (v *getCommentCommentIssue) GetAutoArchivedAt() *time.Time { return v.AutoArchivedAt }

// GetDueDate returns getCommentCommentIssue.DueDate, and is useful for accessing the field via an interface.
func (v *getCommentCommentIssue) GetDueDate() *time.Time { return v.DueDate }

// GetTrashed returns getCommentCommentIssue.Trashed, and is useful for accessing the field via an interface.
func (v *getCommentCommentIssue) GetTrashed() *bool { return v.Trashed }

// GetSnoozedUntilAt returns getCommentCommentIssue.SnoozedUntilAt, and is useful for accessing the field via an interface.
func (v *getCommentCommentIssue) GetSnoozedUntilAt() *time.Time { return v.SnoozedUntilAt }

// GetPreviousIdentifiers returns getCommentCommentIssue.PreviousIdentifiers, and is useful for accessing the field via an interface.
func (v *getCommentCommentIssue) GetPreviousIdentifiers() []*string { return v.PreviousIdentifiers }

// GetSubIssueSortOrder returns getCommentCommentIssue.SubIssueSortOrder, and is useful for accessing the field via an interface.
func (v *getCommentCommentIssue) GetSubIssueSortOrder() *float64 { return v.SubIssueSortOrder }

// GetPriorityLabel returns getCommentCommentIssue.PriorityLabel, and is useful for accessing the field via an interface.
func (v *getCommentCommentIssue) GetPriorityLabel() *string { return v.PriorityLabel }

// GetIdentifier returns getCommentCommentIssue.Identifier, and is useful for accessing the field via an interface.
func (v *getCommentCommentIssue) GetIdentifier() *string { return v.Identifier }

// GetUrl returns getCommentCommentIssue.Url, and is useful for accessing the field via an interface.
func (v *getCommentCommentIssue) GetUrl() *string { return v.Url }

// GetBranchName returns getCommentCommentIssue.BranchName, and is useful for accessing the field via an interface.
func (v *getCommentCommentIssue) GetBranchName() *string { return v.BranchName }

// GetCustomerTicketCount returns getCommentCommentIssue.CustomerTicketCount, and is useful for accessing the field via an interface.
func (v *getCommentCommentIssue) GetCustomerTicketCount() *int { return v.CustomerTicketCount }

func (v *getCommentCommentIssue) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getCommentCommentIssue
		CreatedAt      json.RawMessage `json:"createdAt"`
		UpdatedAt      json.RawMessage `json:"updatedAt"`
		ArchivedAt     json.RawMessage `json:"archivedAt"`
		StartedAt      json.RawMessage `json:"startedAt"`
		CompletedAt    json.RawMessage `json:"completedAt"`
		CanceledAt     json.RawMessage `json:"canceledAt"`
		AutoClosedAt   json.RawMessage `json:"autoClosedAt"`
		AutoArchivedAt json.RawMessage `json:"autoArchivedAt"`
		DueDate        json.RawMessage `json:"dueDate"`
		SnoozedUntilAt json.RawMessage `json:"snoozedUntilAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getCommentCommentIssue = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getCommentCommentIssue.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getCommentCommentIssue.UpdatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getCommentCommentIssue.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.StartedAt
		src := firstPass.StartedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getCommentCommentIssue.StartedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CompletedAt
		src := firstPass.CompletedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getCommentCommentIssue.CompletedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CanceledAt
		src := firstPass.CanceledAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getCommentCommentIssue.CanceledAt: %w", err)
			}
		}
	}

	{
		dst := &v.AutoClosedAt
		src := firstPass.AutoClosedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getCommentCommentIssue.AutoClosedAt: %w", err)
			}
		}
	}

	{
		dst := &v.AutoArchivedAt
		src := firstPass.AutoArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getCommentCommentIssue.AutoArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.DueDate
		src := firstPass.DueDate
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getCommentCommentIssue.DueDate: %w", err)
			}
		}
	}

	{
		dst := &v.SnoozedUntilAt
		src := firstPass.SnoozedUntilAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getCommentCommentIssue.SnoozedUntilAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetCommentCommentIssue struct {
	Id *string `json:"id"`

	CreatedAt json.RawMessage `json:"createdAt"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	Number *float64 `json:"number"`

	Title *string `json:"title"`

	Description *string `json:"description"`

	Priority *float64 `json:"priority"`

	Estimate *float64 `json:"estimate"`

	SortOrder *float64 `json:"sortOrder"`

	StartedAt json.RawMessage `json:"startedAt"`

	CompletedAt json.RawMessage `json:"completedAt"`

	CanceledAt json.RawMessage `json:"canceledAt"`

	AutoClosedAt json.RawMessage `json:"autoClosedAt"`

	AutoArchivedAt json.RawMessage `json:"autoArchivedAt"`

	DueDate json.RawMessage `json:"dueDate"`

	Trashed *bool `json:"trashed"`

	SnoozedUntilAt json.RawMessage `json:"snoozedUntilAt"`

	PreviousIdentifiers []*string `json:"previousIdentifiers"`

	SubIssueSortOrder *float64 `json:"subIssueSortOrder"`

	PriorityLabel *string `json:"priorityLabel"`

	Identifier *string `json:"identifier"`

	Url *string `json:"url"`

	BranchName *string `json:"branchName"`

	CustomerTicketCount *int `json:"customerTicketCount"`
}

func (v *getCommentCommentIssue) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getCommentCommentIssue) __premarshalJSON() (*__premarshalgetCommentCommentIssue, error) {
	var retval __premarshalgetCommentCommentIssue

	retval.Id = v.Id
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getCommentCommentIssue.CreatedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getCommentCommentIssue.UpdatedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getCommentCommentIssue.ArchivedAt: %w", err)
			}
		}
	}
	retval.Number = v.Number
	retval.Title = v.Title
	retval.Description = v.Description
	retval.Priority = v.Priority
	retval.Estimate = v.Estimate
	retval.SortOrder = v.SortOrder
	{

		dst := &retval.StartedAt
		src := v.StartedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getCommentCommentIssue.StartedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CompletedAt
		src := v.CompletedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getCommentCommentIssue.CompletedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CanceledAt
		src := v.CanceledAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getCommentCommentIssue.CanceledAt: %w", err)
			}
		}
	}
	{

		dst := &retval.AutoClosedAt
		src := v.AutoClosedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getCommentCommentIssue.AutoClosedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.AutoArchivedAt
		src := v.AutoArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getCommentCommentIssue.AutoArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.DueDate
		src := v.DueDate
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getCommentCommentIssue.DueDate: %w", err)
			}
		}
	}
	retval.Trashed = v.Trashed
	{

		dst := &retval.SnoozedUntilAt
		src := v.SnoozedUntilAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getCommentCommentIssue.SnoozedUntilAt: %w", err)
			}
		}
	}
	retval.PreviousIdentifiers = v.PreviousIdentifiers
	retval.SubIssueSortOrder = v.SubIssueSortOrder
	retval.PriorityLabel = v.PriorityLabel
	retval.Identifier = v.Identifier
	retval.Url = v.Url
	retval.BranchName = v.BranchName
	retval.CustomerTicketCount = v.CustomerTicketCount
	return &retval, nil
}

// getCommentCommentParentComment includes the requested fields of the GraphQL type Comment.
// The GraphQL type's documentation follows.
//
// A comment associated with an issue.
type getCommentCommentParentComment struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The comment content in markdown format.
	Body *string `json:"body"`
	// The comment content as a Prosemirror document.
	BodyData *string `json:"bodyData"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// The time user edited the comment.
	EditedAt *time.Time `json:"-"`
	// Emoji reaction summary, grouped by emoji type
	ReactionData *json.RawMessage `json:"reactionData"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// Comment's URL.
	Url *string `json:"url"`
}

// GetId returns getCommentCommentParentComment.Id, and is useful for accessing the field via an interface.
func (v *getCommentCommentParentComment) GetId() *string { return v.Id }

// GetArchivedAt returns getCommentCommentParentComment.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getCommentCommentParentComment) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetBody returns getCommentCommentParentComment.Body, and is useful for accessing the field via an interface.
func (v *getCommentCommentParentComment) GetBody() *string { return v.Body }

// GetBodyData returns getCommentCommentParentComment.BodyData, and is useful for accessing the field via an interface.
func (v *getCommentCommentParentComment) GetBodyData() *string { return v.BodyData }

// GetCreatedAt returns getCommentCommentParentComment.CreatedAt, and is useful for accessing the field via an interface.
func (v *getCommentCommentParentComment) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetEditedAt returns getCommentCommentParentComment.EditedAt, and is useful for accessing the field via an interface.
func (v *getCommentCommentParentComment) GetEditedAt() *time.Time { return v.EditedAt }

// GetReactionData returns getCommentCommentParentComment.ReactionData, and is useful for accessing the field via an interface.
func (v *getCommentCommentParentComment) GetReactionData() *json.RawMessage { return v.ReactionData }

// GetUpdatedAt returns getCommentCommentParentComment.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getCommentCommentParentComment) GetUpdatedAt() *time.Time { return v.UpdatedAt }

// GetUrl returns getCommentCommentParentComment.Url, and is useful for accessing the field via an interface.
func (v *getCommentCommentParentComment) GetUrl() *string { return v.Url }

func (v *getCommentCommentParentComment) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getCommentCommentParentComment
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		EditedAt   json.RawMessage `json:"editedAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getCommentCommentParentComment = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getCommentCommentParentComment.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getCommentCommentParentComment.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.EditedAt
		src := firstPass.EditedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getCommentCommentParentComment.EditedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getCommentCommentParentComment.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetCommentCommentParentComment struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	Body *string `json:"body"`

	BodyData *string `json:"bodyData"`

	CreatedAt json.RawMessage `json:"createdAt"`

	EditedAt json.RawMessage `json:"editedAt"`

	ReactionData *json.RawMessage `json:"reactionData"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	Url *string `json:"url"`
}

func (v *getCommentCommentParentComment) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getCommentCommentParentComment) __premarshalJSON() (*__premarshalgetCommentCommentParentComment, error) {
	var retval __premarshalgetCommentCommentParentComment

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getCommentCommentParentComment.ArchivedAt: %w", err)
			}
		}
	}
	retval.Body = v.Body
	retval.BodyData = v.BodyData
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getCommentCommentParentComment.CreatedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.EditedAt
		src := v.EditedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getCommentCommentParentComment.EditedAt: %w", err)
			}
		}
	}
	retval.ReactionData = v.ReactionData
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getCommentCommentParentComment.UpdatedAt: %w", err)
			}
		}
	}
	retval.Url = v.Url
	return &retval, nil
}

// getCommentCommentUser includes the requested fields of the GraphQL type User.
// The GraphQL type's documentation follows.
//
// A user that has access to the the resources of an organization.
type getCommentCommentUser struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// Whether the user account is active or disabled (suspended).
	Active *bool `json:"active"`
	// Whether the user is an organization administrator.
	Admin *bool `json:"admin"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// An URL to the user's avatar image.
	AvatarUrl *string `json:"avatarUrl"`
	// [DEPRECATED] Hash for the user to be used in calendar URLs.
	CalendarHash *string `json:"calendarHash"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Number of issues created.
	CreatedIssueCount *int `json:"createdIssueCount"`
	// A short description of the user, either its title or bio.
	Description *string `json:"description"`
	// Reason why is the account disabled.
	DisableReason *string `json:"disableReason"`
	// The user's display (nick) name. Unique within each organization.
	DisplayName *string `json:"displayName"`
	// The user's email address.
	Email *string `json:"email"`
	// Whether the user is a guest in the workspace and limited to accessing a subset of teams.
	Guest *bool `json:"guest"`
	// Unique hash for the user to be used in invite URLs.
	InviteHash *string `json:"inviteHash"`
	// Whether the user is the currently authenticated user.
	IsMe *bool `json:"isMe"`
	// The last time the user was seen online. If null, the user is currently online.
	LastSeen *time.Time `json:"-"`
	// The user's full name.
	Name *string `json:"name"`
	// The emoji to represent the user current status.
	StatusEmoji *string `json:"statusEmoji"`
	// The label of the user current status.
	StatusLabel *string `json:"statusLabel"`
	// A date at which the user current status should be cleared.
	StatusUntilAt *time.Time `json:"-"`
	// The local timezone of the user.
	Timezone *string `json:"timezone"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// User's profile URL.
	Url *string `json:"url"`
}

// GetId returns getCommentCommentUser.Id, and is useful for accessing the field via an interface.
func (v *getCommentCommentUser) GetId() *string { return v.Id }

// GetActive returns getCommentCommentUser.Active, and is useful for accessing the field via an interface.
func (v *getCommentCommentUser) GetActive() *bool { return v.Active }

// GetAdmin returns getCommentCommentUser.Admin, and is useful for accessing the field via an interface.
func (v *getCommentCommentUser) GetAdmin() *bool { return v.Admin }

// GetArchivedAt returns getCommentCommentUser.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getCommentCommentUser) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetAvatarUrl returns getCommentCommentUser.AvatarUrl, and is useful for accessing the field via an interface.
func (v *getCommentCommentUser) GetAvatarUrl() *string { return v.AvatarUrl }

// GetCalendarHash returns getCommentCommentUser.CalendarHash, and is useful for accessing the field via an interface.
func (v *getCommentCommentUser) GetCalendarHash() *string { return v.CalendarHash }

// GetCreatedAt returns getCommentCommentUser.CreatedAt, and is useful for accessing the field via an interface.
func (v *getCommentCommentUser) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetCreatedIssueCount returns getCommentCommentUser.CreatedIssueCount, and is useful for accessing the field via an interface.
func (v *getCommentCommentUser) GetCreatedIssueCount() *int { return v.CreatedIssueCount }

// GetDescription returns getCommentCommentUser.Description, and is useful for accessing the field via an interface.
func (v *getCommentCommentUser) GetDescription() *string { return v.Description }

// GetDisableReason returns getCommentCommentUser.DisableReason, and is useful for accessing the field via an interface.
func (v *getCommentCommentUser) GetDisableReason() *string { return v.DisableReason }

// GetDisplayName returns getCommentCommentUser.DisplayName, and is useful for accessing the field via an interface.
func (v *getCommentCommentUser) GetDisplayName() *string { return v.DisplayName }

// GetEmail returns getCommentCommentUser.Email, and is useful for accessing the field via an interface.
func (v *getCommentCommentUser) GetEmail() *string { return v.Email }

// GetGuest returns getCommentCommentUser.Guest, and is useful for accessing the field via an interface.
func (v *getCommentCommentUser) GetGuest() *bool { return v.Guest }

// GetInviteHash returns getCommentCommentUser.InviteHash, and is useful for accessing the field via an interface.
func (v *getCommentCommentUser) GetInviteHash() *string { return v.InviteHash }

// GetIsMe returns getCommentCommentUser.IsMe, and is useful for accessing the field via an interface.
func (v *getCommentCommentUser) GetIsMe() *bool { return v.IsMe }

// GetLastSeen returns getCommentCommentUser.LastSeen, and is useful for accessing the field via an interface.
func (v *getCommentCommentUser) GetLastSeen() *time.Time { return v.LastSeen }

// GetName returns getCommentCommentUser.Name, and is useful for accessing the field via an interface.
func (v *getCommentCommentUser) GetName() *string { return v.Name }

// GetStatusEmoji returns getCommentCommentUser.StatusEmoji, and is useful for accessing the field via an interface.
func (v *getCommentCommentUser) GetStatusEmoji() *string { return v.StatusEmoji }

// GetStatusLabel returns getCommentCommentUser.StatusLabel, and is useful for accessing the field via an interface.
func (v *getCommentCommentUser) GetStatusLabel() *string { return v.StatusLabel }

// GetStatusUntilAt returns getCommentCommentUser.StatusUntilAt, and is useful for accessing the field via an interface.
func (v *getCommentCommentUser) GetStatusUntilAt() *time.Time { return v.StatusUntilAt }

// GetTimezone returns getCommentCommentUser.Timezone, and is useful for accessing the field via an interface.
func (v *getCommentCommentUser) GetTimezone() *string { return v.Timezone }

// GetUpdatedAt returns getCommentCommentUser.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getCommentCommentUser) GetUpdatedAt() *time.Time { return v.UpdatedAt }

// GetUrl returns getCommentCommentUser.Url, and is useful for accessing the field via an interface.
func (v *getCommentCommentUser) GetUrl() *string { return v.Url }

func (v *getCommentCommentUser) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getCommentCommentUser
		ArchivedAt    json.RawMessage `json:"archivedAt"`
		CreatedAt     json.RawMessage `json:"createdAt"`
		LastSeen      json.RawMessage `json:"lastSeen"`
		StatusUntilAt json.RawMessage `json:"statusUntilAt"`
		UpdatedAt     json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getCommentCommentUser = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getCommentCommentUser.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getCommentCommentUser.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.LastSeen
		src := firstPass.LastSeen
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getCommentCommentUser.LastSeen: %w", err)
			}
		}
	}

	{
		dst := &v.StatusUntilAt
		src := firstPass.StatusUntilAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getCommentCommentUser.StatusUntilAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getCommentCommentUser.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetCommentCommentUser struct {
	Id *string `json:"id"`

	Active *bool `json:"active"`

	Admin *bool `json:"admin"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AvatarUrl *string `json:"avatarUrl"`

	CalendarHash *string `json:"calendarHash"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CreatedIssueCount *int `json:"createdIssueCount"`

	Description *string `json:"description"`

	DisableReason *string `json:"disableReason"`

	DisplayName *string `json:"displayName"`

	Email *string `json:"email"`

	Guest *bool `json:"guest"`

	InviteHash *string `json:"inviteHash"`

	IsMe *bool `json:"isMe"`

	LastSeen json.RawMessage `json:"lastSeen"`

	Name *string `json:"name"`

	StatusEmoji *string `json:"statusEmoji"`

	StatusLabel *string `json:"statusLabel"`

	StatusUntilAt json.RawMessage `json:"statusUntilAt"`

	Timezone *string `json:"timezone"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	Url *string `json:"url"`
}

func (v *getCommentCommentUser) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getCommentCommentUser) __premarshalJSON() (*__premarshalgetCommentCommentUser, error) {
	var retval __premarshalgetCommentCommentUser

	retval.Id = v.Id
	retval.Active = v.Active
	retval.Admin = v.Admin
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getCommentCommentUser.ArchivedAt: %w", err)
			}
		}
	}
	retval.AvatarUrl = v.AvatarUrl
	retval.CalendarHash = v.CalendarHash
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getCommentCommentUser.CreatedAt: %w", err)
			}
		}
	}
	retval.CreatedIssueCount = v.CreatedIssueCount
	retval.Description = v.Description
	retval.DisableReason = v.DisableReason
	retval.DisplayName = v.DisplayName
	retval.Email = v.Email
	retval.Guest = v.Guest
	retval.InviteHash = v.InviteHash
	retval.IsMe = v.IsMe
	{

		dst := &retval.LastSeen
		src := v.LastSeen
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getCommentCommentUser.LastSeen: %w", err)
			}
		}
	}
	retval.Name = v.Name
	retval.StatusEmoji = v.StatusEmoji
	retval.StatusLabel = v.StatusLabel
	{

		dst := &retval.StatusUntilAt
		src := v.StatusUntilAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getCommentCommentUser.StatusUntilAt: %w", err)
			}
		}
	}
	retval.Timezone = v.Timezone
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getCommentCommentUser.UpdatedAt: %w", err)
			}
		}
	}
	retval.Url = v.Url
	return &retval, nil
}

// getCommentResponse is returned by getComment on success.
type getCommentResponse struct {
	// A specific comment.
	Comment *getCommentComment `json:"comment"`
}

// GetComment returns getCommentResponse.Comment, and is useful for accessing the field via an interface.
func (v *getCommentResponse) GetComment() *getCommentComment { return v.Comment }

// getIntegrationIntegration includes the requested fields of the GraphQL type Integration.
// The GraphQL type's documentation follows.
//
// An integration with an external service.
type getIntegrationIntegration struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// The integration's type.
	Service *string `json:"service"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// The team that the integration is associated with.
	Team *getIntegrationIntegrationTeam `json:"team"`
	// The user that added the integration.
	Creator *getIntegrationIntegrationCreatorUser `json:"creator"`
	// The organization that the integration is associated with.
	Organization *getIntegrationIntegrationOrganization `json:"organization"`
}

// GetId returns getIntegrationIntegration.Id, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegration) GetId() *string { return v.Id }

// GetArchivedAt returns getIntegrationIntegration.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegration) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetCreatedAt returns getIntegrationIntegration.CreatedAt, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegration) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetService returns getIntegrationIntegration.Service, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegration) GetService() *string { return v.Service }

// GetUpdatedAt returns getIntegrationIntegration.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegration) GetUpdatedAt() *time.Time { return v.UpdatedAt }

// GetTeam returns getIntegrationIntegration.Team, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegration) GetTeam() *getIntegrationIntegrationTeam { return v.Team }

// GetCreator returns getIntegrationIntegration.Creator, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegration) GetCreator() *getIntegrationIntegrationCreatorUser {
	return v.Creator
}

// GetOrganization returns getIntegrationIntegration.Organization, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegration) GetOrganization() *getIntegrationIntegrationOrganization {
	return v.Organization
}

func (v *getIntegrationIntegration) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getIntegrationIntegration
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getIntegrationIntegration = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIntegrationIntegration.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIntegrationIntegration.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIntegrationIntegration.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetIntegrationIntegration struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	CreatedAt json.RawMessage `json:"createdAt"`

	Service *string `json:"service"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	Team *getIntegrationIntegrationTeam `json:"team"`

	Creator *getIntegrationIntegrationCreatorUser `json:"creator"`

	Organization *getIntegrationIntegrationOrganization `json:"organization"`
}

func (v *getIntegrationIntegration) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getIntegrationIntegration) __premarshalJSON() (*__premarshalgetIntegrationIntegration, error) {
	var retval __premarshalgetIntegrationIntegration

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIntegrationIntegration.ArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIntegrationIntegration.CreatedAt: %w", err)
			}
		}
	}
	retval.Service = v.Service
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIntegrationIntegration.UpdatedAt: %w", err)
			}
		}
	}
	retval.Team = v.Team
	retval.Creator = v.Creator
	retval.Organization = v.Organization
	return &retval, nil
}

// getIntegrationIntegrationCreatorUser includes the requested fields of the GraphQL type User.
// The GraphQL type's documentation follows.
//
// A user that has access to the the resources of an organization.
type getIntegrationIntegrationCreatorUser struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// Whether the user account is active or disabled (suspended).
	Active *bool `json:"active"`
	// Whether the user is an organization administrator.
	Admin *bool `json:"admin"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// An URL to the user's avatar image.
	AvatarUrl *string `json:"avatarUrl"`
	// [DEPRECATED] Hash for the user to be used in calendar URLs.
	CalendarHash *string `json:"calendarHash"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Number of issues created.
	CreatedIssueCount *int `json:"createdIssueCount"`
	// A short description of the user, either its title or bio.
	Description *string `json:"description"`
	// Reason why is the account disabled.
	DisableReason *string `json:"disableReason"`
	// The user's display (nick) name. Unique within each organization.
	DisplayName *string `json:"displayName"`
	// The user's email address.
	Email *string `json:"email"`
	// Whether the user is a guest in the workspace and limited to accessing a subset of teams.
	Guest *bool `json:"guest"`
	// Unique hash for the user to be used in invite URLs.
	InviteHash *string `json:"inviteHash"`
	// Whether the user is the currently authenticated user.
	IsMe *bool `json:"isMe"`
	// The last time the user was seen online. If null, the user is currently online.
	LastSeen *time.Time `json:"-"`
	// The user's full name.
	Name *string `json:"name"`
	// The emoji to represent the user current status.
	StatusEmoji *string `json:"statusEmoji"`
	// The label of the user current status.
	StatusLabel *string `json:"statusLabel"`
	// A date at which the user current status should be cleared.
	StatusUntilAt *time.Time `json:"-"`
	// The local timezone of the user.
	Timezone *string `json:"timezone"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// User's profile URL.
	Url *string `json:"url"`
}

// GetId returns getIntegrationIntegrationCreatorUser.Id, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationCreatorUser) GetId() *string { return v.Id }

// GetActive returns getIntegrationIntegrationCreatorUser.Active, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationCreatorUser) GetActive() *bool { return v.Active }

// GetAdmin returns getIntegrationIntegrationCreatorUser.Admin, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationCreatorUser) GetAdmin() *bool { return v.Admin }

// GetArchivedAt returns getIntegrationIntegrationCreatorUser.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationCreatorUser) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetAvatarUrl returns getIntegrationIntegrationCreatorUser.AvatarUrl, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationCreatorUser) GetAvatarUrl() *string { return v.AvatarUrl }

// GetCalendarHash returns getIntegrationIntegrationCreatorUser.CalendarHash, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationCreatorUser) GetCalendarHash() *string { return v.CalendarHash }

// GetCreatedAt returns getIntegrationIntegrationCreatorUser.CreatedAt, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationCreatorUser) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetCreatedIssueCount returns getIntegrationIntegrationCreatorUser.CreatedIssueCount, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationCreatorUser) GetCreatedIssueCount() *int {
	return v.CreatedIssueCount
}

// GetDescription returns getIntegrationIntegrationCreatorUser.Description, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationCreatorUser) GetDescription() *string { return v.Description }

// GetDisableReason returns getIntegrationIntegrationCreatorUser.DisableReason, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationCreatorUser) GetDisableReason() *string { return v.DisableReason }

// GetDisplayName returns getIntegrationIntegrationCreatorUser.DisplayName, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationCreatorUser) GetDisplayName() *string { return v.DisplayName }

// GetEmail returns getIntegrationIntegrationCreatorUser.Email, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationCreatorUser) GetEmail() *string { return v.Email }

// GetGuest returns getIntegrationIntegrationCreatorUser.Guest, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationCreatorUser) GetGuest() *bool { return v.Guest }

// GetInviteHash returns getIntegrationIntegrationCreatorUser.InviteHash, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationCreatorUser) GetInviteHash() *string { return v.InviteHash }

// GetIsMe returns getIntegrationIntegrationCreatorUser.IsMe, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationCreatorUser) GetIsMe() *bool { return v.IsMe }

// GetLastSeen returns getIntegrationIntegrationCreatorUser.LastSeen, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationCreatorUser) GetLastSeen() *time.Time { return v.LastSeen }

// GetName returns getIntegrationIntegrationCreatorUser.Name, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationCreatorUser) GetName() *string { return v.Name }

// GetStatusEmoji returns getIntegrationIntegrationCreatorUser.StatusEmoji, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationCreatorUser) GetStatusEmoji() *string { return v.StatusEmoji }

// GetStatusLabel returns getIntegrationIntegrationCreatorUser.StatusLabel, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationCreatorUser) GetStatusLabel() *string { return v.StatusLabel }

// GetStatusUntilAt returns getIntegrationIntegrationCreatorUser.StatusUntilAt, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationCreatorUser) GetStatusUntilAt() *time.Time { return v.StatusUntilAt }

// GetTimezone returns getIntegrationIntegrationCreatorUser.Timezone, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationCreatorUser) GetTimezone() *string { return v.Timezone }

// GetUpdatedAt returns getIntegrationIntegrationCreatorUser.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationCreatorUser) GetUpdatedAt() *time.Time { return v.UpdatedAt }

// GetUrl returns getIntegrationIntegrationCreatorUser.Url, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationCreatorUser) GetUrl() *string { return v.Url }

func (v *getIntegrationIntegrationCreatorUser) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getIntegrationIntegrationCreatorUser
		ArchivedAt    json.RawMessage `json:"archivedAt"`
		CreatedAt     json.RawMessage `json:"createdAt"`
		LastSeen      json.RawMessage `json:"lastSeen"`
		StatusUntilAt json.RawMessage `json:"statusUntilAt"`
		UpdatedAt     json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getIntegrationIntegrationCreatorUser = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIntegrationIntegrationCreatorUser.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIntegrationIntegrationCreatorUser.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.LastSeen
		src := firstPass.LastSeen
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIntegrationIntegrationCreatorUser.LastSeen: %w", err)
			}
		}
	}

	{
		dst := &v.StatusUntilAt
		src := firstPass.StatusUntilAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIntegrationIntegrationCreatorUser.StatusUntilAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIntegrationIntegrationCreatorUser.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetIntegrationIntegrationCreatorUser struct {
	Id *string `json:"id"`

	Active *bool `json:"active"`

	Admin *bool `json:"admin"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AvatarUrl *string `json:"avatarUrl"`

	CalendarHash *string `json:"calendarHash"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CreatedIssueCount *int `json:"createdIssueCount"`

	Description *string `json:"description"`

	DisableReason *string `json:"disableReason"`

	DisplayName *string `json:"displayName"`

	Email *string `json:"email"`

	Guest *bool `json:"guest"`

	InviteHash *string `json:"inviteHash"`

	IsMe *bool `json:"isMe"`

	LastSeen json.RawMessage `json:"lastSeen"`

	Name *string `json:"name"`

	StatusEmoji *string `json:"statusEmoji"`

	StatusLabel *string `json:"statusLabel"`

	StatusUntilAt json.RawMessage `json:"statusUntilAt"`

	Timezone *string `json:"timezone"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	Url *string `json:"url"`
}

func (v *getIntegrationIntegrationCreatorUser) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getIntegrationIntegrationCreatorUser) __premarshalJSON() (*__premarshalgetIntegrationIntegrationCreatorUser, error) {
	var retval __premarshalgetIntegrationIntegrationCreatorUser

	retval.Id = v.Id
	retval.Active = v.Active
	retval.Admin = v.Admin
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIntegrationIntegrationCreatorUser.ArchivedAt: %w", err)
			}
		}
	}
	retval.AvatarUrl = v.AvatarUrl
	retval.CalendarHash = v.CalendarHash
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIntegrationIntegrationCreatorUser.CreatedAt: %w", err)
			}
		}
	}
	retval.CreatedIssueCount = v.CreatedIssueCount
	retval.Description = v.Description
	retval.DisableReason = v.DisableReason
	retval.DisplayName = v.DisplayName
	retval.Email = v.Email
	retval.Guest = v.Guest
	retval.InviteHash = v.InviteHash
	retval.IsMe = v.IsMe
	{

		dst := &retval.LastSeen
		src := v.LastSeen
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIntegrationIntegrationCreatorUser.LastSeen: %w", err)
			}
		}
	}
	retval.Name = v.Name
	retval.StatusEmoji = v.StatusEmoji
	retval.StatusLabel = v.StatusLabel
	{

		dst := &retval.StatusUntilAt
		src := v.StatusUntilAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIntegrationIntegrationCreatorUser.StatusUntilAt: %w", err)
			}
		}
	}
	retval.Timezone = v.Timezone
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIntegrationIntegrationCreatorUser.UpdatedAt: %w", err)
			}
		}
	}
	retval.Url = v.Url
	return &retval, nil
}

// getIntegrationIntegrationOrganization includes the requested fields of the GraphQL type Organization.
// The GraphQL type's documentation follows.
//
// An organization. Organizations are root-level objects that contain user accounts and teams.
type getIntegrationIntegrationOrganization struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// Allowed authentication providers, empty array means all are allowed
	AllowedAuthServices []*string `json:"allowedAuthServices"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Number of issues in the organization.
	CreatedIssueCount *int `json:"createdIssueCount"`
	// The time at which deletion of the organization was requested.
	DeletionRequestedAt *time.Time `json:"-"`
	// How git branches are formatted. If null, default formatting will be used.
	GitBranchFormat *string `json:"gitBranchFormat"`
	// Whether the Git integration linkback messages should be sent to private repositories.
	GitLinkbackMessagesEnabled *bool `json:"gitLinkbackMessagesEnabled"`
	// Whether the Git integration linkback messages should be sent to public repositories.
	GitPublicLinkbackMessagesEnabled *bool `json:"gitPublicLinkbackMessagesEnabled"`
	// The organization's logo URL.
	LogoUrl *string `json:"logoUrl"`
	// The organization's name.
	Name *string `json:"name"`
	// Rolling 30-day total upload volume for the organization, in megabytes.
	PeriodUploadVolume *float64 `json:"periodUploadVolume"`
	// Previously used URL keys for the organization (last 3 are kept and redirected).
	PreviousUrlKeys []*string `json:"previousUrlKeys"`
	// The day at which to prompt for project updates.
	ProjectUpdateRemindersDay *Day `json:"projectUpdateRemindersDay"`
	// The hour at which to prompt for project updates.
	ProjectUpdateRemindersHour *float64 `json:"projectUpdateRemindersHour"`
	// The frequency at which to prompt for project updates.
	ProjectUpdatesReminderFrequency *ProjectUpdateReminderFrequency `json:"projectUpdatesReminderFrequency"`
	// The feature release channel the organization belongs to.
	ReleaseChannel *ReleaseChannel `json:"releaseChannel"`
	// Whether the organization is using a roadmap.
	RoadmapEnabled *bool `json:"roadmapEnabled"`
	// Whether SAML authentication is enabled for organization.
	SamlEnabled *bool `json:"samlEnabled"`
	// Whether SCIM provisioning is enabled for organization.
	ScimEnabled *bool `json:"scimEnabled"`
	// The time at which the trial of the plus plan will end.
	TrialEndsAt *time.Time `json:"-"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// The organization's unique URL key.
	UrlKey *string `json:"urlKey"`
	// Number of active users in the organization.
	UserCount *int `json:"userCount"`
}

// GetId returns getIntegrationIntegrationOrganization.Id, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationOrganization) GetId() *string { return v.Id }

// GetAllowedAuthServices returns getIntegrationIntegrationOrganization.AllowedAuthServices, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationOrganization) GetAllowedAuthServices() []*string {
	return v.AllowedAuthServices
}

// GetArchivedAt returns getIntegrationIntegrationOrganization.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationOrganization) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetCreatedAt returns getIntegrationIntegrationOrganization.CreatedAt, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationOrganization) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetCreatedIssueCount returns getIntegrationIntegrationOrganization.CreatedIssueCount, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationOrganization) GetCreatedIssueCount() *int {
	return v.CreatedIssueCount
}

// GetDeletionRequestedAt returns getIntegrationIntegrationOrganization.DeletionRequestedAt, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationOrganization) GetDeletionRequestedAt() *time.Time {
	return v.DeletionRequestedAt
}

// GetGitBranchFormat returns getIntegrationIntegrationOrganization.GitBranchFormat, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationOrganization) GetGitBranchFormat() *string {
	return v.GitBranchFormat
}

// GetGitLinkbackMessagesEnabled returns getIntegrationIntegrationOrganization.GitLinkbackMessagesEnabled, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationOrganization) GetGitLinkbackMessagesEnabled() *bool {
	return v.GitLinkbackMessagesEnabled
}

// GetGitPublicLinkbackMessagesEnabled returns getIntegrationIntegrationOrganization.GitPublicLinkbackMessagesEnabled, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationOrganization) GetGitPublicLinkbackMessagesEnabled() *bool {
	return v.GitPublicLinkbackMessagesEnabled
}

// GetLogoUrl returns getIntegrationIntegrationOrganization.LogoUrl, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationOrganization) GetLogoUrl() *string { return v.LogoUrl }

// GetName returns getIntegrationIntegrationOrganization.Name, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationOrganization) GetName() *string { return v.Name }

// GetPeriodUploadVolume returns getIntegrationIntegrationOrganization.PeriodUploadVolume, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationOrganization) GetPeriodUploadVolume() *float64 {
	return v.PeriodUploadVolume
}

// GetPreviousUrlKeys returns getIntegrationIntegrationOrganization.PreviousUrlKeys, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationOrganization) GetPreviousUrlKeys() []*string {
	return v.PreviousUrlKeys
}

// GetProjectUpdateRemindersDay returns getIntegrationIntegrationOrganization.ProjectUpdateRemindersDay, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationOrganization) GetProjectUpdateRemindersDay() *Day {
	return v.ProjectUpdateRemindersDay
}

// GetProjectUpdateRemindersHour returns getIntegrationIntegrationOrganization.ProjectUpdateRemindersHour, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationOrganization) GetProjectUpdateRemindersHour() *float64 {
	return v.ProjectUpdateRemindersHour
}

// GetProjectUpdatesReminderFrequency returns getIntegrationIntegrationOrganization.ProjectUpdatesReminderFrequency, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationOrganization) GetProjectUpdatesReminderFrequency() *ProjectUpdateReminderFrequency {
	return v.ProjectUpdatesReminderFrequency
}

// GetReleaseChannel returns getIntegrationIntegrationOrganization.ReleaseChannel, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationOrganization) GetReleaseChannel() *ReleaseChannel {
	return v.ReleaseChannel
}

// GetRoadmapEnabled returns getIntegrationIntegrationOrganization.RoadmapEnabled, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationOrganization) GetRoadmapEnabled() *bool { return v.RoadmapEnabled }

// GetSamlEnabled returns getIntegrationIntegrationOrganization.SamlEnabled, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationOrganization) GetSamlEnabled() *bool { return v.SamlEnabled }

// GetScimEnabled returns getIntegrationIntegrationOrganization.ScimEnabled, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationOrganization) GetScimEnabled() *bool { return v.ScimEnabled }

// GetTrialEndsAt returns getIntegrationIntegrationOrganization.TrialEndsAt, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationOrganization) GetTrialEndsAt() *time.Time { return v.TrialEndsAt }

// GetUpdatedAt returns getIntegrationIntegrationOrganization.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationOrganization) GetUpdatedAt() *time.Time { return v.UpdatedAt }

// GetUrlKey returns getIntegrationIntegrationOrganization.UrlKey, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationOrganization) GetUrlKey() *string { return v.UrlKey }

// GetUserCount returns getIntegrationIntegrationOrganization.UserCount, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationOrganization) GetUserCount() *int { return v.UserCount }

func (v *getIntegrationIntegrationOrganization) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getIntegrationIntegrationOrganization
		ArchivedAt          json.RawMessage `json:"archivedAt"`
		CreatedAt           json.RawMessage `json:"createdAt"`
		DeletionRequestedAt json.RawMessage `json:"deletionRequestedAt"`
		TrialEndsAt         json.RawMessage `json:"trialEndsAt"`
		UpdatedAt           json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getIntegrationIntegrationOrganization = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIntegrationIntegrationOrganization.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIntegrationIntegrationOrganization.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.DeletionRequestedAt
		src := firstPass.DeletionRequestedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIntegrationIntegrationOrganization.DeletionRequestedAt: %w", err)
			}
		}
	}

	{
		dst := &v.TrialEndsAt
		src := firstPass.TrialEndsAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIntegrationIntegrationOrganization.TrialEndsAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIntegrationIntegrationOrganization.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetIntegrationIntegrationOrganization struct {
	Id *string `json:"id"`

	AllowedAuthServices []*string `json:"allowedAuthServices"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CreatedIssueCount *int `json:"createdIssueCount"`

	DeletionRequestedAt json.RawMessage `json:"deletionRequestedAt"`

	GitBranchFormat *string `json:"gitBranchFormat"`

	GitLinkbackMessagesEnabled *bool `json:"gitLinkbackMessagesEnabled"`

	GitPublicLinkbackMessagesEnabled *bool `json:"gitPublicLinkbackMessagesEnabled"`

	LogoUrl *string `json:"logoUrl"`

	Name *string `json:"name"`

	PeriodUploadVolume *float64 `json:"periodUploadVolume"`

	PreviousUrlKeys []*string `json:"previousUrlKeys"`

	ProjectUpdateRemindersDay *Day `json:"projectUpdateRemindersDay"`

	ProjectUpdateRemindersHour *float64 `json:"projectUpdateRemindersHour"`

	ProjectUpdatesReminderFrequency *ProjectUpdateReminderFrequency `json:"projectUpdatesReminderFrequency"`

	ReleaseChannel *ReleaseChannel `json:"releaseChannel"`

	RoadmapEnabled *bool `json:"roadmapEnabled"`

	SamlEnabled *bool `json:"samlEnabled"`

	ScimEnabled *bool `json:"scimEnabled"`

	TrialEndsAt json.RawMessage `json:"trialEndsAt"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	UrlKey *string `json:"urlKey"`

	UserCount *int `json:"userCount"`
}

func (v *getIntegrationIntegrationOrganization) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getIntegrationIntegrationOrganization) __premarshalJSON() (*__premarshalgetIntegrationIntegrationOrganization, error) {
	var retval __premarshalgetIntegrationIntegrationOrganization

	retval.Id = v.Id
	retval.AllowedAuthServices = v.AllowedAuthServices
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIntegrationIntegrationOrganization.ArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIntegrationIntegrationOrganization.CreatedAt: %w", err)
			}
		}
	}
	retval.CreatedIssueCount = v.CreatedIssueCount
	{

		dst := &retval.DeletionRequestedAt
		src := v.DeletionRequestedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIntegrationIntegrationOrganization.DeletionRequestedAt: %w", err)
			}
		}
	}
	retval.GitBranchFormat = v.GitBranchFormat
	retval.GitLinkbackMessagesEnabled = v.GitLinkbackMessagesEnabled
	retval.GitPublicLinkbackMessagesEnabled = v.GitPublicLinkbackMessagesEnabled
	retval.LogoUrl = v.LogoUrl
	retval.Name = v.Name
	retval.PeriodUploadVolume = v.PeriodUploadVolume
	retval.PreviousUrlKeys = v.PreviousUrlKeys
	retval.ProjectUpdateRemindersDay = v.ProjectUpdateRemindersDay
	retval.ProjectUpdateRemindersHour = v.ProjectUpdateRemindersHour
	retval.ProjectUpdatesReminderFrequency = v.ProjectUpdatesReminderFrequency
	retval.ReleaseChannel = v.ReleaseChannel
	retval.RoadmapEnabled = v.RoadmapEnabled
	retval.SamlEnabled = v.SamlEnabled
	retval.ScimEnabled = v.ScimEnabled
	{

		dst := &retval.TrialEndsAt
		src := v.TrialEndsAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIntegrationIntegrationOrganization.TrialEndsAt: %w", err)
			}
		}
	}
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIntegrationIntegrationOrganization.UpdatedAt: %w", err)
			}
		}
	}
	retval.UrlKey = v.UrlKey
	retval.UserCount = v.UserCount
	return &retval, nil
}

// getIntegrationIntegrationTeam includes the requested fields of the GraphQL type Team.
// The GraphQL type's documentation follows.
//
// An organizational unit that contains issues.
type getIntegrationIntegrationTeam struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// Period after which automatically closed and completed issues are automatically archived in months.
	AutoArchivePeriod *float64 `json:"autoArchivePeriod"`
	// Period after which issues are automatically closed in months. Null/undefined means disabled.
	AutoClosePeriod *float64 `json:"autoClosePeriod"`
	// The canceled workflow state which auto closed issues will be set to. Defaults to the first canceled state.
	AutoCloseStateId *string `json:"autoCloseStateId"`
	// The team's color.
	Color *string `json:"color"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Calendar feed URL (iCal) for cycles.
	CycleCalenderUrl *string `json:"cycleCalenderUrl"`
	// The cooldown time after each cycle in weeks.
	CycleCooldownTime *float64 `json:"cycleCooldownTime"`
	// The duration of a cycle in weeks.
	CycleDuration *float64 `json:"cycleDuration"`
	// Auto assign completed issues to current cycle.
	CycleIssueAutoAssignCompleted *bool `json:"cycleIssueAutoAssignCompleted"`
	// Auto assign started issues to current cycle.
	CycleIssueAutoAssignStarted *bool `json:"cycleIssueAutoAssignStarted"`
	// Only allow issues issues with cycles in Active Issues.
	CycleLockToActive *bool `json:"cycleLockToActive"`
	// The day of the week that a new cycle starts.
	CycleStartDay *float64 `json:"cycleStartDay"`
	// Whether the team uses cycles.
	CyclesEnabled *bool `json:"cyclesEnabled"`
	// What to use as an default estimate for unestimated issues.
	DefaultIssueEstimate *float64 `json:"defaultIssueEstimate"`
	// The id of the default template to use for new issues created by members of the team.
	DefaultTemplateForMembersId *string `json:"defaultTemplateForMembersId"`
	// The id of the default template to use for new issues created by non-members of the team.
	DefaultTemplateForNonMembersId *string `json:"defaultTemplateForNonMembersId"`
	// The team's description.
	Description *string `json:"description"`
	// Whether to group recent issue history entries.
	GroupIssueHistory *bool `json:"groupIssueHistory"`
	// The icon of the team.
	Icon *string `json:"icon"`
	// Unique hash for the team to be used in invite URLs.
	InviteHash *string `json:"inviteHash"`
	// Whether to allow zeros in issues estimates.
	IssueEstimationAllowZero *bool `json:"issueEstimationAllowZero"`
	// Whether to add additional points to the estimate scale.
	IssueEstimationExtended *bool `json:"issueEstimationExtended"`
	// The issue estimation type to use.
	IssueEstimationType *string `json:"issueEstimationType"`
	// Whether issues without priority should be sorted first.
	IssueOrderingNoPriorityFirst *bool `json:"issueOrderingNoPriorityFirst"`
	// Whether to move issues to bottom of the column when changing state.
	IssueSortOrderDefaultToBottom *bool `json:"issueSortOrderDefaultToBottom"`
	// The team's unique key. The key is used in URLs.
	Key *string `json:"key"`
	// The team's name.
	Name *string `json:"name"`
	// Whether the team is private or not.
	Private *bool `json:"private"`
	// Whether an issue needs to have a priority set before leaving triage
	RequirePriorityToLeaveTriage *bool `json:"requirePriorityToLeaveTriage"`
	// Whether to send new issue comment notifications to Slack.
	SlackIssueComments *bool `json:"slackIssueComments"`
	// Whether to send new issue status updates to Slack.
	SlackIssueStatuses *bool `json:"slackIssueStatuses"`
	// Whether to send new issue notifications to Slack.
	SlackNewIssue *bool `json:"slackNewIssue"`
	// The timezone of the team. Defaults to "America/Los_Angeles"
	Timezone *string `json:"timezone"`
	// Whether triage mode is enabled for the team or not.
	TriageEnabled *bool `json:"triageEnabled"`
	// How many upcoming cycles to create.
	UpcomingCycleCount *float64 `json:"upcomingCycleCount"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
}

// GetId returns getIntegrationIntegrationTeam.Id, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationTeam) GetId() *string { return v.Id }

// GetArchivedAt returns getIntegrationIntegrationTeam.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationTeam) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetAutoArchivePeriod returns getIntegrationIntegrationTeam.AutoArchivePeriod, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationTeam) GetAutoArchivePeriod() *float64 { return v.AutoArchivePeriod }

// GetAutoClosePeriod returns getIntegrationIntegrationTeam.AutoClosePeriod, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationTeam) GetAutoClosePeriod() *float64 { return v.AutoClosePeriod }

// GetAutoCloseStateId returns getIntegrationIntegrationTeam.AutoCloseStateId, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationTeam) GetAutoCloseStateId() *string { return v.AutoCloseStateId }

// GetColor returns getIntegrationIntegrationTeam.Color, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationTeam) GetColor() *string { return v.Color }

// GetCreatedAt returns getIntegrationIntegrationTeam.CreatedAt, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationTeam) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetCycleCalenderUrl returns getIntegrationIntegrationTeam.CycleCalenderUrl, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationTeam) GetCycleCalenderUrl() *string { return v.CycleCalenderUrl }

// GetCycleCooldownTime returns getIntegrationIntegrationTeam.CycleCooldownTime, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationTeam) GetCycleCooldownTime() *float64 { return v.CycleCooldownTime }

// GetCycleDuration returns getIntegrationIntegrationTeam.CycleDuration, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationTeam) GetCycleDuration() *float64 { return v.CycleDuration }

// GetCycleIssueAutoAssignCompleted returns getIntegrationIntegrationTeam.CycleIssueAutoAssignCompleted, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationTeam) GetCycleIssueAutoAssignCompleted() *bool {
	return v.CycleIssueAutoAssignCompleted
}

// GetCycleIssueAutoAssignStarted returns getIntegrationIntegrationTeam.CycleIssueAutoAssignStarted, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationTeam) GetCycleIssueAutoAssignStarted() *bool {
	return v.CycleIssueAutoAssignStarted
}

// GetCycleLockToActive returns getIntegrationIntegrationTeam.CycleLockToActive, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationTeam) GetCycleLockToActive() *bool { return v.CycleLockToActive }

// GetCycleStartDay returns getIntegrationIntegrationTeam.CycleStartDay, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationTeam) GetCycleStartDay() *float64 { return v.CycleStartDay }

// GetCyclesEnabled returns getIntegrationIntegrationTeam.CyclesEnabled, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationTeam) GetCyclesEnabled() *bool { return v.CyclesEnabled }

// GetDefaultIssueEstimate returns getIntegrationIntegrationTeam.DefaultIssueEstimate, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationTeam) GetDefaultIssueEstimate() *float64 {
	return v.DefaultIssueEstimate
}

// GetDefaultTemplateForMembersId returns getIntegrationIntegrationTeam.DefaultTemplateForMembersId, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationTeam) GetDefaultTemplateForMembersId() *string {
	return v.DefaultTemplateForMembersId
}

// GetDefaultTemplateForNonMembersId returns getIntegrationIntegrationTeam.DefaultTemplateForNonMembersId, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationTeam) GetDefaultTemplateForNonMembersId() *string {
	return v.DefaultTemplateForNonMembersId
}

// GetDescription returns getIntegrationIntegrationTeam.Description, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationTeam) GetDescription() *string { return v.Description }

// GetGroupIssueHistory returns getIntegrationIntegrationTeam.GroupIssueHistory, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationTeam) GetGroupIssueHistory() *bool { return v.GroupIssueHistory }

// GetIcon returns getIntegrationIntegrationTeam.Icon, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationTeam) GetIcon() *string { return v.Icon }

// GetInviteHash returns getIntegrationIntegrationTeam.InviteHash, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationTeam) GetInviteHash() *string { return v.InviteHash }

// GetIssueEstimationAllowZero returns getIntegrationIntegrationTeam.IssueEstimationAllowZero, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationTeam) GetIssueEstimationAllowZero() *bool {
	return v.IssueEstimationAllowZero
}

// GetIssueEstimationExtended returns getIntegrationIntegrationTeam.IssueEstimationExtended, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationTeam) GetIssueEstimationExtended() *bool {
	return v.IssueEstimationExtended
}

// GetIssueEstimationType returns getIntegrationIntegrationTeam.IssueEstimationType, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationTeam) GetIssueEstimationType() *string {
	return v.IssueEstimationType
}

// GetIssueOrderingNoPriorityFirst returns getIntegrationIntegrationTeam.IssueOrderingNoPriorityFirst, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationTeam) GetIssueOrderingNoPriorityFirst() *bool {
	return v.IssueOrderingNoPriorityFirst
}

// GetIssueSortOrderDefaultToBottom returns getIntegrationIntegrationTeam.IssueSortOrderDefaultToBottom, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationTeam) GetIssueSortOrderDefaultToBottom() *bool {
	return v.IssueSortOrderDefaultToBottom
}

// GetKey returns getIntegrationIntegrationTeam.Key, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationTeam) GetKey() *string { return v.Key }

// GetName returns getIntegrationIntegrationTeam.Name, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationTeam) GetName() *string { return v.Name }

// GetPrivate returns getIntegrationIntegrationTeam.Private, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationTeam) GetPrivate() *bool { return v.Private }

// GetRequirePriorityToLeaveTriage returns getIntegrationIntegrationTeam.RequirePriorityToLeaveTriage, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationTeam) GetRequirePriorityToLeaveTriage() *bool {
	return v.RequirePriorityToLeaveTriage
}

// GetSlackIssueComments returns getIntegrationIntegrationTeam.SlackIssueComments, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationTeam) GetSlackIssueComments() *bool { return v.SlackIssueComments }

// GetSlackIssueStatuses returns getIntegrationIntegrationTeam.SlackIssueStatuses, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationTeam) GetSlackIssueStatuses() *bool { return v.SlackIssueStatuses }

// GetSlackNewIssue returns getIntegrationIntegrationTeam.SlackNewIssue, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationTeam) GetSlackNewIssue() *bool { return v.SlackNewIssue }

// GetTimezone returns getIntegrationIntegrationTeam.Timezone, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationTeam) GetTimezone() *string { return v.Timezone }

// GetTriageEnabled returns getIntegrationIntegrationTeam.TriageEnabled, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationTeam) GetTriageEnabled() *bool { return v.TriageEnabled }

// GetUpcomingCycleCount returns getIntegrationIntegrationTeam.UpcomingCycleCount, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationTeam) GetUpcomingCycleCount() *float64 { return v.UpcomingCycleCount }

// GetUpdatedAt returns getIntegrationIntegrationTeam.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getIntegrationIntegrationTeam) GetUpdatedAt() *time.Time { return v.UpdatedAt }

func (v *getIntegrationIntegrationTeam) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getIntegrationIntegrationTeam
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getIntegrationIntegrationTeam = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIntegrationIntegrationTeam.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIntegrationIntegrationTeam.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIntegrationIntegrationTeam.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetIntegrationIntegrationTeam struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AutoArchivePeriod *float64 `json:"autoArchivePeriod"`

	AutoClosePeriod *float64 `json:"autoClosePeriod"`

	AutoCloseStateId *string `json:"autoCloseStateId"`

	Color *string `json:"color"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CycleCalenderUrl *string `json:"cycleCalenderUrl"`

	CycleCooldownTime *float64 `json:"cycleCooldownTime"`

	CycleDuration *float64 `json:"cycleDuration"`

	CycleIssueAutoAssignCompleted *bool `json:"cycleIssueAutoAssignCompleted"`

	CycleIssueAutoAssignStarted *bool `json:"cycleIssueAutoAssignStarted"`

	CycleLockToActive *bool `json:"cycleLockToActive"`

	CycleStartDay *float64 `json:"cycleStartDay"`

	CyclesEnabled *bool `json:"cyclesEnabled"`

	DefaultIssueEstimate *float64 `json:"defaultIssueEstimate"`

	DefaultTemplateForMembersId *string `json:"defaultTemplateForMembersId"`

	DefaultTemplateForNonMembersId *string `json:"defaultTemplateForNonMembersId"`

	Description *string `json:"description"`

	GroupIssueHistory *bool `json:"groupIssueHistory"`

	Icon *string `json:"icon"`

	InviteHash *string `json:"inviteHash"`

	IssueEstimationAllowZero *bool `json:"issueEstimationAllowZero"`

	IssueEstimationExtended *bool `json:"issueEstimationExtended"`

	IssueEstimationType *string `json:"issueEstimationType"`

	IssueOrderingNoPriorityFirst *bool `json:"issueOrderingNoPriorityFirst"`

	IssueSortOrderDefaultToBottom *bool `json:"issueSortOrderDefaultToBottom"`

	Key *string `json:"key"`

	Name *string `json:"name"`

	Private *bool `json:"private"`

	RequirePriorityToLeaveTriage *bool `json:"requirePriorityToLeaveTriage"`

	SlackIssueComments *bool `json:"slackIssueComments"`

	SlackIssueStatuses *bool `json:"slackIssueStatuses"`

	SlackNewIssue *bool `json:"slackNewIssue"`

	Timezone *string `json:"timezone"`

	TriageEnabled *bool `json:"triageEnabled"`

	UpcomingCycleCount *float64 `json:"upcomingCycleCount"`

	UpdatedAt json.RawMessage `json:"updatedAt"`
}

func (v *getIntegrationIntegrationTeam) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getIntegrationIntegrationTeam) __premarshalJSON() (*__premarshalgetIntegrationIntegrationTeam, error) {
	var retval __premarshalgetIntegrationIntegrationTeam

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIntegrationIntegrationTeam.ArchivedAt: %w", err)
			}
		}
	}
	retval.AutoArchivePeriod = v.AutoArchivePeriod
	retval.AutoClosePeriod = v.AutoClosePeriod
	retval.AutoCloseStateId = v.AutoCloseStateId
	retval.Color = v.Color
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIntegrationIntegrationTeam.CreatedAt: %w", err)
			}
		}
	}
	retval.CycleCalenderUrl = v.CycleCalenderUrl
	retval.CycleCooldownTime = v.CycleCooldownTime
	retval.CycleDuration = v.CycleDuration
	retval.CycleIssueAutoAssignCompleted = v.CycleIssueAutoAssignCompleted
	retval.CycleIssueAutoAssignStarted = v.CycleIssueAutoAssignStarted
	retval.CycleLockToActive = v.CycleLockToActive
	retval.CycleStartDay = v.CycleStartDay
	retval.CyclesEnabled = v.CyclesEnabled
	retval.DefaultIssueEstimate = v.DefaultIssueEstimate
	retval.DefaultTemplateForMembersId = v.DefaultTemplateForMembersId
	retval.DefaultTemplateForNonMembersId = v.DefaultTemplateForNonMembersId
	retval.Description = v.Description
	retval.GroupIssueHistory = v.GroupIssueHistory
	retval.Icon = v.Icon
	retval.InviteHash = v.InviteHash
	retval.IssueEstimationAllowZero = v.IssueEstimationAllowZero
	retval.IssueEstimationExtended = v.IssueEstimationExtended
	retval.IssueEstimationType = v.IssueEstimationType
	retval.IssueOrderingNoPriorityFirst = v.IssueOrderingNoPriorityFirst
	retval.IssueSortOrderDefaultToBottom = v.IssueSortOrderDefaultToBottom
	retval.Key = v.Key
	retval.Name = v.Name
	retval.Private = v.Private
	retval.RequirePriorityToLeaveTriage = v.RequirePriorityToLeaveTriage
	retval.SlackIssueComments = v.SlackIssueComments
	retval.SlackIssueStatuses = v.SlackIssueStatuses
	retval.SlackNewIssue = v.SlackNewIssue
	retval.Timezone = v.Timezone
	retval.TriageEnabled = v.TriageEnabled
	retval.UpcomingCycleCount = v.UpcomingCycleCount
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIntegrationIntegrationTeam.UpdatedAt: %w", err)
			}
		}
	}
	return &retval, nil
}

// getIntegrationResponse is returned by getIntegration on success.
type getIntegrationResponse struct {
	// One specific integration.
	Integration *getIntegrationIntegration `json:"integration"`
}

// GetIntegration returns getIntegrationResponse.Integration, and is useful for accessing the field via an interface.
func (v *getIntegrationResponse) GetIntegration() *getIntegrationIntegration { return v.Integration }

// getIssueIdsIssueLabel includes the requested fields of the GraphQL type IssueLabel.
// The GraphQL type's documentation follows.
//
// Labels that can be associated with issues.
type getIssueIdsIssueLabel struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// Issues associated with the label.
	Issues *getIssueIdsIssueLabelIssuesIssueConnection `json:"issues"`
}

// GetId returns getIssueIdsIssueLabel.Id, and is useful for accessing the field via an interface.
func (v *getIssueIdsIssueLabel) GetId() *string { return v.Id }

// GetIssues returns getIssueIdsIssueLabel.Issues, and is useful for accessing the field via an interface.
func (v *getIssueIdsIssueLabel) GetIssues() *getIssueIdsIssueLabelIssuesIssueConnection {
	return v.Issues
}

// getIssueIdsIssueLabelIssuesIssueConnection includes the requested fields of the GraphQL type IssueConnection.
type getIssueIdsIssueLabelIssuesIssueConnection struct {
	PageInfo *getIssueIdsIssueLabelIssuesIssueConnectionPageInfo     `json:"pageInfo"`
	Nodes    []*getIssueIdsIssueLabelIssuesIssueConnectionNodesIssue `json:"nodes"`
}

// GetPageInfo returns getIssueIdsIssueLabelIssuesIssueConnection.PageInfo, and is useful for accessing the field via an interface.
func (v *getIssueIdsIssueLabelIssuesIssueConnection) GetPageInfo() *getIssueIdsIssueLabelIssuesIssueConnectionPageInfo {
	return v.PageInfo
}

// GetNodes returns getIssueIdsIssueLabelIssuesIssueConnection.Nodes, and is useful for accessing the field via an interface.
func (v *getIssueIdsIssueLabelIssuesIssueConnection) GetNodes() []*getIssueIdsIssueLabelIssuesIssueConnectionNodesIssue {
	return v.Nodes
}

// getIssueIdsIssueLabelIssuesIssueConnectionNodesIssue includes the requested fields of the GraphQL type Issue.
// The GraphQL type's documentation follows.
//
// An issue.
type getIssueIdsIssueLabelIssuesIssueConnectionNodesIssue struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
}

// GetId returns getIssueIdsIssueLabelIssuesIssueConnectionNodesIssue.Id, and is useful for accessing the field via an interface.
func (v *getIssueIdsIssueLabelIssuesIssueConnectionNodesIssue) GetId() *string { return v.Id }

// getIssueIdsIssueLabelIssuesIssueConnectionPageInfo includes the requested fields of the GraphQL type PageInfo.
type getIssueIdsIssueLabelIssuesIssueConnectionPageInfo struct {
	// Indicates if there are more results when paginating forward.
	HasNextPage *bool `json:"hasNextPage"`
	// Cursor representing the last result in the paginated results.
	EndCursor *string `json:"endCursor"`
}

// GetHasNextPage returns getIssueIdsIssueLabelIssuesIssueConnectionPageInfo.HasNextPage, and is useful for accessing the field via an interface.
func (v *getIssueIdsIssueLabelIssuesIssueConnectionPageInfo) GetHasNextPage() *bool {
	return v.HasNextPage
}

// GetEndCursor returns getIssueIdsIssueLabelIssuesIssueConnectionPageInfo.EndCursor, and is useful for accessing the field via an interface.
func (v *getIssueIdsIssueLabelIssuesIssueConnectionPageInfo) GetEndCursor() *string {
	return v.EndCursor
}

// getIssueIdsResponse is returned by getIssueIds on success.
type getIssueIdsResponse struct {
	// One specific label.
	IssueLabel *getIssueIdsIssueLabel `json:"issueLabel"`
}

// GetIssueLabel returns getIssueIdsResponse.IssueLabel, and is useful for accessing the field via an interface.
func (v *getIssueIdsResponse) GetIssueLabel() *getIssueIdsIssueLabel { return v.IssueLabel }

// getIssueIssue includes the requested fields of the GraphQL type Issue.
// The GraphQL type's documentation follows.
//
// An issue.
type getIssueIssue struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The issue's unique number.
	Number *float64 `json:"number"`
	// The issue's title.
	Title *string `json:"title"`
	// The issue's description in markdown format.
	Description *string `json:"description"`
	// The priority of the issue. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low.
	Priority *float64 `json:"priority"`
	// The estimate of the complexity of the issue..
	Estimate *float64 `json:"estimate"`
	// The order of the item in relation to other items in the organization.
	SortOrder *float64 `json:"sortOrder"`
	// The time at which the issue was moved into started state.
	StartedAt *time.Time `json:"-"`
	// The time at which the issue was moved into completed state.
	CompletedAt *time.Time `json:"-"`
	// The time at which the issue was moved into canceled state.
	CanceledAt *time.Time `json:"-"`
	// The time at which the issue was automatically closed by the auto pruning process.
	AutoClosedAt *time.Time `json:"-"`
	// The time at which the issue was automatically archived by the auto pruning process.
	AutoArchivedAt *time.Time `json:"-"`
	// The date at which the issue is due.
	DueDate *time.Time `json:"-"`
	// A flag that indicates whether the issue is in the trash bin.
	Trashed *bool `json:"trashed"`
	// The time until an issue will be snoozed in Triage view.
	SnoozedUntilAt *time.Time `json:"-"`
	// Previous identifiers of the issue if it has been moved between teams.
	PreviousIdentifiers []*string `json:"previousIdentifiers"`
	// The order of the item in the sub-issue list. Only set if the issue has a parent.
	SubIssueSortOrder *float64 `json:"subIssueSortOrder"`
	// Label for the priority.
	PriorityLabel *string `json:"priorityLabel"`
	// Issue's human readable identifier (e.g. ENG-123).
	Identifier *string `json:"identifier"`
	// Issue URL.
	Url *string `json:"url"`
	// Suggested branch name for the issue.
	BranchName *string `json:"branchName"`
	// Returns the number of Attachment resources which are created by customer support ticketing systems (e.g. Zendesk).
	CustomerTicketCount *int `json:"customerTicketCount"`
	// The team that the issue is associated with.
	Team *getIssueIssueTeam `json:"team"`
	// The cycle that the issue is associated with.
	Cycle *getIssueIssueCycle `json:"cycle"`
	// The project that the issue is associated with.
	Project *getIssueIssueProject `json:"project"`
	// The user who created the issue.
	Creator *getIssueIssueCreatorUser `json:"creator"`
	// The user to whom the issue is assigned to.
	Assignee *getIssueIssueAssigneeUser `json:"assignee"`
	// The user who snoozed the issue.
	SnoozedBy *getIssueIssueSnoozedByUser `json:"snoozedBy"`
	// The workflow state that the issue is associated with.
	State *getIssueIssueStateWorkflowState `json:"state"`
	// The parent of the issue.
	Parent *getIssueIssueParentIssue `json:"parent"`
	// The projectMilestone that the issue is associated with.
	ProjectMilestone *getIssueIssueProjectMilestone `json:"projectMilestone"`
}

// GetId returns getIssueIssue.Id, and is useful for accessing the field via an interface.
func (v *getIssueIssue) GetId() *string { return v.Id }

// GetCreatedAt returns getIssueIssue.CreatedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssue) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetUpdatedAt returns getIssueIssue.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssue) GetUpdatedAt() *time.Time { return v.UpdatedAt }

// GetArchivedAt returns getIssueIssue.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssue) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetNumber returns getIssueIssue.Number, and is useful for accessing the field via an interface.
func (v *getIssueIssue) GetNumber() *float64 { return v.Number }

// GetTitle returns getIssueIssue.Title, and is useful for accessing the field via an interface.
func (v *getIssueIssue) GetTitle() *string { return v.Title }

// GetDescription returns getIssueIssue.Description, and is useful for accessing the field via an interface.
func (v *getIssueIssue) GetDescription() *string { return v.Description }

// GetPriority returns getIssueIssue.Priority, and is useful for accessing the field via an interface.
func (v *getIssueIssue) GetPriority() *float64 { return v.Priority }

// GetEstimate returns getIssueIssue.Estimate, and is useful for accessing the field via an interface.
func (v *getIssueIssue) GetEstimate() *float64 { return v.Estimate }

// GetSortOrder returns getIssueIssue.SortOrder, and is useful for accessing the field via an interface.
func (v *getIssueIssue) GetSortOrder() *float64 { return v.SortOrder }

// GetStartedAt returns getIssueIssue.StartedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssue) GetStartedAt() *time.Time { return v.StartedAt }

// GetCompletedAt returns getIssueIssue.CompletedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssue) GetCompletedAt() *time.Time { return v.CompletedAt }

// GetCanceledAt returns getIssueIssue.CanceledAt, and is useful for accessing the field via an interface.
func (v *getIssueIssue) GetCanceledAt() *time.Time { return v.CanceledAt }

// GetAutoClosedAt returns getIssueIssue.AutoClosedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssue) GetAutoClosedAt() *time.Time { return v.AutoClosedAt }

// GetAutoArchivedAt returns getIssueIssue.AutoArchivedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssue) GetAutoArchivedAt() *time.Time { return v.AutoArchivedAt }

// GetDueDate returns getIssueIssue.DueDate, and is useful for accessing the field via an interface.
func (v *getIssueIssue) GetDueDate() *time.Time { return v.DueDate }

// GetTrashed returns getIssueIssue.Trashed, and is useful for accessing the field via an interface.
func (v *getIssueIssue) GetTrashed() *bool { return v.Trashed }

// GetSnoozedUntilAt returns getIssueIssue.SnoozedUntilAt, and is useful for accessing the field via an interface.
func (v *getIssueIssue) GetSnoozedUntilAt() *time.Time { return v.SnoozedUntilAt }

// GetPreviousIdentifiers returns getIssueIssue.PreviousIdentifiers, and is useful for accessing the field via an interface.
func (v *getIssueIssue) GetPreviousIdentifiers() []*string { return v.PreviousIdentifiers }

// GetSubIssueSortOrder returns getIssueIssue.SubIssueSortOrder, and is useful for accessing the field via an interface.
func (v *getIssueIssue) GetSubIssueSortOrder() *float64 { return v.SubIssueSortOrder }

// GetPriorityLabel returns getIssueIssue.PriorityLabel, and is useful for accessing the field via an interface.
func (v *getIssueIssue) GetPriorityLabel() *string { return v.PriorityLabel }

// GetIdentifier returns getIssueIssue.Identifier, and is useful for accessing the field via an interface.
func (v *getIssueIssue) GetIdentifier() *string { return v.Identifier }

// GetUrl returns getIssueIssue.Url, and is useful for accessing the field via an interface.
func (v *getIssueIssue) GetUrl() *string { return v.Url }

// GetBranchName returns getIssueIssue.BranchName, and is useful for accessing the field via an interface.
func (v *getIssueIssue) GetBranchName() *string { return v.BranchName }

// GetCustomerTicketCount returns getIssueIssue.CustomerTicketCount, and is useful for accessing the field via an interface.
func (v *getIssueIssue) GetCustomerTicketCount() *int { return v.CustomerTicketCount }

// GetTeam returns getIssueIssue.Team, and is useful for accessing the field via an interface.
func (v *getIssueIssue) GetTeam() *getIssueIssueTeam { return v.Team }

// GetCycle returns getIssueIssue.Cycle, and is useful for accessing the field via an interface.
func (v *getIssueIssue) GetCycle() *getIssueIssueCycle { return v.Cycle }

// GetProject returns getIssueIssue.Project, and is useful for accessing the field via an interface.
func (v *getIssueIssue) GetProject() *getIssueIssueProject { return v.Project }

// GetCreator returns getIssueIssue.Creator, and is useful for accessing the field via an interface.
func (v *getIssueIssue) GetCreator() *getIssueIssueCreatorUser { return v.Creator }

// GetAssignee returns getIssueIssue.Assignee, and is useful for accessing the field via an interface.
func (v *getIssueIssue) GetAssignee() *getIssueIssueAssigneeUser { return v.Assignee }

// GetSnoozedBy returns getIssueIssue.SnoozedBy, and is useful for accessing the field via an interface.
func (v *getIssueIssue) GetSnoozedBy() *getIssueIssueSnoozedByUser { return v.SnoozedBy }

// GetState returns getIssueIssue.State, and is useful for accessing the field via an interface.
func (v *getIssueIssue) GetState() *getIssueIssueStateWorkflowState { return v.State }

// GetParent returns getIssueIssue.Parent, and is useful for accessing the field via an interface.
func (v *getIssueIssue) GetParent() *getIssueIssueParentIssue { return v.Parent }

// GetProjectMilestone returns getIssueIssue.ProjectMilestone, and is useful for accessing the field via an interface.
func (v *getIssueIssue) GetProjectMilestone() *getIssueIssueProjectMilestone {
	return v.ProjectMilestone
}

func (v *getIssueIssue) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getIssueIssue
		CreatedAt      json.RawMessage `json:"createdAt"`
		UpdatedAt      json.RawMessage `json:"updatedAt"`
		ArchivedAt     json.RawMessage `json:"archivedAt"`
		StartedAt      json.RawMessage `json:"startedAt"`
		CompletedAt    json.RawMessage `json:"completedAt"`
		CanceledAt     json.RawMessage `json:"canceledAt"`
		AutoClosedAt   json.RawMessage `json:"autoClosedAt"`
		AutoArchivedAt json.RawMessage `json:"autoArchivedAt"`
		DueDate        json.RawMessage `json:"dueDate"`
		SnoozedUntilAt json.RawMessage `json:"snoozedUntilAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getIssueIssue = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssue.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssue.UpdatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssue.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.StartedAt
		src := firstPass.StartedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssue.StartedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CompletedAt
		src := firstPass.CompletedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssue.CompletedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CanceledAt
		src := firstPass.CanceledAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssue.CanceledAt: %w", err)
			}
		}
	}

	{
		dst := &v.AutoClosedAt
		src := firstPass.AutoClosedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssue.AutoClosedAt: %w", err)
			}
		}
	}

	{
		dst := &v.AutoArchivedAt
		src := firstPass.AutoArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssue.AutoArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.DueDate
		src := firstPass.DueDate
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssue.DueDate: %w", err)
			}
		}
	}

	{
		dst := &v.SnoozedUntilAt
		src := firstPass.SnoozedUntilAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssue.SnoozedUntilAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetIssueIssue struct {
	Id *string `json:"id"`

	CreatedAt json.RawMessage `json:"createdAt"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	Number *float64 `json:"number"`

	Title *string `json:"title"`

	Description *string `json:"description"`

	Priority *float64 `json:"priority"`

	Estimate *float64 `json:"estimate"`

	SortOrder *float64 `json:"sortOrder"`

	StartedAt json.RawMessage `json:"startedAt"`

	CompletedAt json.RawMessage `json:"completedAt"`

	CanceledAt json.RawMessage `json:"canceledAt"`

	AutoClosedAt json.RawMessage `json:"autoClosedAt"`

	AutoArchivedAt json.RawMessage `json:"autoArchivedAt"`

	DueDate json.RawMessage `json:"dueDate"`

	Trashed *bool `json:"trashed"`

	SnoozedUntilAt json.RawMessage `json:"snoozedUntilAt"`

	PreviousIdentifiers []*string `json:"previousIdentifiers"`

	SubIssueSortOrder *float64 `json:"subIssueSortOrder"`

	PriorityLabel *string `json:"priorityLabel"`

	Identifier *string `json:"identifier"`

	Url *string `json:"url"`

	BranchName *string `json:"branchName"`

	CustomerTicketCount *int `json:"customerTicketCount"`

	Team *getIssueIssueTeam `json:"team"`

	Cycle *getIssueIssueCycle `json:"cycle"`

	Project *getIssueIssueProject `json:"project"`

	Creator *getIssueIssueCreatorUser `json:"creator"`

	Assignee *getIssueIssueAssigneeUser `json:"assignee"`

	SnoozedBy *getIssueIssueSnoozedByUser `json:"snoozedBy"`

	State *getIssueIssueStateWorkflowState `json:"state"`

	Parent *getIssueIssueParentIssue `json:"parent"`

	ProjectMilestone *getIssueIssueProjectMilestone `json:"projectMilestone"`
}

func (v *getIssueIssue) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getIssueIssue) __premarshalJSON() (*__premarshalgetIssueIssue, error) {
	var retval __premarshalgetIssueIssue

	retval.Id = v.Id
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssue.CreatedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssue.UpdatedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssue.ArchivedAt: %w", err)
			}
		}
	}
	retval.Number = v.Number
	retval.Title = v.Title
	retval.Description = v.Description
	retval.Priority = v.Priority
	retval.Estimate = v.Estimate
	retval.SortOrder = v.SortOrder
	{

		dst := &retval.StartedAt
		src := v.StartedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssue.StartedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CompletedAt
		src := v.CompletedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssue.CompletedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CanceledAt
		src := v.CanceledAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssue.CanceledAt: %w", err)
			}
		}
	}
	{

		dst := &retval.AutoClosedAt
		src := v.AutoClosedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssue.AutoClosedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.AutoArchivedAt
		src := v.AutoArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssue.AutoArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.DueDate
		src := v.DueDate
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssue.DueDate: %w", err)
			}
		}
	}
	retval.Trashed = v.Trashed
	{

		dst := &retval.SnoozedUntilAt
		src := v.SnoozedUntilAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssue.SnoozedUntilAt: %w", err)
			}
		}
	}
	retval.PreviousIdentifiers = v.PreviousIdentifiers
	retval.SubIssueSortOrder = v.SubIssueSortOrder
	retval.PriorityLabel = v.PriorityLabel
	retval.Identifier = v.Identifier
	retval.Url = v.Url
	retval.BranchName = v.BranchName
	retval.CustomerTicketCount = v.CustomerTicketCount
	retval.Team = v.Team
	retval.Cycle = v.Cycle
	retval.Project = v.Project
	retval.Creator = v.Creator
	retval.Assignee = v.Assignee
	retval.SnoozedBy = v.SnoozedBy
	retval.State = v.State
	retval.Parent = v.Parent
	retval.ProjectMilestone = v.ProjectMilestone
	return &retval, nil
}

// getIssueIssueAssigneeUser includes the requested fields of the GraphQL type User.
// The GraphQL type's documentation follows.
//
// A user that has access to the the resources of an organization.
type getIssueIssueAssigneeUser struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// Whether the user account is active or disabled (suspended).
	Active *bool `json:"active"`
	// Whether the user is an organization administrator.
	Admin *bool `json:"admin"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// An URL to the user's avatar image.
	AvatarUrl *string `json:"avatarUrl"`
	// [DEPRECATED] Hash for the user to be used in calendar URLs.
	CalendarHash *string `json:"calendarHash"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Number of issues created.
	CreatedIssueCount *int `json:"createdIssueCount"`
	// A short description of the user, either its title or bio.
	Description *string `json:"description"`
	// Reason why is the account disabled.
	DisableReason *string `json:"disableReason"`
	// The user's display (nick) name. Unique within each organization.
	DisplayName *string `json:"displayName"`
	// The user's email address.
	Email *string `json:"email"`
	// Whether the user is a guest in the workspace and limited to accessing a subset of teams.
	Guest *bool `json:"guest"`
	// Unique hash for the user to be used in invite URLs.
	InviteHash *string `json:"inviteHash"`
	// Whether the user is the currently authenticated user.
	IsMe *bool `json:"isMe"`
	// The last time the user was seen online. If null, the user is currently online.
	LastSeen *time.Time `json:"-"`
	// The user's full name.
	Name *string `json:"name"`
	// The emoji to represent the user current status.
	StatusEmoji *string `json:"statusEmoji"`
	// The label of the user current status.
	StatusLabel *string `json:"statusLabel"`
	// A date at which the user current status should be cleared.
	StatusUntilAt *time.Time `json:"-"`
	// The local timezone of the user.
	Timezone *string `json:"timezone"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// User's profile URL.
	Url *string `json:"url"`
}

// GetId returns getIssueIssueAssigneeUser.Id, and is useful for accessing the field via an interface.
func (v *getIssueIssueAssigneeUser) GetId() *string { return v.Id }

// GetActive returns getIssueIssueAssigneeUser.Active, and is useful for accessing the field via an interface.
func (v *getIssueIssueAssigneeUser) GetActive() *bool { return v.Active }

// GetAdmin returns getIssueIssueAssigneeUser.Admin, and is useful for accessing the field via an interface.
func (v *getIssueIssueAssigneeUser) GetAdmin() *bool { return v.Admin }

// GetArchivedAt returns getIssueIssueAssigneeUser.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueAssigneeUser) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetAvatarUrl returns getIssueIssueAssigneeUser.AvatarUrl, and is useful for accessing the field via an interface.
func (v *getIssueIssueAssigneeUser) GetAvatarUrl() *string { return v.AvatarUrl }

// GetCalendarHash returns getIssueIssueAssigneeUser.CalendarHash, and is useful for accessing the field via an interface.
func (v *getIssueIssueAssigneeUser) GetCalendarHash() *string { return v.CalendarHash }

// GetCreatedAt returns getIssueIssueAssigneeUser.CreatedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueAssigneeUser) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetCreatedIssueCount returns getIssueIssueAssigneeUser.CreatedIssueCount, and is useful for accessing the field via an interface.
func (v *getIssueIssueAssigneeUser) GetCreatedIssueCount() *int { return v.CreatedIssueCount }

// GetDescription returns getIssueIssueAssigneeUser.Description, and is useful for accessing the field via an interface.
func (v *getIssueIssueAssigneeUser) GetDescription() *string { return v.Description }

// GetDisableReason returns getIssueIssueAssigneeUser.DisableReason, and is useful for accessing the field via an interface.
func (v *getIssueIssueAssigneeUser) GetDisableReason() *string { return v.DisableReason }

// GetDisplayName returns getIssueIssueAssigneeUser.DisplayName, and is useful for accessing the field via an interface.
func (v *getIssueIssueAssigneeUser) GetDisplayName() *string { return v.DisplayName }

// GetEmail returns getIssueIssueAssigneeUser.Email, and is useful for accessing the field via an interface.
func (v *getIssueIssueAssigneeUser) GetEmail() *string { return v.Email }

// GetGuest returns getIssueIssueAssigneeUser.Guest, and is useful for accessing the field via an interface.
func (v *getIssueIssueAssigneeUser) GetGuest() *bool { return v.Guest }

// GetInviteHash returns getIssueIssueAssigneeUser.InviteHash, and is useful for accessing the field via an interface.
func (v *getIssueIssueAssigneeUser) GetInviteHash() *string { return v.InviteHash }

// GetIsMe returns getIssueIssueAssigneeUser.IsMe, and is useful for accessing the field via an interface.
func (v *getIssueIssueAssigneeUser) GetIsMe() *bool { return v.IsMe }

// GetLastSeen returns getIssueIssueAssigneeUser.LastSeen, and is useful for accessing the field via an interface.
func (v *getIssueIssueAssigneeUser) GetLastSeen() *time.Time { return v.LastSeen }

// GetName returns getIssueIssueAssigneeUser.Name, and is useful for accessing the field via an interface.
func (v *getIssueIssueAssigneeUser) GetName() *string { return v.Name }

// GetStatusEmoji returns getIssueIssueAssigneeUser.StatusEmoji, and is useful for accessing the field via an interface.
func (v *getIssueIssueAssigneeUser) GetStatusEmoji() *string { return v.StatusEmoji }

// GetStatusLabel returns getIssueIssueAssigneeUser.StatusLabel, and is useful for accessing the field via an interface.
func (v *getIssueIssueAssigneeUser) GetStatusLabel() *string { return v.StatusLabel }

// GetStatusUntilAt returns getIssueIssueAssigneeUser.StatusUntilAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueAssigneeUser) GetStatusUntilAt() *time.Time { return v.StatusUntilAt }

// GetTimezone returns getIssueIssueAssigneeUser.Timezone, and is useful for accessing the field via an interface.
func (v *getIssueIssueAssigneeUser) GetTimezone() *string { return v.Timezone }

// GetUpdatedAt returns getIssueIssueAssigneeUser.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueAssigneeUser) GetUpdatedAt() *time.Time { return v.UpdatedAt }

// GetUrl returns getIssueIssueAssigneeUser.Url, and is useful for accessing the field via an interface.
func (v *getIssueIssueAssigneeUser) GetUrl() *string { return v.Url }

func (v *getIssueIssueAssigneeUser) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getIssueIssueAssigneeUser
		ArchivedAt    json.RawMessage `json:"archivedAt"`
		CreatedAt     json.RawMessage `json:"createdAt"`
		LastSeen      json.RawMessage `json:"lastSeen"`
		StatusUntilAt json.RawMessage `json:"statusUntilAt"`
		UpdatedAt     json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getIssueIssueAssigneeUser = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueAssigneeUser.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueAssigneeUser.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.LastSeen
		src := firstPass.LastSeen
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueAssigneeUser.LastSeen: %w", err)
			}
		}
	}

	{
		dst := &v.StatusUntilAt
		src := firstPass.StatusUntilAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueAssigneeUser.StatusUntilAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueAssigneeUser.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetIssueIssueAssigneeUser struct {
	Id *string `json:"id"`

	Active *bool `json:"active"`

	Admin *bool `json:"admin"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AvatarUrl *string `json:"avatarUrl"`

	CalendarHash *string `json:"calendarHash"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CreatedIssueCount *int `json:"createdIssueCount"`

	Description *string `json:"description"`

	DisableReason *string `json:"disableReason"`

	DisplayName *string `json:"displayName"`

	Email *string `json:"email"`

	Guest *bool `json:"guest"`

	InviteHash *string `json:"inviteHash"`

	IsMe *bool `json:"isMe"`

	LastSeen json.RawMessage `json:"lastSeen"`

	Name *string `json:"name"`

	StatusEmoji *string `json:"statusEmoji"`

	StatusLabel *string `json:"statusLabel"`

	StatusUntilAt json.RawMessage `json:"statusUntilAt"`

	Timezone *string `json:"timezone"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	Url *string `json:"url"`
}

func (v *getIssueIssueAssigneeUser) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getIssueIssueAssigneeUser) __premarshalJSON() (*__premarshalgetIssueIssueAssigneeUser, error) {
	var retval __premarshalgetIssueIssueAssigneeUser

	retval.Id = v.Id
	retval.Active = v.Active
	retval.Admin = v.Admin
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueAssigneeUser.ArchivedAt: %w", err)
			}
		}
	}
	retval.AvatarUrl = v.AvatarUrl
	retval.CalendarHash = v.CalendarHash
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueAssigneeUser.CreatedAt: %w", err)
			}
		}
	}
	retval.CreatedIssueCount = v.CreatedIssueCount
	retval.Description = v.Description
	retval.DisableReason = v.DisableReason
	retval.DisplayName = v.DisplayName
	retval.Email = v.Email
	retval.Guest = v.Guest
	retval.InviteHash = v.InviteHash
	retval.IsMe = v.IsMe
	{

		dst := &retval.LastSeen
		src := v.LastSeen
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueAssigneeUser.LastSeen: %w", err)
			}
		}
	}
	retval.Name = v.Name
	retval.StatusEmoji = v.StatusEmoji
	retval.StatusLabel = v.StatusLabel
	{

		dst := &retval.StatusUntilAt
		src := v.StatusUntilAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueAssigneeUser.StatusUntilAt: %w", err)
			}
		}
	}
	retval.Timezone = v.Timezone
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueAssigneeUser.UpdatedAt: %w", err)
			}
		}
	}
	retval.Url = v.Url
	return &retval, nil
}

// getIssueIssueCreatorUser includes the requested fields of the GraphQL type User.
// The GraphQL type's documentation follows.
//
// A user that has access to the the resources of an organization.
type getIssueIssueCreatorUser struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// Whether the user account is active or disabled (suspended).
	Active *bool `json:"active"`
	// Whether the user is an organization administrator.
	Admin *bool `json:"admin"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// An URL to the user's avatar image.
	AvatarUrl *string `json:"avatarUrl"`
	// [DEPRECATED] Hash for the user to be used in calendar URLs.
	CalendarHash *string `json:"calendarHash"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Number of issues created.
	CreatedIssueCount *int `json:"createdIssueCount"`
	// A short description of the user, either its title or bio.
	Description *string `json:"description"`
	// Reason why is the account disabled.
	DisableReason *string `json:"disableReason"`
	// The user's display (nick) name. Unique within each organization.
	DisplayName *string `json:"displayName"`
	// The user's email address.
	Email *string `json:"email"`
	// Whether the user is a guest in the workspace and limited to accessing a subset of teams.
	Guest *bool `json:"guest"`
	// Unique hash for the user to be used in invite URLs.
	InviteHash *string `json:"inviteHash"`
	// Whether the user is the currently authenticated user.
	IsMe *bool `json:"isMe"`
	// The last time the user was seen online. If null, the user is currently online.
	LastSeen *time.Time `json:"-"`
	// The user's full name.
	Name *string `json:"name"`
	// The emoji to represent the user current status.
	StatusEmoji *string `json:"statusEmoji"`
	// The label of the user current status.
	StatusLabel *string `json:"statusLabel"`
	// A date at which the user current status should be cleared.
	StatusUntilAt *time.Time `json:"-"`
	// The local timezone of the user.
	Timezone *string `json:"timezone"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// User's profile URL.
	Url *string `json:"url"`
}

// GetId returns getIssueIssueCreatorUser.Id, and is useful for accessing the field via an interface.
func (v *getIssueIssueCreatorUser) GetId() *string { return v.Id }

// GetActive returns getIssueIssueCreatorUser.Active, and is useful for accessing the field via an interface.
func (v *getIssueIssueCreatorUser) GetActive() *bool { return v.Active }

// GetAdmin returns getIssueIssueCreatorUser.Admin, and is useful for accessing the field via an interface.
func (v *getIssueIssueCreatorUser) GetAdmin() *bool { return v.Admin }

// GetArchivedAt returns getIssueIssueCreatorUser.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueCreatorUser) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetAvatarUrl returns getIssueIssueCreatorUser.AvatarUrl, and is useful for accessing the field via an interface.
func (v *getIssueIssueCreatorUser) GetAvatarUrl() *string { return v.AvatarUrl }

// GetCalendarHash returns getIssueIssueCreatorUser.CalendarHash, and is useful for accessing the field via an interface.
func (v *getIssueIssueCreatorUser) GetCalendarHash() *string { return v.CalendarHash }

// GetCreatedAt returns getIssueIssueCreatorUser.CreatedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueCreatorUser) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetCreatedIssueCount returns getIssueIssueCreatorUser.CreatedIssueCount, and is useful for accessing the field via an interface.
func (v *getIssueIssueCreatorUser) GetCreatedIssueCount() *int { return v.CreatedIssueCount }

// GetDescription returns getIssueIssueCreatorUser.Description, and is useful for accessing the field via an interface.
func (v *getIssueIssueCreatorUser) GetDescription() *string { return v.Description }

// GetDisableReason returns getIssueIssueCreatorUser.DisableReason, and is useful for accessing the field via an interface.
func (v *getIssueIssueCreatorUser) GetDisableReason() *string { return v.DisableReason }

// GetDisplayName returns getIssueIssueCreatorUser.DisplayName, and is useful for accessing the field via an interface.
func (v *getIssueIssueCreatorUser) GetDisplayName() *string { return v.DisplayName }

// GetEmail returns getIssueIssueCreatorUser.Email, and is useful for accessing the field via an interface.
func (v *getIssueIssueCreatorUser) GetEmail() *string { return v.Email }

// GetGuest returns getIssueIssueCreatorUser.Guest, and is useful for accessing the field via an interface.
func (v *getIssueIssueCreatorUser) GetGuest() *bool { return v.Guest }

// GetInviteHash returns getIssueIssueCreatorUser.InviteHash, and is useful for accessing the field via an interface.
func (v *getIssueIssueCreatorUser) GetInviteHash() *string { return v.InviteHash }

// GetIsMe returns getIssueIssueCreatorUser.IsMe, and is useful for accessing the field via an interface.
func (v *getIssueIssueCreatorUser) GetIsMe() *bool { return v.IsMe }

// GetLastSeen returns getIssueIssueCreatorUser.LastSeen, and is useful for accessing the field via an interface.
func (v *getIssueIssueCreatorUser) GetLastSeen() *time.Time { return v.LastSeen }

// GetName returns getIssueIssueCreatorUser.Name, and is useful for accessing the field via an interface.
func (v *getIssueIssueCreatorUser) GetName() *string { return v.Name }

// GetStatusEmoji returns getIssueIssueCreatorUser.StatusEmoji, and is useful for accessing the field via an interface.
func (v *getIssueIssueCreatorUser) GetStatusEmoji() *string { return v.StatusEmoji }

// GetStatusLabel returns getIssueIssueCreatorUser.StatusLabel, and is useful for accessing the field via an interface.
func (v *getIssueIssueCreatorUser) GetStatusLabel() *string { return v.StatusLabel }

// GetStatusUntilAt returns getIssueIssueCreatorUser.StatusUntilAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueCreatorUser) GetStatusUntilAt() *time.Time { return v.StatusUntilAt }

// GetTimezone returns getIssueIssueCreatorUser.Timezone, and is useful for accessing the field via an interface.
func (v *getIssueIssueCreatorUser) GetTimezone() *string { return v.Timezone }

// GetUpdatedAt returns getIssueIssueCreatorUser.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueCreatorUser) GetUpdatedAt() *time.Time { return v.UpdatedAt }

// GetUrl returns getIssueIssueCreatorUser.Url, and is useful for accessing the field via an interface.
func (v *getIssueIssueCreatorUser) GetUrl() *string { return v.Url }

func (v *getIssueIssueCreatorUser) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getIssueIssueCreatorUser
		ArchivedAt    json.RawMessage `json:"archivedAt"`
		CreatedAt     json.RawMessage `json:"createdAt"`
		LastSeen      json.RawMessage `json:"lastSeen"`
		StatusUntilAt json.RawMessage `json:"statusUntilAt"`
		UpdatedAt     json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getIssueIssueCreatorUser = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueCreatorUser.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueCreatorUser.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.LastSeen
		src := firstPass.LastSeen
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueCreatorUser.LastSeen: %w", err)
			}
		}
	}

	{
		dst := &v.StatusUntilAt
		src := firstPass.StatusUntilAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueCreatorUser.StatusUntilAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueCreatorUser.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetIssueIssueCreatorUser struct {
	Id *string `json:"id"`

	Active *bool `json:"active"`

	Admin *bool `json:"admin"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AvatarUrl *string `json:"avatarUrl"`

	CalendarHash *string `json:"calendarHash"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CreatedIssueCount *int `json:"createdIssueCount"`

	Description *string `json:"description"`

	DisableReason *string `json:"disableReason"`

	DisplayName *string `json:"displayName"`

	Email *string `json:"email"`

	Guest *bool `json:"guest"`

	InviteHash *string `json:"inviteHash"`

	IsMe *bool `json:"isMe"`

	LastSeen json.RawMessage `json:"lastSeen"`

	Name *string `json:"name"`

	StatusEmoji *string `json:"statusEmoji"`

	StatusLabel *string `json:"statusLabel"`

	StatusUntilAt json.RawMessage `json:"statusUntilAt"`

	Timezone *string `json:"timezone"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	Url *string `json:"url"`
}

func (v *getIssueIssueCreatorUser) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getIssueIssueCreatorUser) __premarshalJSON() (*__premarshalgetIssueIssueCreatorUser, error) {
	var retval __premarshalgetIssueIssueCreatorUser

	retval.Id = v.Id
	retval.Active = v.Active
	retval.Admin = v.Admin
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueCreatorUser.ArchivedAt: %w", err)
			}
		}
	}
	retval.AvatarUrl = v.AvatarUrl
	retval.CalendarHash = v.CalendarHash
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueCreatorUser.CreatedAt: %w", err)
			}
		}
	}
	retval.CreatedIssueCount = v.CreatedIssueCount
	retval.Description = v.Description
	retval.DisableReason = v.DisableReason
	retval.DisplayName = v.DisplayName
	retval.Email = v.Email
	retval.Guest = v.Guest
	retval.InviteHash = v.InviteHash
	retval.IsMe = v.IsMe
	{

		dst := &retval.LastSeen
		src := v.LastSeen
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueCreatorUser.LastSeen: %w", err)
			}
		}
	}
	retval.Name = v.Name
	retval.StatusEmoji = v.StatusEmoji
	retval.StatusLabel = v.StatusLabel
	{

		dst := &retval.StatusUntilAt
		src := v.StatusUntilAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueCreatorUser.StatusUntilAt: %w", err)
			}
		}
	}
	retval.Timezone = v.Timezone
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueCreatorUser.UpdatedAt: %w", err)
			}
		}
	}
	retval.Url = v.Url
	return &retval, nil
}

// getIssueIssueCycle includes the requested fields of the GraphQL type Cycle.
// The GraphQL type's documentation follows.
//
// A set of issues to be resolved in a specified amount of time.
type getIssueIssueCycle struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The time at which the cycle was automatically archived by the auto pruning process.
	AutoArchivedAt *time.Time `json:"-"`
	// The completion time of the cycle. If null, the cycle hasn't been completed.
	CompletedAt *time.Time `json:"-"`
	// The number of completed issues in the cycle after each day.
	CompletedIssueCountHistory []*float64 `json:"completedIssueCountHistory"`
	// The number of completed estimation points after each day.
	CompletedScopeHistory []*float64 `json:"completedScopeHistory"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// The cycle's description.
	Description *string `json:"description"`
	// The end time of the cycle.
	EndsAt *time.Time `json:"-"`
	// The number of in progress estimation points after each day.
	InProgressScopeHistory []*float64 `json:"inProgressScopeHistory"`
	// The total number of issues in the cycle after each day.
	IssueCountHistory []*float64 `json:"issueCountHistory"`
	// The custom name of the cycle.
	Name *string `json:"name"`
	// The number of the cycle.
	Number *float64 `json:"number"`
	// The overall progress of the cycle. This is the (completed estimate points + 0.25 * in progress estimate points) / total estimate points.
	Progress *float64 `json:"progress"`
	// The total number of estimation points after each day.
	ScopeHistory []*float64 `json:"scopeHistory"`
	// The start time of the cycle.
	StartsAt *time.Time `json:"-"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
}

// GetId returns getIssueIssueCycle.Id, and is useful for accessing the field via an interface.
func (v *getIssueIssueCycle) GetId() *string { return v.Id }

// GetArchivedAt returns getIssueIssueCycle.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueCycle) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetAutoArchivedAt returns getIssueIssueCycle.AutoArchivedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueCycle) GetAutoArchivedAt() *time.Time { return v.AutoArchivedAt }

// GetCompletedAt returns getIssueIssueCycle.CompletedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueCycle) GetCompletedAt() *time.Time { return v.CompletedAt }

// GetCompletedIssueCountHistory returns getIssueIssueCycle.CompletedIssueCountHistory, and is useful for accessing the field via an interface.
func (v *getIssueIssueCycle) GetCompletedIssueCountHistory() []*float64 {
	return v.CompletedIssueCountHistory
}

// GetCompletedScopeHistory returns getIssueIssueCycle.CompletedScopeHistory, and is useful for accessing the field via an interface.
func (v *getIssueIssueCycle) GetCompletedScopeHistory() []*float64 { return v.CompletedScopeHistory }

// GetCreatedAt returns getIssueIssueCycle.CreatedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueCycle) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetDescription returns getIssueIssueCycle.Description, and is useful for accessing the field via an interface.
func (v *getIssueIssueCycle) GetDescription() *string { return v.Description }

// GetEndsAt returns getIssueIssueCycle.EndsAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueCycle) GetEndsAt() *time.Time { return v.EndsAt }

// GetInProgressScopeHistory returns getIssueIssueCycle.InProgressScopeHistory, and is useful for accessing the field via an interface.
func (v *getIssueIssueCycle) GetInProgressScopeHistory() []*float64 { return v.InProgressScopeHistory }

// GetIssueCountHistory returns getIssueIssueCycle.IssueCountHistory, and is useful for accessing the field via an interface.
func (v *getIssueIssueCycle) GetIssueCountHistory() []*float64 { return v.IssueCountHistory }

// GetName returns getIssueIssueCycle.Name, and is useful for accessing the field via an interface.
func (v *getIssueIssueCycle) GetName() *string { return v.Name }

// GetNumber returns getIssueIssueCycle.Number, and is useful for accessing the field via an interface.
func (v *getIssueIssueCycle) GetNumber() *float64 { return v.Number }

// GetProgress returns getIssueIssueCycle.Progress, and is useful for accessing the field via an interface.
func (v *getIssueIssueCycle) GetProgress() *float64 { return v.Progress }

// GetScopeHistory returns getIssueIssueCycle.ScopeHistory, and is useful for accessing the field via an interface.
func (v *getIssueIssueCycle) GetScopeHistory() []*float64 { return v.ScopeHistory }

// GetStartsAt returns getIssueIssueCycle.StartsAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueCycle) GetStartsAt() *time.Time { return v.StartsAt }

// GetUpdatedAt returns getIssueIssueCycle.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueCycle) GetUpdatedAt() *time.Time { return v.UpdatedAt }

func (v *getIssueIssueCycle) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getIssueIssueCycle
		ArchivedAt     json.RawMessage `json:"archivedAt"`
		AutoArchivedAt json.RawMessage `json:"autoArchivedAt"`
		CompletedAt    json.RawMessage `json:"completedAt"`
		CreatedAt      json.RawMessage `json:"createdAt"`
		EndsAt         json.RawMessage `json:"endsAt"`
		StartsAt       json.RawMessage `json:"startsAt"`
		UpdatedAt      json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getIssueIssueCycle = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueCycle.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.AutoArchivedAt
		src := firstPass.AutoArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueCycle.AutoArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CompletedAt
		src := firstPass.CompletedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueCycle.CompletedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueCycle.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.EndsAt
		src := firstPass.EndsAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueCycle.EndsAt: %w", err)
			}
		}
	}

	{
		dst := &v.StartsAt
		src := firstPass.StartsAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueCycle.StartsAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueCycle.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetIssueIssueCycle struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AutoArchivedAt json.RawMessage `json:"autoArchivedAt"`

	CompletedAt json.RawMessage `json:"completedAt"`

	CompletedIssueCountHistory []*float64 `json:"completedIssueCountHistory"`

	CompletedScopeHistory []*float64 `json:"completedScopeHistory"`

	CreatedAt json.RawMessage `json:"createdAt"`

	Description *string `json:"description"`

	EndsAt json.RawMessage `json:"endsAt"`

	InProgressScopeHistory []*float64 `json:"inProgressScopeHistory"`

	IssueCountHistory []*float64 `json:"issueCountHistory"`

	Name *string `json:"name"`

	Number *float64 `json:"number"`

	Progress *float64 `json:"progress"`

	ScopeHistory []*float64 `json:"scopeHistory"`

	StartsAt json.RawMessage `json:"startsAt"`

	UpdatedAt json.RawMessage `json:"updatedAt"`
}

func (v *getIssueIssueCycle) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getIssueIssueCycle) __premarshalJSON() (*__premarshalgetIssueIssueCycle, error) {
	var retval __premarshalgetIssueIssueCycle

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueCycle.ArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.AutoArchivedAt
		src := v.AutoArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueCycle.AutoArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CompletedAt
		src := v.CompletedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueCycle.CompletedAt: %w", err)
			}
		}
	}
	retval.CompletedIssueCountHistory = v.CompletedIssueCountHistory
	retval.CompletedScopeHistory = v.CompletedScopeHistory
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueCycle.CreatedAt: %w", err)
			}
		}
	}
	retval.Description = v.Description
	{

		dst := &retval.EndsAt
		src := v.EndsAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueCycle.EndsAt: %w", err)
			}
		}
	}
	retval.InProgressScopeHistory = v.InProgressScopeHistory
	retval.IssueCountHistory = v.IssueCountHistory
	retval.Name = v.Name
	retval.Number = v.Number
	retval.Progress = v.Progress
	retval.ScopeHistory = v.ScopeHistory
	{

		dst := &retval.StartsAt
		src := v.StartsAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueCycle.StartsAt: %w", err)
			}
		}
	}
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueCycle.UpdatedAt: %w", err)
			}
		}
	}
	return &retval, nil
}

// getIssueIssueParentIssue includes the requested fields of the GraphQL type Issue.
// The GraphQL type's documentation follows.
//
// An issue.
type getIssueIssueParentIssue struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The issue's unique number.
	Number *float64 `json:"number"`
	// The issue's title.
	Title *string `json:"title"`
	// The issue's description in markdown format.
	Description *string `json:"description"`
	// The priority of the issue. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low.
	Priority *float64 `json:"priority"`
	// The estimate of the complexity of the issue..
	Estimate *float64 `json:"estimate"`
	// The order of the item in relation to other items in the organization.
	SortOrder *float64 `json:"sortOrder"`
	// The time at which the issue was moved into started state.
	StartedAt *time.Time `json:"-"`
	// The time at which the issue was moved into completed state.
	CompletedAt *time.Time `json:"-"`
	// The time at which the issue was moved into canceled state.
	CanceledAt *time.Time `json:"-"`
	// The time at which the issue was automatically closed by the auto pruning process.
	AutoClosedAt *time.Time `json:"-"`
	// The time at which the issue was automatically archived by the auto pruning process.
	AutoArchivedAt *time.Time `json:"-"`
	// The date at which the issue is due.
	DueDate *time.Time `json:"-"`
	// A flag that indicates whether the issue is in the trash bin.
	Trashed *bool `json:"trashed"`
	// The time until an issue will be snoozed in Triage view.
	SnoozedUntilAt *time.Time `json:"-"`
	// Previous identifiers of the issue if it has been moved between teams.
	PreviousIdentifiers []*string `json:"previousIdentifiers"`
}

// GetId returns getIssueIssueParentIssue.Id, and is useful for accessing the field via an interface.
func (v *getIssueIssueParentIssue) GetId() *string { return v.Id }

// GetCreatedAt returns getIssueIssueParentIssue.CreatedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueParentIssue) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetUpdatedAt returns getIssueIssueParentIssue.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueParentIssue) GetUpdatedAt() *time.Time { return v.UpdatedAt }

// GetArchivedAt returns getIssueIssueParentIssue.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueParentIssue) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetNumber returns getIssueIssueParentIssue.Number, and is useful for accessing the field via an interface.
func (v *getIssueIssueParentIssue) GetNumber() *float64 { return v.Number }

// GetTitle returns getIssueIssueParentIssue.Title, and is useful for accessing the field via an interface.
func (v *getIssueIssueParentIssue) GetTitle() *string { return v.Title }

// GetDescription returns getIssueIssueParentIssue.Description, and is useful for accessing the field via an interface.
func (v *getIssueIssueParentIssue) GetDescription() *string { return v.Description }

// GetPriority returns getIssueIssueParentIssue.Priority, and is useful for accessing the field via an interface.
func (v *getIssueIssueParentIssue) GetPriority() *float64 { return v.Priority }

// GetEstimate returns getIssueIssueParentIssue.Estimate, and is useful for accessing the field via an interface.
func (v *getIssueIssueParentIssue) GetEstimate() *float64 { return v.Estimate }

// GetSortOrder returns getIssueIssueParentIssue.SortOrder, and is useful for accessing the field via an interface.
func (v *getIssueIssueParentIssue) GetSortOrder() *float64 { return v.SortOrder }

// GetStartedAt returns getIssueIssueParentIssue.StartedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueParentIssue) GetStartedAt() *time.Time { return v.StartedAt }

// GetCompletedAt returns getIssueIssueParentIssue.CompletedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueParentIssue) GetCompletedAt() *time.Time { return v.CompletedAt }

// GetCanceledAt returns getIssueIssueParentIssue.CanceledAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueParentIssue) GetCanceledAt() *time.Time { return v.CanceledAt }

// GetAutoClosedAt returns getIssueIssueParentIssue.AutoClosedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueParentIssue) GetAutoClosedAt() *time.Time { return v.AutoClosedAt }

// GetAutoArchivedAt returns getIssueIssueParentIssue.AutoArchivedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueParentIssue) GetAutoArchivedAt() *time.Time { return v.AutoArchivedAt }

// GetDueDate returns getIssueIssueParentIssue.DueDate, and is useful for accessing the field via an interface.
func (v *getIssueIssueParentIssue) GetDueDate() *time.Time { return v.DueDate }

// GetTrashed returns getIssueIssueParentIssue.Trashed, and is useful for accessing the field via an interface.
func (v *getIssueIssueParentIssue) GetTrashed() *bool { return v.Trashed }

// GetSnoozedUntilAt returns getIssueIssueParentIssue.SnoozedUntilAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueParentIssue) GetSnoozedUntilAt() *time.Time { return v.SnoozedUntilAt }

// GetPreviousIdentifiers returns getIssueIssueParentIssue.PreviousIdentifiers, and is useful for accessing the field via an interface.
func (v *getIssueIssueParentIssue) GetPreviousIdentifiers() []*string { return v.PreviousIdentifiers }

func (v *getIssueIssueParentIssue) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getIssueIssueParentIssue
		CreatedAt      json.RawMessage `json:"createdAt"`
		UpdatedAt      json.RawMessage `json:"updatedAt"`
		ArchivedAt     json.RawMessage `json:"archivedAt"`
		StartedAt      json.RawMessage `json:"startedAt"`
		CompletedAt    json.RawMessage `json:"completedAt"`
		CanceledAt     json.RawMessage `json:"canceledAt"`
		AutoClosedAt   json.RawMessage `json:"autoClosedAt"`
		AutoArchivedAt json.RawMessage `json:"autoArchivedAt"`
		DueDate        json.RawMessage `json:"dueDate"`
		SnoozedUntilAt json.RawMessage `json:"snoozedUntilAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getIssueIssueParentIssue = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueParentIssue.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueParentIssue.UpdatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueParentIssue.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.StartedAt
		src := firstPass.StartedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueParentIssue.StartedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CompletedAt
		src := firstPass.CompletedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueParentIssue.CompletedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CanceledAt
		src := firstPass.CanceledAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueParentIssue.CanceledAt: %w", err)
			}
		}
	}

	{
		dst := &v.AutoClosedAt
		src := firstPass.AutoClosedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueParentIssue.AutoClosedAt: %w", err)
			}
		}
	}

	{
		dst := &v.AutoArchivedAt
		src := firstPass.AutoArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueParentIssue.AutoArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.DueDate
		src := firstPass.DueDate
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueParentIssue.DueDate: %w", err)
			}
		}
	}

	{
		dst := &v.SnoozedUntilAt
		src := firstPass.SnoozedUntilAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueParentIssue.SnoozedUntilAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetIssueIssueParentIssue struct {
	Id *string `json:"id"`

	CreatedAt json.RawMessage `json:"createdAt"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	Number *float64 `json:"number"`

	Title *string `json:"title"`

	Description *string `json:"description"`

	Priority *float64 `json:"priority"`

	Estimate *float64 `json:"estimate"`

	SortOrder *float64 `json:"sortOrder"`

	StartedAt json.RawMessage `json:"startedAt"`

	CompletedAt json.RawMessage `json:"completedAt"`

	CanceledAt json.RawMessage `json:"canceledAt"`

	AutoClosedAt json.RawMessage `json:"autoClosedAt"`

	AutoArchivedAt json.RawMessage `json:"autoArchivedAt"`

	DueDate json.RawMessage `json:"dueDate"`

	Trashed *bool `json:"trashed"`

	SnoozedUntilAt json.RawMessage `json:"snoozedUntilAt"`

	PreviousIdentifiers []*string `json:"previousIdentifiers"`
}

func (v *getIssueIssueParentIssue) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getIssueIssueParentIssue) __premarshalJSON() (*__premarshalgetIssueIssueParentIssue, error) {
	var retval __premarshalgetIssueIssueParentIssue

	retval.Id = v.Id
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueParentIssue.CreatedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueParentIssue.UpdatedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueParentIssue.ArchivedAt: %w", err)
			}
		}
	}
	retval.Number = v.Number
	retval.Title = v.Title
	retval.Description = v.Description
	retval.Priority = v.Priority
	retval.Estimate = v.Estimate
	retval.SortOrder = v.SortOrder
	{

		dst := &retval.StartedAt
		src := v.StartedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueParentIssue.StartedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CompletedAt
		src := v.CompletedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueParentIssue.CompletedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CanceledAt
		src := v.CanceledAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueParentIssue.CanceledAt: %w", err)
			}
		}
	}
	{

		dst := &retval.AutoClosedAt
		src := v.AutoClosedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueParentIssue.AutoClosedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.AutoArchivedAt
		src := v.AutoArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueParentIssue.AutoArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.DueDate
		src := v.DueDate
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueParentIssue.DueDate: %w", err)
			}
		}
	}
	retval.Trashed = v.Trashed
	{

		dst := &retval.SnoozedUntilAt
		src := v.SnoozedUntilAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueParentIssue.SnoozedUntilAt: %w", err)
			}
		}
	}
	retval.PreviousIdentifiers = v.PreviousIdentifiers
	return &retval, nil
}

// getIssueIssueProject includes the requested fields of the GraphQL type Project.
// The GraphQL type's documentation follows.
//
// A project.
type getIssueIssueProject struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The time at which the project was automatically archived by the auto pruning process.
	AutoArchivedAt *time.Time `json:"-"`
	// The time at which the project was moved into canceled state.
	CanceledAt *time.Time `json:"-"`
	// The project's color.
	Color *string `json:"color"`
	// The time at which the project was moved into completed state.
	CompletedAt *time.Time `json:"-"`
	// The number of completed issues in the project after each week.
	CompletedIssueCountHistory []*float64 `json:"completedIssueCountHistory"`
	// The number of completed estimation points after each week.
	CompletedScopeHistory []*float64 `json:"completedScopeHistory"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// The project's description.
	Description *string `json:"description"`
	// The icon of the project.
	Icon *string `json:"icon"`
	// The number of in progress estimation points after each week.
	InProgressScopeHistory []*float64 `json:"inProgressScopeHistory"`
	// The total number of issues in the project after each week.
	IssueCountHistory []*float64 `json:"issueCountHistory"`
	// The project's name.
	Name *string `json:"name"`
	// The overall progress of the project. This is the (completed estimate points + 0.25 * in progress estimate points) / total estimate points.
	Progress *float64 `json:"progress"`
	// The time until which project update reminders are paused.
	ProjectUpdateRemindersPausedUntilAt *time.Time `json:"-"`
	// The overall scope (total estimate points) of the project.
	Scope *float64 `json:"scope"`
	// The total number of estimation points after each week.
	ScopeHistory []*float64 `json:"scopeHistory"`
	// Whether to send new issue comment notifications to Slack.
	SlackIssueComments *bool `json:"slackIssueComments"`
	// Whether to send new issue status updates to Slack.
	SlackIssueStatuses *bool `json:"slackIssueStatuses"`
	// Whether to send new issue notifications to Slack.
	SlackNewIssue *bool `json:"slackNewIssue"`
	// The project's unique URL slug.
	SlugId *string `json:"slugId"`
	// The sort order for the project within the organization.
	SortOrder *float64 `json:"sortOrder"`
	// [Internal] The estimated start date of the project.
	StartDate *time.Time `json:"-"`
	// The time at which the project was moved into started state.
	StartedAt *time.Time `json:"-"`
	// The type of the state.
	State *string `json:"state"`
	// The estimated completion date of the project.
	TargetDate *time.Time `json:"-"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// Project URL.
	Url *string `json:"url"`
}

// GetId returns getIssueIssueProject.Id, and is useful for accessing the field via an interface.
func (v *getIssueIssueProject) GetId() *string { return v.Id }

// GetArchivedAt returns getIssueIssueProject.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueProject) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetAutoArchivedAt returns getIssueIssueProject.AutoArchivedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueProject) GetAutoArchivedAt() *time.Time { return v.AutoArchivedAt }

// GetCanceledAt returns getIssueIssueProject.CanceledAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueProject) GetCanceledAt() *time.Time { return v.CanceledAt }

// GetColor returns getIssueIssueProject.Color, and is useful for accessing the field via an interface.
func (v *getIssueIssueProject) GetColor() *string { return v.Color }

// GetCompletedAt returns getIssueIssueProject.CompletedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueProject) GetCompletedAt() *time.Time { return v.CompletedAt }

// GetCompletedIssueCountHistory returns getIssueIssueProject.CompletedIssueCountHistory, and is useful for accessing the field via an interface.
func (v *getIssueIssueProject) GetCompletedIssueCountHistory() []*float64 {
	return v.CompletedIssueCountHistory
}

// GetCompletedScopeHistory returns getIssueIssueProject.CompletedScopeHistory, and is useful for accessing the field via an interface.
func (v *getIssueIssueProject) GetCompletedScopeHistory() []*float64 { return v.CompletedScopeHistory }

// GetCreatedAt returns getIssueIssueProject.CreatedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueProject) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetDescription returns getIssueIssueProject.Description, and is useful for accessing the field via an interface.
func (v *getIssueIssueProject) GetDescription() *string { return v.Description }

// GetIcon returns getIssueIssueProject.Icon, and is useful for accessing the field via an interface.
func (v *getIssueIssueProject) GetIcon() *string { return v.Icon }

// GetInProgressScopeHistory returns getIssueIssueProject.InProgressScopeHistory, and is useful for accessing the field via an interface.
func (v *getIssueIssueProject) GetInProgressScopeHistory() []*float64 {
	return v.InProgressScopeHistory
}

// GetIssueCountHistory returns getIssueIssueProject.IssueCountHistory, and is useful for accessing the field via an interface.
func (v *getIssueIssueProject) GetIssueCountHistory() []*float64 { return v.IssueCountHistory }

// GetName returns getIssueIssueProject.Name, and is useful for accessing the field via an interface.
func (v *getIssueIssueProject) GetName() *string { return v.Name }

// GetProgress returns getIssueIssueProject.Progress, and is useful for accessing the field via an interface.
func (v *getIssueIssueProject) GetProgress() *float64 { return v.Progress }

// GetProjectUpdateRemindersPausedUntilAt returns getIssueIssueProject.ProjectUpdateRemindersPausedUntilAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueProject) GetProjectUpdateRemindersPausedUntilAt() *time.Time {
	return v.ProjectUpdateRemindersPausedUntilAt
}

// GetScope returns getIssueIssueProject.Scope, and is useful for accessing the field via an interface.
func (v *getIssueIssueProject) GetScope() *float64 { return v.Scope }

// GetScopeHistory returns getIssueIssueProject.ScopeHistory, and is useful for accessing the field via an interface.
func (v *getIssueIssueProject) GetScopeHistory() []*float64 { return v.ScopeHistory }

// GetSlackIssueComments returns getIssueIssueProject.SlackIssueComments, and is useful for accessing the field via an interface.
func (v *getIssueIssueProject) GetSlackIssueComments() *bool { return v.SlackIssueComments }

// GetSlackIssueStatuses returns getIssueIssueProject.SlackIssueStatuses, and is useful for accessing the field via an interface.
func (v *getIssueIssueProject) GetSlackIssueStatuses() *bool { return v.SlackIssueStatuses }

// GetSlackNewIssue returns getIssueIssueProject.SlackNewIssue, and is useful for accessing the field via an interface.
func (v *getIssueIssueProject) GetSlackNewIssue() *bool { return v.SlackNewIssue }

// GetSlugId returns getIssueIssueProject.SlugId, and is useful for accessing the field via an interface.
func (v *getIssueIssueProject) GetSlugId() *string { return v.SlugId }

// GetSortOrder returns getIssueIssueProject.SortOrder, and is useful for accessing the field via an interface.
func (v *getIssueIssueProject) GetSortOrder() *float64 { return v.SortOrder }

// GetStartDate returns getIssueIssueProject.StartDate, and is useful for accessing the field via an interface.
func (v *getIssueIssueProject) GetStartDate() *time.Time { return v.StartDate }

// GetStartedAt returns getIssueIssueProject.StartedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueProject) GetStartedAt() *time.Time { return v.StartedAt }

// GetState returns getIssueIssueProject.State, and is useful for accessing the field via an interface.
func (v *getIssueIssueProject) GetState() *string { return v.State }

// GetTargetDate returns getIssueIssueProject.TargetDate, and is useful for accessing the field via an interface.
func (v *getIssueIssueProject) GetTargetDate() *time.Time { return v.TargetDate }

// GetUpdatedAt returns getIssueIssueProject.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueProject) GetUpdatedAt() *time.Time { return v.UpdatedAt }

// GetUrl returns getIssueIssueProject.Url, and is useful for accessing the field via an interface.
func (v *getIssueIssueProject) GetUrl() *string { return v.Url }

func (v *getIssueIssueProject) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getIssueIssueProject
		ArchivedAt                          json.RawMessage `json:"archivedAt"`
		AutoArchivedAt                      json.RawMessage `json:"autoArchivedAt"`
		CanceledAt                          json.RawMessage `json:"canceledAt"`
		CompletedAt                         json.RawMessage `json:"completedAt"`
		CreatedAt                           json.RawMessage `json:"createdAt"`
		ProjectUpdateRemindersPausedUntilAt json.RawMessage `json:"projectUpdateRemindersPausedUntilAt"`
		StartDate                           json.RawMessage `json:"startDate"`
		StartedAt                           json.RawMessage `json:"startedAt"`
		TargetDate                          json.RawMessage `json:"targetDate"`
		UpdatedAt                           json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getIssueIssueProject = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueProject.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.AutoArchivedAt
		src := firstPass.AutoArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueProject.AutoArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CanceledAt
		src := firstPass.CanceledAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueProject.CanceledAt: %w", err)
			}
		}
	}

	{
		dst := &v.CompletedAt
		src := firstPass.CompletedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueProject.CompletedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueProject.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.ProjectUpdateRemindersPausedUntilAt
		src := firstPass.ProjectUpdateRemindersPausedUntilAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueProject.ProjectUpdateRemindersPausedUntilAt: %w", err)
			}
		}
	}

	{
		dst := &v.StartDate
		src := firstPass.StartDate
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueProject.StartDate: %w", err)
			}
		}
	}

	{
		dst := &v.StartedAt
		src := firstPass.StartedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueProject.StartedAt: %w", err)
			}
		}
	}

	{
		dst := &v.TargetDate
		src := firstPass.TargetDate
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueProject.TargetDate: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueProject.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetIssueIssueProject struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AutoArchivedAt json.RawMessage `json:"autoArchivedAt"`

	CanceledAt json.RawMessage `json:"canceledAt"`

	Color *string `json:"color"`

	CompletedAt json.RawMessage `json:"completedAt"`

	CompletedIssueCountHistory []*float64 `json:"completedIssueCountHistory"`

	CompletedScopeHistory []*float64 `json:"completedScopeHistory"`

	CreatedAt json.RawMessage `json:"createdAt"`

	Description *string `json:"description"`

	Icon *string `json:"icon"`

	InProgressScopeHistory []*float64 `json:"inProgressScopeHistory"`

	IssueCountHistory []*float64 `json:"issueCountHistory"`

	Name *string `json:"name"`

	Progress *float64 `json:"progress"`

	ProjectUpdateRemindersPausedUntilAt json.RawMessage `json:"projectUpdateRemindersPausedUntilAt"`

	Scope *float64 `json:"scope"`

	ScopeHistory []*float64 `json:"scopeHistory"`

	SlackIssueComments *bool `json:"slackIssueComments"`

	SlackIssueStatuses *bool `json:"slackIssueStatuses"`

	SlackNewIssue *bool `json:"slackNewIssue"`

	SlugId *string `json:"slugId"`

	SortOrder *float64 `json:"sortOrder"`

	StartDate json.RawMessage `json:"startDate"`

	StartedAt json.RawMessage `json:"startedAt"`

	State *string `json:"state"`

	TargetDate json.RawMessage `json:"targetDate"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	Url *string `json:"url"`
}

func (v *getIssueIssueProject) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getIssueIssueProject) __premarshalJSON() (*__premarshalgetIssueIssueProject, error) {
	var retval __premarshalgetIssueIssueProject

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueProject.ArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.AutoArchivedAt
		src := v.AutoArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueProject.AutoArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CanceledAt
		src := v.CanceledAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueProject.CanceledAt: %w", err)
			}
		}
	}
	retval.Color = v.Color
	{

		dst := &retval.CompletedAt
		src := v.CompletedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueProject.CompletedAt: %w", err)
			}
		}
	}
	retval.CompletedIssueCountHistory = v.CompletedIssueCountHistory
	retval.CompletedScopeHistory = v.CompletedScopeHistory
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueProject.CreatedAt: %w", err)
			}
		}
	}
	retval.Description = v.Description
	retval.Icon = v.Icon
	retval.InProgressScopeHistory = v.InProgressScopeHistory
	retval.IssueCountHistory = v.IssueCountHistory
	retval.Name = v.Name
	retval.Progress = v.Progress
	{

		dst := &retval.ProjectUpdateRemindersPausedUntilAt
		src := v.ProjectUpdateRemindersPausedUntilAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueProject.ProjectUpdateRemindersPausedUntilAt: %w", err)
			}
		}
	}
	retval.Scope = v.Scope
	retval.ScopeHistory = v.ScopeHistory
	retval.SlackIssueComments = v.SlackIssueComments
	retval.SlackIssueStatuses = v.SlackIssueStatuses
	retval.SlackNewIssue = v.SlackNewIssue
	retval.SlugId = v.SlugId
	retval.SortOrder = v.SortOrder
	{

		dst := &retval.StartDate
		src := v.StartDate
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueProject.StartDate: %w", err)
			}
		}
	}
	{

		dst := &retval.StartedAt
		src := v.StartedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueProject.StartedAt: %w", err)
			}
		}
	}
	retval.State = v.State
	{

		dst := &retval.TargetDate
		src := v.TargetDate
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueProject.TargetDate: %w", err)
			}
		}
	}
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueProject.UpdatedAt: %w", err)
			}
		}
	}
	retval.Url = v.Url
	return &retval, nil
}

// getIssueIssueProjectMilestone includes the requested fields of the GraphQL type ProjectMilestone.
// The GraphQL type's documentation follows.
//
// A milestone for a project.
type getIssueIssueProjectMilestone struct {
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// The description of the project milestone.
	Description *string `json:"description"`
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The name of the project milestone.
	Name *string `json:"name"`
	// The order of the milestone in relation to other milestones within a project.
	SortOrder *float64 `json:"sortOrder"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
}

// GetArchivedAt returns getIssueIssueProjectMilestone.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueProjectMilestone) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetCreatedAt returns getIssueIssueProjectMilestone.CreatedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueProjectMilestone) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetDescription returns getIssueIssueProjectMilestone.Description, and is useful for accessing the field via an interface.
func (v *getIssueIssueProjectMilestone) GetDescription() *string { return v.Description }

// GetId returns getIssueIssueProjectMilestone.Id, and is useful for accessing the field via an interface.
func (v *getIssueIssueProjectMilestone) GetId() *string { return v.Id }

// GetName returns getIssueIssueProjectMilestone.Name, and is useful for accessing the field via an interface.
func (v *getIssueIssueProjectMilestone) GetName() *string { return v.Name }

// GetSortOrder returns getIssueIssueProjectMilestone.SortOrder, and is useful for accessing the field via an interface.
func (v *getIssueIssueProjectMilestone) GetSortOrder() *float64 { return v.SortOrder }

// GetUpdatedAt returns getIssueIssueProjectMilestone.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueProjectMilestone) GetUpdatedAt() *time.Time { return v.UpdatedAt }

func (v *getIssueIssueProjectMilestone) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getIssueIssueProjectMilestone
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getIssueIssueProjectMilestone = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueProjectMilestone.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueProjectMilestone.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueProjectMilestone.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetIssueIssueProjectMilestone struct {
	ArchivedAt json.RawMessage `json:"archivedAt"`

	CreatedAt json.RawMessage `json:"createdAt"`

	Description *string `json:"description"`

	Id *string `json:"id"`

	Name *string `json:"name"`

	SortOrder *float64 `json:"sortOrder"`

	UpdatedAt json.RawMessage `json:"updatedAt"`
}

func (v *getIssueIssueProjectMilestone) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getIssueIssueProjectMilestone) __premarshalJSON() (*__premarshalgetIssueIssueProjectMilestone, error) {
	var retval __premarshalgetIssueIssueProjectMilestone

	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueProjectMilestone.ArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueProjectMilestone.CreatedAt: %w", err)
			}
		}
	}
	retval.Description = v.Description
	retval.Id = v.Id
	retval.Name = v.Name
	retval.SortOrder = v.SortOrder
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueProjectMilestone.UpdatedAt: %w", err)
			}
		}
	}
	return &retval, nil
}

// getIssueIssueSnoozedByUser includes the requested fields of the GraphQL type User.
// The GraphQL type's documentation follows.
//
// A user that has access to the the resources of an organization.
type getIssueIssueSnoozedByUser struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// Whether the user account is active or disabled (suspended).
	Active *bool `json:"active"`
	// Whether the user is an organization administrator.
	Admin *bool `json:"admin"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// An URL to the user's avatar image.
	AvatarUrl *string `json:"avatarUrl"`
	// [DEPRECATED] Hash for the user to be used in calendar URLs.
	CalendarHash *string `json:"calendarHash"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Number of issues created.
	CreatedIssueCount *int `json:"createdIssueCount"`
	// A short description of the user, either its title or bio.
	Description *string `json:"description"`
	// Reason why is the account disabled.
	DisableReason *string `json:"disableReason"`
	// The user's display (nick) name. Unique within each organization.
	DisplayName *string `json:"displayName"`
	// The user's email address.
	Email *string `json:"email"`
	// Whether the user is a guest in the workspace and limited to accessing a subset of teams.
	Guest *bool `json:"guest"`
	// Unique hash for the user to be used in invite URLs.
	InviteHash *string `json:"inviteHash"`
	// Whether the user is the currently authenticated user.
	IsMe *bool `json:"isMe"`
	// The last time the user was seen online. If null, the user is currently online.
	LastSeen *time.Time `json:"-"`
	// The user's full name.
	Name *string `json:"name"`
	// The emoji to represent the user current status.
	StatusEmoji *string `json:"statusEmoji"`
	// The label of the user current status.
	StatusLabel *string `json:"statusLabel"`
	// A date at which the user current status should be cleared.
	StatusUntilAt *time.Time `json:"-"`
	// The local timezone of the user.
	Timezone *string `json:"timezone"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// User's profile URL.
	Url *string `json:"url"`
}

// GetId returns getIssueIssueSnoozedByUser.Id, and is useful for accessing the field via an interface.
func (v *getIssueIssueSnoozedByUser) GetId() *string { return v.Id }

// GetActive returns getIssueIssueSnoozedByUser.Active, and is useful for accessing the field via an interface.
func (v *getIssueIssueSnoozedByUser) GetActive() *bool { return v.Active }

// GetAdmin returns getIssueIssueSnoozedByUser.Admin, and is useful for accessing the field via an interface.
func (v *getIssueIssueSnoozedByUser) GetAdmin() *bool { return v.Admin }

// GetArchivedAt returns getIssueIssueSnoozedByUser.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueSnoozedByUser) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetAvatarUrl returns getIssueIssueSnoozedByUser.AvatarUrl, and is useful for accessing the field via an interface.
func (v *getIssueIssueSnoozedByUser) GetAvatarUrl() *string { return v.AvatarUrl }

// GetCalendarHash returns getIssueIssueSnoozedByUser.CalendarHash, and is useful for accessing the field via an interface.
func (v *getIssueIssueSnoozedByUser) GetCalendarHash() *string { return v.CalendarHash }

// GetCreatedAt returns getIssueIssueSnoozedByUser.CreatedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueSnoozedByUser) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetCreatedIssueCount returns getIssueIssueSnoozedByUser.CreatedIssueCount, and is useful for accessing the field via an interface.
func (v *getIssueIssueSnoozedByUser) GetCreatedIssueCount() *int { return v.CreatedIssueCount }

// GetDescription returns getIssueIssueSnoozedByUser.Description, and is useful for accessing the field via an interface.
func (v *getIssueIssueSnoozedByUser) GetDescription() *string { return v.Description }

// GetDisableReason returns getIssueIssueSnoozedByUser.DisableReason, and is useful for accessing the field via an interface.
func (v *getIssueIssueSnoozedByUser) GetDisableReason() *string { return v.DisableReason }

// GetDisplayName returns getIssueIssueSnoozedByUser.DisplayName, and is useful for accessing the field via an interface.
func (v *getIssueIssueSnoozedByUser) GetDisplayName() *string { return v.DisplayName }

// GetEmail returns getIssueIssueSnoozedByUser.Email, and is useful for accessing the field via an interface.
func (v *getIssueIssueSnoozedByUser) GetEmail() *string { return v.Email }

// GetGuest returns getIssueIssueSnoozedByUser.Guest, and is useful for accessing the field via an interface.
func (v *getIssueIssueSnoozedByUser) GetGuest() *bool { return v.Guest }

// GetInviteHash returns getIssueIssueSnoozedByUser.InviteHash, and is useful for accessing the field via an interface.
func (v *getIssueIssueSnoozedByUser) GetInviteHash() *string { return v.InviteHash }

// GetIsMe returns getIssueIssueSnoozedByUser.IsMe, and is useful for accessing the field via an interface.
func (v *getIssueIssueSnoozedByUser) GetIsMe() *bool { return v.IsMe }

// GetLastSeen returns getIssueIssueSnoozedByUser.LastSeen, and is useful for accessing the field via an interface.
func (v *getIssueIssueSnoozedByUser) GetLastSeen() *time.Time { return v.LastSeen }

// GetName returns getIssueIssueSnoozedByUser.Name, and is useful for accessing the field via an interface.
func (v *getIssueIssueSnoozedByUser) GetName() *string { return v.Name }

// GetStatusEmoji returns getIssueIssueSnoozedByUser.StatusEmoji, and is useful for accessing the field via an interface.
func (v *getIssueIssueSnoozedByUser) GetStatusEmoji() *string { return v.StatusEmoji }

// GetStatusLabel returns getIssueIssueSnoozedByUser.StatusLabel, and is useful for accessing the field via an interface.
func (v *getIssueIssueSnoozedByUser) GetStatusLabel() *string { return v.StatusLabel }

// GetStatusUntilAt returns getIssueIssueSnoozedByUser.StatusUntilAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueSnoozedByUser) GetStatusUntilAt() *time.Time { return v.StatusUntilAt }

// GetTimezone returns getIssueIssueSnoozedByUser.Timezone, and is useful for accessing the field via an interface.
func (v *getIssueIssueSnoozedByUser) GetTimezone() *string { return v.Timezone }

// GetUpdatedAt returns getIssueIssueSnoozedByUser.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueSnoozedByUser) GetUpdatedAt() *time.Time { return v.UpdatedAt }

// GetUrl returns getIssueIssueSnoozedByUser.Url, and is useful for accessing the field via an interface.
func (v *getIssueIssueSnoozedByUser) GetUrl() *string { return v.Url }

func (v *getIssueIssueSnoozedByUser) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getIssueIssueSnoozedByUser
		ArchivedAt    json.RawMessage `json:"archivedAt"`
		CreatedAt     json.RawMessage `json:"createdAt"`
		LastSeen      json.RawMessage `json:"lastSeen"`
		StatusUntilAt json.RawMessage `json:"statusUntilAt"`
		UpdatedAt     json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getIssueIssueSnoozedByUser = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueSnoozedByUser.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueSnoozedByUser.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.LastSeen
		src := firstPass.LastSeen
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueSnoozedByUser.LastSeen: %w", err)
			}
		}
	}

	{
		dst := &v.StatusUntilAt
		src := firstPass.StatusUntilAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueSnoozedByUser.StatusUntilAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueSnoozedByUser.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetIssueIssueSnoozedByUser struct {
	Id *string `json:"id"`

	Active *bool `json:"active"`

	Admin *bool `json:"admin"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AvatarUrl *string `json:"avatarUrl"`

	CalendarHash *string `json:"calendarHash"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CreatedIssueCount *int `json:"createdIssueCount"`

	Description *string `json:"description"`

	DisableReason *string `json:"disableReason"`

	DisplayName *string `json:"displayName"`

	Email *string `json:"email"`

	Guest *bool `json:"guest"`

	InviteHash *string `json:"inviteHash"`

	IsMe *bool `json:"isMe"`

	LastSeen json.RawMessage `json:"lastSeen"`

	Name *string `json:"name"`

	StatusEmoji *string `json:"statusEmoji"`

	StatusLabel *string `json:"statusLabel"`

	StatusUntilAt json.RawMessage `json:"statusUntilAt"`

	Timezone *string `json:"timezone"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	Url *string `json:"url"`
}

func (v *getIssueIssueSnoozedByUser) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getIssueIssueSnoozedByUser) __premarshalJSON() (*__premarshalgetIssueIssueSnoozedByUser, error) {
	var retval __premarshalgetIssueIssueSnoozedByUser

	retval.Id = v.Id
	retval.Active = v.Active
	retval.Admin = v.Admin
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueSnoozedByUser.ArchivedAt: %w", err)
			}
		}
	}
	retval.AvatarUrl = v.AvatarUrl
	retval.CalendarHash = v.CalendarHash
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueSnoozedByUser.CreatedAt: %w", err)
			}
		}
	}
	retval.CreatedIssueCount = v.CreatedIssueCount
	retval.Description = v.Description
	retval.DisableReason = v.DisableReason
	retval.DisplayName = v.DisplayName
	retval.Email = v.Email
	retval.Guest = v.Guest
	retval.InviteHash = v.InviteHash
	retval.IsMe = v.IsMe
	{

		dst := &retval.LastSeen
		src := v.LastSeen
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueSnoozedByUser.LastSeen: %w", err)
			}
		}
	}
	retval.Name = v.Name
	retval.StatusEmoji = v.StatusEmoji
	retval.StatusLabel = v.StatusLabel
	{

		dst := &retval.StatusUntilAt
		src := v.StatusUntilAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueSnoozedByUser.StatusUntilAt: %w", err)
			}
		}
	}
	retval.Timezone = v.Timezone
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueSnoozedByUser.UpdatedAt: %w", err)
			}
		}
	}
	retval.Url = v.Url
	return &retval, nil
}

// getIssueIssueStateWorkflowState includes the requested fields of the GraphQL type WorkflowState.
// The GraphQL type's documentation follows.
//
// A state in a team workflow.
type getIssueIssueStateWorkflowState struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The state's UI color as a HEX string.
	Color *string `json:"color"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Description of the state.
	Description *string `json:"description"`
	// The state's name.
	Name *string `json:"name"`
	// The position of the state in the team flow.
	Position *float64 `json:"position"`
	// The type of the state.
	Type *string `json:"type"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
}

// GetId returns getIssueIssueStateWorkflowState.Id, and is useful for accessing the field via an interface.
func (v *getIssueIssueStateWorkflowState) GetId() *string { return v.Id }

// GetArchivedAt returns getIssueIssueStateWorkflowState.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueStateWorkflowState) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetColor returns getIssueIssueStateWorkflowState.Color, and is useful for accessing the field via an interface.
func (v *getIssueIssueStateWorkflowState) GetColor() *string { return v.Color }

// GetCreatedAt returns getIssueIssueStateWorkflowState.CreatedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueStateWorkflowState) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetDescription returns getIssueIssueStateWorkflowState.Description, and is useful for accessing the field via an interface.
func (v *getIssueIssueStateWorkflowState) GetDescription() *string { return v.Description }

// GetName returns getIssueIssueStateWorkflowState.Name, and is useful for accessing the field via an interface.
func (v *getIssueIssueStateWorkflowState) GetName() *string { return v.Name }

// GetPosition returns getIssueIssueStateWorkflowState.Position, and is useful for accessing the field via an interface.
func (v *getIssueIssueStateWorkflowState) GetPosition() *float64 { return v.Position }

// GetType returns getIssueIssueStateWorkflowState.Type, and is useful for accessing the field via an interface.
func (v *getIssueIssueStateWorkflowState) GetType() *string { return v.Type }

// GetUpdatedAt returns getIssueIssueStateWorkflowState.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueStateWorkflowState) GetUpdatedAt() *time.Time { return v.UpdatedAt }

func (v *getIssueIssueStateWorkflowState) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getIssueIssueStateWorkflowState
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getIssueIssueStateWorkflowState = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueStateWorkflowState.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueStateWorkflowState.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueStateWorkflowState.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetIssueIssueStateWorkflowState struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	Color *string `json:"color"`

	CreatedAt json.RawMessage `json:"createdAt"`

	Description *string `json:"description"`

	Name *string `json:"name"`

	Position *float64 `json:"position"`

	Type *string `json:"type"`

	UpdatedAt json.RawMessage `json:"updatedAt"`
}

func (v *getIssueIssueStateWorkflowState) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getIssueIssueStateWorkflowState) __premarshalJSON() (*__premarshalgetIssueIssueStateWorkflowState, error) {
	var retval __premarshalgetIssueIssueStateWorkflowState

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueStateWorkflowState.ArchivedAt: %w", err)
			}
		}
	}
	retval.Color = v.Color
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueStateWorkflowState.CreatedAt: %w", err)
			}
		}
	}
	retval.Description = v.Description
	retval.Name = v.Name
	retval.Position = v.Position
	retval.Type = v.Type
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueStateWorkflowState.UpdatedAt: %w", err)
			}
		}
	}
	return &retval, nil
}

// getIssueIssueTeam includes the requested fields of the GraphQL type Team.
// The GraphQL type's documentation follows.
//
// An organizational unit that contains issues.
type getIssueIssueTeam struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// Period after which automatically closed and completed issues are automatically archived in months.
	AutoArchivePeriod *float64 `json:"autoArchivePeriod"`
	// Period after which issues are automatically closed in months. Null/undefined means disabled.
	AutoClosePeriod *float64 `json:"autoClosePeriod"`
	// The canceled workflow state which auto closed issues will be set to. Defaults to the first canceled state.
	AutoCloseStateId *string `json:"autoCloseStateId"`
	// The team's color.
	Color *string `json:"color"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Calendar feed URL (iCal) for cycles.
	CycleCalenderUrl *string `json:"cycleCalenderUrl"`
	// The cooldown time after each cycle in weeks.
	CycleCooldownTime *float64 `json:"cycleCooldownTime"`
	// The duration of a cycle in weeks.
	CycleDuration *float64 `json:"cycleDuration"`
	// Auto assign completed issues to current cycle.
	CycleIssueAutoAssignCompleted *bool `json:"cycleIssueAutoAssignCompleted"`
	// Auto assign started issues to current cycle.
	CycleIssueAutoAssignStarted *bool `json:"cycleIssueAutoAssignStarted"`
	// Only allow issues issues with cycles in Active Issues.
	CycleLockToActive *bool `json:"cycleLockToActive"`
	// The day of the week that a new cycle starts.
	CycleStartDay *float64 `json:"cycleStartDay"`
	// Whether the team uses cycles.
	CyclesEnabled *bool `json:"cyclesEnabled"`
	// What to use as an default estimate for unestimated issues.
	DefaultIssueEstimate *float64 `json:"defaultIssueEstimate"`
	// The id of the default template to use for new issues created by members of the team.
	DefaultTemplateForMembersId *string `json:"defaultTemplateForMembersId"`
	// The id of the default template to use for new issues created by non-members of the team.
	DefaultTemplateForNonMembersId *string `json:"defaultTemplateForNonMembersId"`
	// The team's description.
	Description *string `json:"description"`
	// Whether to group recent issue history entries.
	GroupIssueHistory *bool `json:"groupIssueHistory"`
	// The icon of the team.
	Icon *string `json:"icon"`
	// Unique hash for the team to be used in invite URLs.
	InviteHash *string `json:"inviteHash"`
	// Whether to allow zeros in issues estimates.
	IssueEstimationAllowZero *bool `json:"issueEstimationAllowZero"`
	// Whether to add additional points to the estimate scale.
	IssueEstimationExtended *bool `json:"issueEstimationExtended"`
	// The issue estimation type to use.
	IssueEstimationType *string `json:"issueEstimationType"`
	// Whether issues without priority should be sorted first.
	IssueOrderingNoPriorityFirst *bool `json:"issueOrderingNoPriorityFirst"`
	// Whether to move issues to bottom of the column when changing state.
	IssueSortOrderDefaultToBottom *bool `json:"issueSortOrderDefaultToBottom"`
	// The team's unique key. The key is used in URLs.
	Key *string `json:"key"`
	// The team's name.
	Name *string `json:"name"`
	// Whether the team is private or not.
	Private *bool `json:"private"`
	// Whether an issue needs to have a priority set before leaving triage
	RequirePriorityToLeaveTriage *bool `json:"requirePriorityToLeaveTriage"`
	// Whether to send new issue comment notifications to Slack.
	SlackIssueComments *bool `json:"slackIssueComments"`
	// Whether to send new issue status updates to Slack.
	SlackIssueStatuses *bool `json:"slackIssueStatuses"`
	// Whether to send new issue notifications to Slack.
	SlackNewIssue *bool `json:"slackNewIssue"`
	// The timezone of the team. Defaults to "America/Los_Angeles"
	Timezone *string `json:"timezone"`
	// Whether triage mode is enabled for the team or not.
	TriageEnabled *bool `json:"triageEnabled"`
	// How many upcoming cycles to create.
	UpcomingCycleCount *float64 `json:"upcomingCycleCount"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
}

// GetId returns getIssueIssueTeam.Id, and is useful for accessing the field via an interface.
func (v *getIssueIssueTeam) GetId() *string { return v.Id }

// GetArchivedAt returns getIssueIssueTeam.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueTeam) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetAutoArchivePeriod returns getIssueIssueTeam.AutoArchivePeriod, and is useful for accessing the field via an interface.
func (v *getIssueIssueTeam) GetAutoArchivePeriod() *float64 { return v.AutoArchivePeriod }

// GetAutoClosePeriod returns getIssueIssueTeam.AutoClosePeriod, and is useful for accessing the field via an interface.
func (v *getIssueIssueTeam) GetAutoClosePeriod() *float64 { return v.AutoClosePeriod }

// GetAutoCloseStateId returns getIssueIssueTeam.AutoCloseStateId, and is useful for accessing the field via an interface.
func (v *getIssueIssueTeam) GetAutoCloseStateId() *string { return v.AutoCloseStateId }

// GetColor returns getIssueIssueTeam.Color, and is useful for accessing the field via an interface.
func (v *getIssueIssueTeam) GetColor() *string { return v.Color }

// GetCreatedAt returns getIssueIssueTeam.CreatedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueTeam) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetCycleCalenderUrl returns getIssueIssueTeam.CycleCalenderUrl, and is useful for accessing the field via an interface.
func (v *getIssueIssueTeam) GetCycleCalenderUrl() *string { return v.CycleCalenderUrl }

// GetCycleCooldownTime returns getIssueIssueTeam.CycleCooldownTime, and is useful for accessing the field via an interface.
func (v *getIssueIssueTeam) GetCycleCooldownTime() *float64 { return v.CycleCooldownTime }

// GetCycleDuration returns getIssueIssueTeam.CycleDuration, and is useful for accessing the field via an interface.
func (v *getIssueIssueTeam) GetCycleDuration() *float64 { return v.CycleDuration }

// GetCycleIssueAutoAssignCompleted returns getIssueIssueTeam.CycleIssueAutoAssignCompleted, and is useful for accessing the field via an interface.
func (v *getIssueIssueTeam) GetCycleIssueAutoAssignCompleted() *bool {
	return v.CycleIssueAutoAssignCompleted
}

// GetCycleIssueAutoAssignStarted returns getIssueIssueTeam.CycleIssueAutoAssignStarted, and is useful for accessing the field via an interface.
func (v *getIssueIssueTeam) GetCycleIssueAutoAssignStarted() *bool {
	return v.CycleIssueAutoAssignStarted
}

// GetCycleLockToActive returns getIssueIssueTeam.CycleLockToActive, and is useful for accessing the field via an interface.
func (v *getIssueIssueTeam) GetCycleLockToActive() *bool { return v.CycleLockToActive }

// GetCycleStartDay returns getIssueIssueTeam.CycleStartDay, and is useful for accessing the field via an interface.
func (v *getIssueIssueTeam) GetCycleStartDay() *float64 { return v.CycleStartDay }

// GetCyclesEnabled returns getIssueIssueTeam.CyclesEnabled, and is useful for accessing the field via an interface.
func (v *getIssueIssueTeam) GetCyclesEnabled() *bool { return v.CyclesEnabled }

// GetDefaultIssueEstimate returns getIssueIssueTeam.DefaultIssueEstimate, and is useful for accessing the field via an interface.
func (v *getIssueIssueTeam) GetDefaultIssueEstimate() *float64 { return v.DefaultIssueEstimate }

// GetDefaultTemplateForMembersId returns getIssueIssueTeam.DefaultTemplateForMembersId, and is useful for accessing the field via an interface.
func (v *getIssueIssueTeam) GetDefaultTemplateForMembersId() *string {
	return v.DefaultTemplateForMembersId
}

// GetDefaultTemplateForNonMembersId returns getIssueIssueTeam.DefaultTemplateForNonMembersId, and is useful for accessing the field via an interface.
func (v *getIssueIssueTeam) GetDefaultTemplateForNonMembersId() *string {
	return v.DefaultTemplateForNonMembersId
}

// GetDescription returns getIssueIssueTeam.Description, and is useful for accessing the field via an interface.
func (v *getIssueIssueTeam) GetDescription() *string { return v.Description }

// GetGroupIssueHistory returns getIssueIssueTeam.GroupIssueHistory, and is useful for accessing the field via an interface.
func (v *getIssueIssueTeam) GetGroupIssueHistory() *bool { return v.GroupIssueHistory }

// GetIcon returns getIssueIssueTeam.Icon, and is useful for accessing the field via an interface.
func (v *getIssueIssueTeam) GetIcon() *string { return v.Icon }

// GetInviteHash returns getIssueIssueTeam.InviteHash, and is useful for accessing the field via an interface.
func (v *getIssueIssueTeam) GetInviteHash() *string { return v.InviteHash }

// GetIssueEstimationAllowZero returns getIssueIssueTeam.IssueEstimationAllowZero, and is useful for accessing the field via an interface.
func (v *getIssueIssueTeam) GetIssueEstimationAllowZero() *bool { return v.IssueEstimationAllowZero }

// GetIssueEstimationExtended returns getIssueIssueTeam.IssueEstimationExtended, and is useful for accessing the field via an interface.
func (v *getIssueIssueTeam) GetIssueEstimationExtended() *bool { return v.IssueEstimationExtended }

// GetIssueEstimationType returns getIssueIssueTeam.IssueEstimationType, and is useful for accessing the field via an interface.
func (v *getIssueIssueTeam) GetIssueEstimationType() *string { return v.IssueEstimationType }

// GetIssueOrderingNoPriorityFirst returns getIssueIssueTeam.IssueOrderingNoPriorityFirst, and is useful for accessing the field via an interface.
func (v *getIssueIssueTeam) GetIssueOrderingNoPriorityFirst() *bool {
	return v.IssueOrderingNoPriorityFirst
}

// GetIssueSortOrderDefaultToBottom returns getIssueIssueTeam.IssueSortOrderDefaultToBottom, and is useful for accessing the field via an interface.
func (v *getIssueIssueTeam) GetIssueSortOrderDefaultToBottom() *bool {
	return v.IssueSortOrderDefaultToBottom
}

// GetKey returns getIssueIssueTeam.Key, and is useful for accessing the field via an interface.
func (v *getIssueIssueTeam) GetKey() *string { return v.Key }

// GetName returns getIssueIssueTeam.Name, and is useful for accessing the field via an interface.
func (v *getIssueIssueTeam) GetName() *string { return v.Name }

// GetPrivate returns getIssueIssueTeam.Private, and is useful for accessing the field via an interface.
func (v *getIssueIssueTeam) GetPrivate() *bool { return v.Private }

// GetRequirePriorityToLeaveTriage returns getIssueIssueTeam.RequirePriorityToLeaveTriage, and is useful for accessing the field via an interface.
func (v *getIssueIssueTeam) GetRequirePriorityToLeaveTriage() *bool {
	return v.RequirePriorityToLeaveTriage
}

// GetSlackIssueComments returns getIssueIssueTeam.SlackIssueComments, and is useful for accessing the field via an interface.
func (v *getIssueIssueTeam) GetSlackIssueComments() *bool { return v.SlackIssueComments }

// GetSlackIssueStatuses returns getIssueIssueTeam.SlackIssueStatuses, and is useful for accessing the field via an interface.
func (v *getIssueIssueTeam) GetSlackIssueStatuses() *bool { return v.SlackIssueStatuses }

// GetSlackNewIssue returns getIssueIssueTeam.SlackNewIssue, and is useful for accessing the field via an interface.
func (v *getIssueIssueTeam) GetSlackNewIssue() *bool { return v.SlackNewIssue }

// GetTimezone returns getIssueIssueTeam.Timezone, and is useful for accessing the field via an interface.
func (v *getIssueIssueTeam) GetTimezone() *string { return v.Timezone }

// GetTriageEnabled returns getIssueIssueTeam.TriageEnabled, and is useful for accessing the field via an interface.
func (v *getIssueIssueTeam) GetTriageEnabled() *bool { return v.TriageEnabled }

// GetUpcomingCycleCount returns getIssueIssueTeam.UpcomingCycleCount, and is useful for accessing the field via an interface.
func (v *getIssueIssueTeam) GetUpcomingCycleCount() *float64 { return v.UpcomingCycleCount }

// GetUpdatedAt returns getIssueIssueTeam.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getIssueIssueTeam) GetUpdatedAt() *time.Time { return v.UpdatedAt }

func (v *getIssueIssueTeam) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getIssueIssueTeam
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getIssueIssueTeam = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueTeam.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueTeam.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueIssueTeam.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetIssueIssueTeam struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AutoArchivePeriod *float64 `json:"autoArchivePeriod"`

	AutoClosePeriod *float64 `json:"autoClosePeriod"`

	AutoCloseStateId *string `json:"autoCloseStateId"`

	Color *string `json:"color"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CycleCalenderUrl *string `json:"cycleCalenderUrl"`

	CycleCooldownTime *float64 `json:"cycleCooldownTime"`

	CycleDuration *float64 `json:"cycleDuration"`

	CycleIssueAutoAssignCompleted *bool `json:"cycleIssueAutoAssignCompleted"`

	CycleIssueAutoAssignStarted *bool `json:"cycleIssueAutoAssignStarted"`

	CycleLockToActive *bool `json:"cycleLockToActive"`

	CycleStartDay *float64 `json:"cycleStartDay"`

	CyclesEnabled *bool `json:"cyclesEnabled"`

	DefaultIssueEstimate *float64 `json:"defaultIssueEstimate"`

	DefaultTemplateForMembersId *string `json:"defaultTemplateForMembersId"`

	DefaultTemplateForNonMembersId *string `json:"defaultTemplateForNonMembersId"`

	Description *string `json:"description"`

	GroupIssueHistory *bool `json:"groupIssueHistory"`

	Icon *string `json:"icon"`

	InviteHash *string `json:"inviteHash"`

	IssueEstimationAllowZero *bool `json:"issueEstimationAllowZero"`

	IssueEstimationExtended *bool `json:"issueEstimationExtended"`

	IssueEstimationType *string `json:"issueEstimationType"`

	IssueOrderingNoPriorityFirst *bool `json:"issueOrderingNoPriorityFirst"`

	IssueSortOrderDefaultToBottom *bool `json:"issueSortOrderDefaultToBottom"`

	Key *string `json:"key"`

	Name *string `json:"name"`

	Private *bool `json:"private"`

	RequirePriorityToLeaveTriage *bool `json:"requirePriorityToLeaveTriage"`

	SlackIssueComments *bool `json:"slackIssueComments"`

	SlackIssueStatuses *bool `json:"slackIssueStatuses"`

	SlackNewIssue *bool `json:"slackNewIssue"`

	Timezone *string `json:"timezone"`

	TriageEnabled *bool `json:"triageEnabled"`

	UpcomingCycleCount *float64 `json:"upcomingCycleCount"`

	UpdatedAt json.RawMessage `json:"updatedAt"`
}

func (v *getIssueIssueTeam) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getIssueIssueTeam) __premarshalJSON() (*__premarshalgetIssueIssueTeam, error) {
	var retval __premarshalgetIssueIssueTeam

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueTeam.ArchivedAt: %w", err)
			}
		}
	}
	retval.AutoArchivePeriod = v.AutoArchivePeriod
	retval.AutoClosePeriod = v.AutoClosePeriod
	retval.AutoCloseStateId = v.AutoCloseStateId
	retval.Color = v.Color
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueTeam.CreatedAt: %w", err)
			}
		}
	}
	retval.CycleCalenderUrl = v.CycleCalenderUrl
	retval.CycleCooldownTime = v.CycleCooldownTime
	retval.CycleDuration = v.CycleDuration
	retval.CycleIssueAutoAssignCompleted = v.CycleIssueAutoAssignCompleted
	retval.CycleIssueAutoAssignStarted = v.CycleIssueAutoAssignStarted
	retval.CycleLockToActive = v.CycleLockToActive
	retval.CycleStartDay = v.CycleStartDay
	retval.CyclesEnabled = v.CyclesEnabled
	retval.DefaultIssueEstimate = v.DefaultIssueEstimate
	retval.DefaultTemplateForMembersId = v.DefaultTemplateForMembersId
	retval.DefaultTemplateForNonMembersId = v.DefaultTemplateForNonMembersId
	retval.Description = v.Description
	retval.GroupIssueHistory = v.GroupIssueHistory
	retval.Icon = v.Icon
	retval.InviteHash = v.InviteHash
	retval.IssueEstimationAllowZero = v.IssueEstimationAllowZero
	retval.IssueEstimationExtended = v.IssueEstimationExtended
	retval.IssueEstimationType = v.IssueEstimationType
	retval.IssueOrderingNoPriorityFirst = v.IssueOrderingNoPriorityFirst
	retval.IssueSortOrderDefaultToBottom = v.IssueSortOrderDefaultToBottom
	retval.Key = v.Key
	retval.Name = v.Name
	retval.Private = v.Private
	retval.RequirePriorityToLeaveTriage = v.RequirePriorityToLeaveTriage
	retval.SlackIssueComments = v.SlackIssueComments
	retval.SlackIssueStatuses = v.SlackIssueStatuses
	retval.SlackNewIssue = v.SlackNewIssue
	retval.Timezone = v.Timezone
	retval.TriageEnabled = v.TriageEnabled
	retval.UpcomingCycleCount = v.UpcomingCycleCount
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueIssueTeam.UpdatedAt: %w", err)
			}
		}
	}
	return &retval, nil
}

// getIssueLabelIssueLabel includes the requested fields of the GraphQL type IssueLabel.
// The GraphQL type's documentation follows.
//
// Labels that can be associated with issues.
type getIssueLabelIssueLabel struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The label's color as a HEX string.
	Color *string `json:"color"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// The label's description.
	Description *string `json:"description"`
	// The label's name.
	Name *string `json:"name"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// Issues associated with the label.
	Issues *getIssueLabelIssueLabelIssuesIssueConnection `json:"issues"`
	// The team that the label is associated with. If null, the label is associated with the global workspace.
	Team *getIssueLabelIssueLabelTeam `json:"team"`
	// The user who created the label.
	Creator      *getIssueLabelIssueLabelCreatorUser  `json:"creator"`
	Organization *getIssueLabelIssueLabelOrganization `json:"organization"`
	// The parent label.
	Parent *getIssueLabelIssueLabelParentIssueLabel `json:"parent"`
}

// GetId returns getIssueLabelIssueLabel.Id, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabel) GetId() *string { return v.Id }

// GetArchivedAt returns getIssueLabelIssueLabel.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabel) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetColor returns getIssueLabelIssueLabel.Color, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabel) GetColor() *string { return v.Color }

// GetCreatedAt returns getIssueLabelIssueLabel.CreatedAt, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabel) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetDescription returns getIssueLabelIssueLabel.Description, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabel) GetDescription() *string { return v.Description }

// GetName returns getIssueLabelIssueLabel.Name, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabel) GetName() *string { return v.Name }

// GetUpdatedAt returns getIssueLabelIssueLabel.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabel) GetUpdatedAt() *time.Time { return v.UpdatedAt }

// GetIssues returns getIssueLabelIssueLabel.Issues, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabel) GetIssues() *getIssueLabelIssueLabelIssuesIssueConnection {
	return v.Issues
}

// GetTeam returns getIssueLabelIssueLabel.Team, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabel) GetTeam() *getIssueLabelIssueLabelTeam { return v.Team }

// GetCreator returns getIssueLabelIssueLabel.Creator, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabel) GetCreator() *getIssueLabelIssueLabelCreatorUser { return v.Creator }

// GetOrganization returns getIssueLabelIssueLabel.Organization, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabel) GetOrganization() *getIssueLabelIssueLabelOrganization {
	return v.Organization
}

// GetParent returns getIssueLabelIssueLabel.Parent, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabel) GetParent() *getIssueLabelIssueLabelParentIssueLabel {
	return v.Parent
}

func (v *getIssueLabelIssueLabel) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getIssueLabelIssueLabel
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getIssueLabelIssueLabel = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueLabelIssueLabel.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueLabelIssueLabel.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueLabelIssueLabel.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetIssueLabelIssueLabel struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	Color *string `json:"color"`

	CreatedAt json.RawMessage `json:"createdAt"`

	Description *string `json:"description"`

	Name *string `json:"name"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	Issues *getIssueLabelIssueLabelIssuesIssueConnection `json:"issues"`

	Team *getIssueLabelIssueLabelTeam `json:"team"`

	Creator *getIssueLabelIssueLabelCreatorUser `json:"creator"`

	Organization *getIssueLabelIssueLabelOrganization `json:"organization"`

	Parent *getIssueLabelIssueLabelParentIssueLabel `json:"parent"`
}

func (v *getIssueLabelIssueLabel) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getIssueLabelIssueLabel) __premarshalJSON() (*__premarshalgetIssueLabelIssueLabel, error) {
	var retval __premarshalgetIssueLabelIssueLabel

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueLabelIssueLabel.ArchivedAt: %w", err)
			}
		}
	}
	retval.Color = v.Color
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueLabelIssueLabel.CreatedAt: %w", err)
			}
		}
	}
	retval.Description = v.Description
	retval.Name = v.Name
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueLabelIssueLabel.UpdatedAt: %w", err)
			}
		}
	}
	retval.Issues = v.Issues
	retval.Team = v.Team
	retval.Creator = v.Creator
	retval.Organization = v.Organization
	retval.Parent = v.Parent
	return &retval, nil
}

// getIssueLabelIssueLabelCreatorUser includes the requested fields of the GraphQL type User.
// The GraphQL type's documentation follows.
//
// A user that has access to the the resources of an organization.
type getIssueLabelIssueLabelCreatorUser struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// Whether the user account is active or disabled (suspended).
	Active *bool `json:"active"`
	// Whether the user is an organization administrator.
	Admin *bool `json:"admin"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// An URL to the user's avatar image.
	AvatarUrl *string `json:"avatarUrl"`
	// [DEPRECATED] Hash for the user to be used in calendar URLs.
	CalendarHash *string `json:"calendarHash"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Number of issues created.
	CreatedIssueCount *int `json:"createdIssueCount"`
	// A short description of the user, either its title or bio.
	Description *string `json:"description"`
	// Reason why is the account disabled.
	DisableReason *string `json:"disableReason"`
	// The user's display (nick) name. Unique within each organization.
	DisplayName *string `json:"displayName"`
	// The user's email address.
	Email *string `json:"email"`
	// Whether the user is a guest in the workspace and limited to accessing a subset of teams.
	Guest *bool `json:"guest"`
	// Unique hash for the user to be used in invite URLs.
	InviteHash *string `json:"inviteHash"`
	// Whether the user is the currently authenticated user.
	IsMe *bool `json:"isMe"`
	// The last time the user was seen online. If null, the user is currently online.
	LastSeen *time.Time `json:"-"`
	// The user's full name.
	Name *string `json:"name"`
	// The emoji to represent the user current status.
	StatusEmoji *string `json:"statusEmoji"`
	// The label of the user current status.
	StatusLabel *string `json:"statusLabel"`
	// A date at which the user current status should be cleared.
	StatusUntilAt *time.Time `json:"-"`
	// The local timezone of the user.
	Timezone *string `json:"timezone"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// User's profile URL.
	Url *string `json:"url"`
}

// GetId returns getIssueLabelIssueLabelCreatorUser.Id, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelCreatorUser) GetId() *string { return v.Id }

// GetActive returns getIssueLabelIssueLabelCreatorUser.Active, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelCreatorUser) GetActive() *bool { return v.Active }

// GetAdmin returns getIssueLabelIssueLabelCreatorUser.Admin, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelCreatorUser) GetAdmin() *bool { return v.Admin }

// GetArchivedAt returns getIssueLabelIssueLabelCreatorUser.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelCreatorUser) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetAvatarUrl returns getIssueLabelIssueLabelCreatorUser.AvatarUrl, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelCreatorUser) GetAvatarUrl() *string { return v.AvatarUrl }

// GetCalendarHash returns getIssueLabelIssueLabelCreatorUser.CalendarHash, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelCreatorUser) GetCalendarHash() *string { return v.CalendarHash }

// GetCreatedAt returns getIssueLabelIssueLabelCreatorUser.CreatedAt, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelCreatorUser) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetCreatedIssueCount returns getIssueLabelIssueLabelCreatorUser.CreatedIssueCount, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelCreatorUser) GetCreatedIssueCount() *int { return v.CreatedIssueCount }

// GetDescription returns getIssueLabelIssueLabelCreatorUser.Description, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelCreatorUser) GetDescription() *string { return v.Description }

// GetDisableReason returns getIssueLabelIssueLabelCreatorUser.DisableReason, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelCreatorUser) GetDisableReason() *string { return v.DisableReason }

// GetDisplayName returns getIssueLabelIssueLabelCreatorUser.DisplayName, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelCreatorUser) GetDisplayName() *string { return v.DisplayName }

// GetEmail returns getIssueLabelIssueLabelCreatorUser.Email, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelCreatorUser) GetEmail() *string { return v.Email }

// GetGuest returns getIssueLabelIssueLabelCreatorUser.Guest, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelCreatorUser) GetGuest() *bool { return v.Guest }

// GetInviteHash returns getIssueLabelIssueLabelCreatorUser.InviteHash, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelCreatorUser) GetInviteHash() *string { return v.InviteHash }

// GetIsMe returns getIssueLabelIssueLabelCreatorUser.IsMe, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelCreatorUser) GetIsMe() *bool { return v.IsMe }

// GetLastSeen returns getIssueLabelIssueLabelCreatorUser.LastSeen, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelCreatorUser) GetLastSeen() *time.Time { return v.LastSeen }

// GetName returns getIssueLabelIssueLabelCreatorUser.Name, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelCreatorUser) GetName() *string { return v.Name }

// GetStatusEmoji returns getIssueLabelIssueLabelCreatorUser.StatusEmoji, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelCreatorUser) GetStatusEmoji() *string { return v.StatusEmoji }

// GetStatusLabel returns getIssueLabelIssueLabelCreatorUser.StatusLabel, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelCreatorUser) GetStatusLabel() *string { return v.StatusLabel }

// GetStatusUntilAt returns getIssueLabelIssueLabelCreatorUser.StatusUntilAt, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelCreatorUser) GetStatusUntilAt() *time.Time { return v.StatusUntilAt }

// GetTimezone returns getIssueLabelIssueLabelCreatorUser.Timezone, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelCreatorUser) GetTimezone() *string { return v.Timezone }

// GetUpdatedAt returns getIssueLabelIssueLabelCreatorUser.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelCreatorUser) GetUpdatedAt() *time.Time { return v.UpdatedAt }

// GetUrl returns getIssueLabelIssueLabelCreatorUser.Url, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelCreatorUser) GetUrl() *string { return v.Url }

func (v *getIssueLabelIssueLabelCreatorUser) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getIssueLabelIssueLabelCreatorUser
		ArchivedAt    json.RawMessage `json:"archivedAt"`
		CreatedAt     json.RawMessage `json:"createdAt"`
		LastSeen      json.RawMessage `json:"lastSeen"`
		StatusUntilAt json.RawMessage `json:"statusUntilAt"`
		UpdatedAt     json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getIssueLabelIssueLabelCreatorUser = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueLabelIssueLabelCreatorUser.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueLabelIssueLabelCreatorUser.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.LastSeen
		src := firstPass.LastSeen
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueLabelIssueLabelCreatorUser.LastSeen: %w", err)
			}
		}
	}

	{
		dst := &v.StatusUntilAt
		src := firstPass.StatusUntilAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueLabelIssueLabelCreatorUser.StatusUntilAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueLabelIssueLabelCreatorUser.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetIssueLabelIssueLabelCreatorUser struct {
	Id *string `json:"id"`

	Active *bool `json:"active"`

	Admin *bool `json:"admin"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AvatarUrl *string `json:"avatarUrl"`

	CalendarHash *string `json:"calendarHash"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CreatedIssueCount *int `json:"createdIssueCount"`

	Description *string `json:"description"`

	DisableReason *string `json:"disableReason"`

	DisplayName *string `json:"displayName"`

	Email *string `json:"email"`

	Guest *bool `json:"guest"`

	InviteHash *string `json:"inviteHash"`

	IsMe *bool `json:"isMe"`

	LastSeen json.RawMessage `json:"lastSeen"`

	Name *string `json:"name"`

	StatusEmoji *string `json:"statusEmoji"`

	StatusLabel *string `json:"statusLabel"`

	StatusUntilAt json.RawMessage `json:"statusUntilAt"`

	Timezone *string `json:"timezone"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	Url *string `json:"url"`
}

func (v *getIssueLabelIssueLabelCreatorUser) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getIssueLabelIssueLabelCreatorUser) __premarshalJSON() (*__premarshalgetIssueLabelIssueLabelCreatorUser, error) {
	var retval __premarshalgetIssueLabelIssueLabelCreatorUser

	retval.Id = v.Id
	retval.Active = v.Active
	retval.Admin = v.Admin
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueLabelIssueLabelCreatorUser.ArchivedAt: %w", err)
			}
		}
	}
	retval.AvatarUrl = v.AvatarUrl
	retval.CalendarHash = v.CalendarHash
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueLabelIssueLabelCreatorUser.CreatedAt: %w", err)
			}
		}
	}
	retval.CreatedIssueCount = v.CreatedIssueCount
	retval.Description = v.Description
	retval.DisableReason = v.DisableReason
	retval.DisplayName = v.DisplayName
	retval.Email = v.Email
	retval.Guest = v.Guest
	retval.InviteHash = v.InviteHash
	retval.IsMe = v.IsMe
	{

		dst := &retval.LastSeen
		src := v.LastSeen
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueLabelIssueLabelCreatorUser.LastSeen: %w", err)
			}
		}
	}
	retval.Name = v.Name
	retval.StatusEmoji = v.StatusEmoji
	retval.StatusLabel = v.StatusLabel
	{

		dst := &retval.StatusUntilAt
		src := v.StatusUntilAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueLabelIssueLabelCreatorUser.StatusUntilAt: %w", err)
			}
		}
	}
	retval.Timezone = v.Timezone
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueLabelIssueLabelCreatorUser.UpdatedAt: %w", err)
			}
		}
	}
	retval.Url = v.Url
	return &retval, nil
}

// getIssueLabelIssueLabelIssuesIssueConnection includes the requested fields of the GraphQL type IssueConnection.
type getIssueLabelIssueLabelIssuesIssueConnection struct {
	PageInfo *getIssueLabelIssueLabelIssuesIssueConnectionPageInfo     `json:"pageInfo"`
	Nodes    []*getIssueLabelIssueLabelIssuesIssueConnectionNodesIssue `json:"nodes"`
}

// GetPageInfo returns getIssueLabelIssueLabelIssuesIssueConnection.PageInfo, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelIssuesIssueConnection) GetPageInfo() *getIssueLabelIssueLabelIssuesIssueConnectionPageInfo {
	return v.PageInfo
}

// GetNodes returns getIssueLabelIssueLabelIssuesIssueConnection.Nodes, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelIssuesIssueConnection) GetNodes() []*getIssueLabelIssueLabelIssuesIssueConnectionNodesIssue {
	return v.Nodes
}

// getIssueLabelIssueLabelIssuesIssueConnectionNodesIssue includes the requested fields of the GraphQL type Issue.
// The GraphQL type's documentation follows.
//
// An issue.
type getIssueLabelIssueLabelIssuesIssueConnectionNodesIssue struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
}

// GetId returns getIssueLabelIssueLabelIssuesIssueConnectionNodesIssue.Id, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelIssuesIssueConnectionNodesIssue) GetId() *string { return v.Id }

// getIssueLabelIssueLabelIssuesIssueConnectionPageInfo includes the requested fields of the GraphQL type PageInfo.
type getIssueLabelIssueLabelIssuesIssueConnectionPageInfo struct {
	// Indicates if there are more results when paginating forward.
	HasNextPage *bool `json:"hasNextPage"`
	// Cursor representing the last result in the paginated results.
	EndCursor *string `json:"endCursor"`
}

// GetHasNextPage returns getIssueLabelIssueLabelIssuesIssueConnectionPageInfo.HasNextPage, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelIssuesIssueConnectionPageInfo) GetHasNextPage() *bool {
	return v.HasNextPage
}

// GetEndCursor returns getIssueLabelIssueLabelIssuesIssueConnectionPageInfo.EndCursor, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelIssuesIssueConnectionPageInfo) GetEndCursor() *string {
	return v.EndCursor
}

// getIssueLabelIssueLabelOrganization includes the requested fields of the GraphQL type Organization.
// The GraphQL type's documentation follows.
//
// An organization. Organizations are root-level objects that contain user accounts and teams.
type getIssueLabelIssueLabelOrganization struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// Allowed authentication providers, empty array means all are allowed
	AllowedAuthServices []*string `json:"allowedAuthServices"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Number of issues in the organization.
	CreatedIssueCount *int `json:"createdIssueCount"`
	// The time at which deletion of the organization was requested.
	DeletionRequestedAt *time.Time `json:"-"`
	// How git branches are formatted. If null, default formatting will be used.
	GitBranchFormat *string `json:"gitBranchFormat"`
	// Whether the Git integration linkback messages should be sent to private repositories.
	GitLinkbackMessagesEnabled *bool `json:"gitLinkbackMessagesEnabled"`
	// Whether the Git integration linkback messages should be sent to public repositories.
	GitPublicLinkbackMessagesEnabled *bool `json:"gitPublicLinkbackMessagesEnabled"`
	// The organization's logo URL.
	LogoUrl *string `json:"logoUrl"`
	// The organization's name.
	Name *string `json:"name"`
	// Rolling 30-day total upload volume for the organization, in megabytes.
	PeriodUploadVolume *float64 `json:"periodUploadVolume"`
	// Previously used URL keys for the organization (last 3 are kept and redirected).
	PreviousUrlKeys []*string `json:"previousUrlKeys"`
	// The day at which to prompt for project updates.
	ProjectUpdateRemindersDay *Day `json:"projectUpdateRemindersDay"`
	// The hour at which to prompt for project updates.
	ProjectUpdateRemindersHour *float64 `json:"projectUpdateRemindersHour"`
	// The frequency at which to prompt for project updates.
	ProjectUpdatesReminderFrequency *ProjectUpdateReminderFrequency `json:"projectUpdatesReminderFrequency"`
	// The feature release channel the organization belongs to.
	ReleaseChannel *ReleaseChannel `json:"releaseChannel"`
	// Whether the organization is using a roadmap.
	RoadmapEnabled *bool `json:"roadmapEnabled"`
	// Whether SAML authentication is enabled for organization.
	SamlEnabled *bool `json:"samlEnabled"`
	// Whether SCIM provisioning is enabled for organization.
	ScimEnabled *bool `json:"scimEnabled"`
	// The time at which the trial of the plus plan will end.
	TrialEndsAt *time.Time `json:"-"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// The organization's unique URL key.
	UrlKey *string `json:"urlKey"`
	// Number of active users in the organization.
	UserCount *int `json:"userCount"`
}

// GetId returns getIssueLabelIssueLabelOrganization.Id, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelOrganization) GetId() *string { return v.Id }

// GetAllowedAuthServices returns getIssueLabelIssueLabelOrganization.AllowedAuthServices, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelOrganization) GetAllowedAuthServices() []*string {
	return v.AllowedAuthServices
}

// GetArchivedAt returns getIssueLabelIssueLabelOrganization.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelOrganization) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetCreatedAt returns getIssueLabelIssueLabelOrganization.CreatedAt, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelOrganization) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetCreatedIssueCount returns getIssueLabelIssueLabelOrganization.CreatedIssueCount, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelOrganization) GetCreatedIssueCount() *int { return v.CreatedIssueCount }

// GetDeletionRequestedAt returns getIssueLabelIssueLabelOrganization.DeletionRequestedAt, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelOrganization) GetDeletionRequestedAt() *time.Time {
	return v.DeletionRequestedAt
}

// GetGitBranchFormat returns getIssueLabelIssueLabelOrganization.GitBranchFormat, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelOrganization) GetGitBranchFormat() *string { return v.GitBranchFormat }

// GetGitLinkbackMessagesEnabled returns getIssueLabelIssueLabelOrganization.GitLinkbackMessagesEnabled, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelOrganization) GetGitLinkbackMessagesEnabled() *bool {
	return v.GitLinkbackMessagesEnabled
}

// GetGitPublicLinkbackMessagesEnabled returns getIssueLabelIssueLabelOrganization.GitPublicLinkbackMessagesEnabled, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelOrganization) GetGitPublicLinkbackMessagesEnabled() *bool {
	return v.GitPublicLinkbackMessagesEnabled
}

// GetLogoUrl returns getIssueLabelIssueLabelOrganization.LogoUrl, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelOrganization) GetLogoUrl() *string { return v.LogoUrl }

// GetName returns getIssueLabelIssueLabelOrganization.Name, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelOrganization) GetName() *string { return v.Name }

// GetPeriodUploadVolume returns getIssueLabelIssueLabelOrganization.PeriodUploadVolume, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelOrganization) GetPeriodUploadVolume() *float64 {
	return v.PeriodUploadVolume
}

// GetPreviousUrlKeys returns getIssueLabelIssueLabelOrganization.PreviousUrlKeys, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelOrganization) GetPreviousUrlKeys() []*string {
	return v.PreviousUrlKeys
}

// GetProjectUpdateRemindersDay returns getIssueLabelIssueLabelOrganization.ProjectUpdateRemindersDay, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelOrganization) GetProjectUpdateRemindersDay() *Day {
	return v.ProjectUpdateRemindersDay
}

// GetProjectUpdateRemindersHour returns getIssueLabelIssueLabelOrganization.ProjectUpdateRemindersHour, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelOrganization) GetProjectUpdateRemindersHour() *float64 {
	return v.ProjectUpdateRemindersHour
}

// GetProjectUpdatesReminderFrequency returns getIssueLabelIssueLabelOrganization.ProjectUpdatesReminderFrequency, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelOrganization) GetProjectUpdatesReminderFrequency() *ProjectUpdateReminderFrequency {
	return v.ProjectUpdatesReminderFrequency
}

// GetReleaseChannel returns getIssueLabelIssueLabelOrganization.ReleaseChannel, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelOrganization) GetReleaseChannel() *ReleaseChannel {
	return v.ReleaseChannel
}

// GetRoadmapEnabled returns getIssueLabelIssueLabelOrganization.RoadmapEnabled, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelOrganization) GetRoadmapEnabled() *bool { return v.RoadmapEnabled }

// GetSamlEnabled returns getIssueLabelIssueLabelOrganization.SamlEnabled, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelOrganization) GetSamlEnabled() *bool { return v.SamlEnabled }

// GetScimEnabled returns getIssueLabelIssueLabelOrganization.ScimEnabled, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelOrganization) GetScimEnabled() *bool { return v.ScimEnabled }

// GetTrialEndsAt returns getIssueLabelIssueLabelOrganization.TrialEndsAt, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelOrganization) GetTrialEndsAt() *time.Time { return v.TrialEndsAt }

// GetUpdatedAt returns getIssueLabelIssueLabelOrganization.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelOrganization) GetUpdatedAt() *time.Time { return v.UpdatedAt }

// GetUrlKey returns getIssueLabelIssueLabelOrganization.UrlKey, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelOrganization) GetUrlKey() *string { return v.UrlKey }

// GetUserCount returns getIssueLabelIssueLabelOrganization.UserCount, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelOrganization) GetUserCount() *int { return v.UserCount }

func (v *getIssueLabelIssueLabelOrganization) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getIssueLabelIssueLabelOrganization
		ArchivedAt          json.RawMessage `json:"archivedAt"`
		CreatedAt           json.RawMessage `json:"createdAt"`
		DeletionRequestedAt json.RawMessage `json:"deletionRequestedAt"`
		TrialEndsAt         json.RawMessage `json:"trialEndsAt"`
		UpdatedAt           json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getIssueLabelIssueLabelOrganization = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueLabelIssueLabelOrganization.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueLabelIssueLabelOrganization.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.DeletionRequestedAt
		src := firstPass.DeletionRequestedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueLabelIssueLabelOrganization.DeletionRequestedAt: %w", err)
			}
		}
	}

	{
		dst := &v.TrialEndsAt
		src := firstPass.TrialEndsAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueLabelIssueLabelOrganization.TrialEndsAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueLabelIssueLabelOrganization.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetIssueLabelIssueLabelOrganization struct {
	Id *string `json:"id"`

	AllowedAuthServices []*string `json:"allowedAuthServices"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CreatedIssueCount *int `json:"createdIssueCount"`

	DeletionRequestedAt json.RawMessage `json:"deletionRequestedAt"`

	GitBranchFormat *string `json:"gitBranchFormat"`

	GitLinkbackMessagesEnabled *bool `json:"gitLinkbackMessagesEnabled"`

	GitPublicLinkbackMessagesEnabled *bool `json:"gitPublicLinkbackMessagesEnabled"`

	LogoUrl *string `json:"logoUrl"`

	Name *string `json:"name"`

	PeriodUploadVolume *float64 `json:"periodUploadVolume"`

	PreviousUrlKeys []*string `json:"previousUrlKeys"`

	ProjectUpdateRemindersDay *Day `json:"projectUpdateRemindersDay"`

	ProjectUpdateRemindersHour *float64 `json:"projectUpdateRemindersHour"`

	ProjectUpdatesReminderFrequency *ProjectUpdateReminderFrequency `json:"projectUpdatesReminderFrequency"`

	ReleaseChannel *ReleaseChannel `json:"releaseChannel"`

	RoadmapEnabled *bool `json:"roadmapEnabled"`

	SamlEnabled *bool `json:"samlEnabled"`

	ScimEnabled *bool `json:"scimEnabled"`

	TrialEndsAt json.RawMessage `json:"trialEndsAt"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	UrlKey *string `json:"urlKey"`

	UserCount *int `json:"userCount"`
}

func (v *getIssueLabelIssueLabelOrganization) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getIssueLabelIssueLabelOrganization) __premarshalJSON() (*__premarshalgetIssueLabelIssueLabelOrganization, error) {
	var retval __premarshalgetIssueLabelIssueLabelOrganization

	retval.Id = v.Id
	retval.AllowedAuthServices = v.AllowedAuthServices
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueLabelIssueLabelOrganization.ArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueLabelIssueLabelOrganization.CreatedAt: %w", err)
			}
		}
	}
	retval.CreatedIssueCount = v.CreatedIssueCount
	{

		dst := &retval.DeletionRequestedAt
		src := v.DeletionRequestedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueLabelIssueLabelOrganization.DeletionRequestedAt: %w", err)
			}
		}
	}
	retval.GitBranchFormat = v.GitBranchFormat
	retval.GitLinkbackMessagesEnabled = v.GitLinkbackMessagesEnabled
	retval.GitPublicLinkbackMessagesEnabled = v.GitPublicLinkbackMessagesEnabled
	retval.LogoUrl = v.LogoUrl
	retval.Name = v.Name
	retval.PeriodUploadVolume = v.PeriodUploadVolume
	retval.PreviousUrlKeys = v.PreviousUrlKeys
	retval.ProjectUpdateRemindersDay = v.ProjectUpdateRemindersDay
	retval.ProjectUpdateRemindersHour = v.ProjectUpdateRemindersHour
	retval.ProjectUpdatesReminderFrequency = v.ProjectUpdatesReminderFrequency
	retval.ReleaseChannel = v.ReleaseChannel
	retval.RoadmapEnabled = v.RoadmapEnabled
	retval.SamlEnabled = v.SamlEnabled
	retval.ScimEnabled = v.ScimEnabled
	{

		dst := &retval.TrialEndsAt
		src := v.TrialEndsAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueLabelIssueLabelOrganization.TrialEndsAt: %w", err)
			}
		}
	}
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueLabelIssueLabelOrganization.UpdatedAt: %w", err)
			}
		}
	}
	retval.UrlKey = v.UrlKey
	retval.UserCount = v.UserCount
	return &retval, nil
}

// getIssueLabelIssueLabelParentIssueLabel includes the requested fields of the GraphQL type IssueLabel.
// The GraphQL type's documentation follows.
//
// Labels that can be associated with issues.
type getIssueLabelIssueLabelParentIssueLabel struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The label's color as a HEX string.
	Color *string `json:"color"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// The label's description.
	Description *string `json:"description"`
	// The label's name.
	Name *string `json:"name"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
}

// GetId returns getIssueLabelIssueLabelParentIssueLabel.Id, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelParentIssueLabel) GetId() *string { return v.Id }

// GetArchivedAt returns getIssueLabelIssueLabelParentIssueLabel.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelParentIssueLabel) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetColor returns getIssueLabelIssueLabelParentIssueLabel.Color, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelParentIssueLabel) GetColor() *string { return v.Color }

// GetCreatedAt returns getIssueLabelIssueLabelParentIssueLabel.CreatedAt, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelParentIssueLabel) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetDescription returns getIssueLabelIssueLabelParentIssueLabel.Description, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelParentIssueLabel) GetDescription() *string { return v.Description }

// GetName returns getIssueLabelIssueLabelParentIssueLabel.Name, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelParentIssueLabel) GetName() *string { return v.Name }

// GetUpdatedAt returns getIssueLabelIssueLabelParentIssueLabel.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelParentIssueLabel) GetUpdatedAt() *time.Time { return v.UpdatedAt }

func (v *getIssueLabelIssueLabelParentIssueLabel) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getIssueLabelIssueLabelParentIssueLabel
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getIssueLabelIssueLabelParentIssueLabel = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueLabelIssueLabelParentIssueLabel.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueLabelIssueLabelParentIssueLabel.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueLabelIssueLabelParentIssueLabel.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetIssueLabelIssueLabelParentIssueLabel struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	Color *string `json:"color"`

	CreatedAt json.RawMessage `json:"createdAt"`

	Description *string `json:"description"`

	Name *string `json:"name"`

	UpdatedAt json.RawMessage `json:"updatedAt"`
}

func (v *getIssueLabelIssueLabelParentIssueLabel) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getIssueLabelIssueLabelParentIssueLabel) __premarshalJSON() (*__premarshalgetIssueLabelIssueLabelParentIssueLabel, error) {
	var retval __premarshalgetIssueLabelIssueLabelParentIssueLabel

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueLabelIssueLabelParentIssueLabel.ArchivedAt: %w", err)
			}
		}
	}
	retval.Color = v.Color
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueLabelIssueLabelParentIssueLabel.CreatedAt: %w", err)
			}
		}
	}
	retval.Description = v.Description
	retval.Name = v.Name
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueLabelIssueLabelParentIssueLabel.UpdatedAt: %w", err)
			}
		}
	}
	return &retval, nil
}

// getIssueLabelIssueLabelTeam includes the requested fields of the GraphQL type Team.
// The GraphQL type's documentation follows.
//
// An organizational unit that contains issues.
type getIssueLabelIssueLabelTeam struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// Period after which automatically closed and completed issues are automatically archived in months.
	AutoArchivePeriod *float64 `json:"autoArchivePeriod"`
	// Period after which issues are automatically closed in months. Null/undefined means disabled.
	AutoClosePeriod *float64 `json:"autoClosePeriod"`
	// The canceled workflow state which auto closed issues will be set to. Defaults to the first canceled state.
	AutoCloseStateId *string `json:"autoCloseStateId"`
	// The team's color.
	Color *string `json:"color"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Calendar feed URL (iCal) for cycles.
	CycleCalenderUrl *string `json:"cycleCalenderUrl"`
	// The cooldown time after each cycle in weeks.
	CycleCooldownTime *float64 `json:"cycleCooldownTime"`
	// The duration of a cycle in weeks.
	CycleDuration *float64 `json:"cycleDuration"`
	// Auto assign completed issues to current cycle.
	CycleIssueAutoAssignCompleted *bool `json:"cycleIssueAutoAssignCompleted"`
	// Auto assign started issues to current cycle.
	CycleIssueAutoAssignStarted *bool `json:"cycleIssueAutoAssignStarted"`
	// Only allow issues issues with cycles in Active Issues.
	CycleLockToActive *bool `json:"cycleLockToActive"`
	// The day of the week that a new cycle starts.
	CycleStartDay *float64 `json:"cycleStartDay"`
	// Whether the team uses cycles.
	CyclesEnabled *bool `json:"cyclesEnabled"`
	// What to use as an default estimate for unestimated issues.
	DefaultIssueEstimate *float64 `json:"defaultIssueEstimate"`
	// The id of the default template to use for new issues created by members of the team.
	DefaultTemplateForMembersId *string `json:"defaultTemplateForMembersId"`
	// The id of the default template to use for new issues created by non-members of the team.
	DefaultTemplateForNonMembersId *string `json:"defaultTemplateForNonMembersId"`
	// The team's description.
	Description *string `json:"description"`
	// Whether to group recent issue history entries.
	GroupIssueHistory *bool `json:"groupIssueHistory"`
	// The icon of the team.
	Icon *string `json:"icon"`
	// Unique hash for the team to be used in invite URLs.
	InviteHash *string `json:"inviteHash"`
	// Whether to allow zeros in issues estimates.
	IssueEstimationAllowZero *bool `json:"issueEstimationAllowZero"`
	// Whether to add additional points to the estimate scale.
	IssueEstimationExtended *bool `json:"issueEstimationExtended"`
	// The issue estimation type to use.
	IssueEstimationType *string `json:"issueEstimationType"`
	// Whether issues without priority should be sorted first.
	IssueOrderingNoPriorityFirst *bool `json:"issueOrderingNoPriorityFirst"`
	// Whether to move issues to bottom of the column when changing state.
	IssueSortOrderDefaultToBottom *bool `json:"issueSortOrderDefaultToBottom"`
	// The team's unique key. The key is used in URLs.
	Key *string `json:"key"`
	// The team's name.
	Name *string `json:"name"`
	// Whether the team is private or not.
	Private *bool `json:"private"`
	// Whether an issue needs to have a priority set before leaving triage
	RequirePriorityToLeaveTriage *bool `json:"requirePriorityToLeaveTriage"`
	// Whether to send new issue comment notifications to Slack.
	SlackIssueComments *bool `json:"slackIssueComments"`
	// Whether to send new issue status updates to Slack.
	SlackIssueStatuses *bool `json:"slackIssueStatuses"`
	// Whether to send new issue notifications to Slack.
	SlackNewIssue *bool `json:"slackNewIssue"`
	// The timezone of the team. Defaults to "America/Los_Angeles"
	Timezone *string `json:"timezone"`
	// Whether triage mode is enabled for the team or not.
	TriageEnabled *bool `json:"triageEnabled"`
	// How many upcoming cycles to create.
	UpcomingCycleCount *float64 `json:"upcomingCycleCount"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
}

// GetId returns getIssueLabelIssueLabelTeam.Id, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelTeam) GetId() *string { return v.Id }

// GetArchivedAt returns getIssueLabelIssueLabelTeam.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelTeam) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetAutoArchivePeriod returns getIssueLabelIssueLabelTeam.AutoArchivePeriod, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelTeam) GetAutoArchivePeriod() *float64 { return v.AutoArchivePeriod }

// GetAutoClosePeriod returns getIssueLabelIssueLabelTeam.AutoClosePeriod, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelTeam) GetAutoClosePeriod() *float64 { return v.AutoClosePeriod }

// GetAutoCloseStateId returns getIssueLabelIssueLabelTeam.AutoCloseStateId, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelTeam) GetAutoCloseStateId() *string { return v.AutoCloseStateId }

// GetColor returns getIssueLabelIssueLabelTeam.Color, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelTeam) GetColor() *string { return v.Color }

// GetCreatedAt returns getIssueLabelIssueLabelTeam.CreatedAt, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelTeam) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetCycleCalenderUrl returns getIssueLabelIssueLabelTeam.CycleCalenderUrl, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelTeam) GetCycleCalenderUrl() *string { return v.CycleCalenderUrl }

// GetCycleCooldownTime returns getIssueLabelIssueLabelTeam.CycleCooldownTime, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelTeam) GetCycleCooldownTime() *float64 { return v.CycleCooldownTime }

// GetCycleDuration returns getIssueLabelIssueLabelTeam.CycleDuration, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelTeam) GetCycleDuration() *float64 { return v.CycleDuration }

// GetCycleIssueAutoAssignCompleted returns getIssueLabelIssueLabelTeam.CycleIssueAutoAssignCompleted, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelTeam) GetCycleIssueAutoAssignCompleted() *bool {
	return v.CycleIssueAutoAssignCompleted
}

// GetCycleIssueAutoAssignStarted returns getIssueLabelIssueLabelTeam.CycleIssueAutoAssignStarted, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelTeam) GetCycleIssueAutoAssignStarted() *bool {
	return v.CycleIssueAutoAssignStarted
}

// GetCycleLockToActive returns getIssueLabelIssueLabelTeam.CycleLockToActive, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelTeam) GetCycleLockToActive() *bool { return v.CycleLockToActive }

// GetCycleStartDay returns getIssueLabelIssueLabelTeam.CycleStartDay, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelTeam) GetCycleStartDay() *float64 { return v.CycleStartDay }

// GetCyclesEnabled returns getIssueLabelIssueLabelTeam.CyclesEnabled, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelTeam) GetCyclesEnabled() *bool { return v.CyclesEnabled }

// GetDefaultIssueEstimate returns getIssueLabelIssueLabelTeam.DefaultIssueEstimate, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelTeam) GetDefaultIssueEstimate() *float64 {
	return v.DefaultIssueEstimate
}

// GetDefaultTemplateForMembersId returns getIssueLabelIssueLabelTeam.DefaultTemplateForMembersId, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelTeam) GetDefaultTemplateForMembersId() *string {
	return v.DefaultTemplateForMembersId
}

// GetDefaultTemplateForNonMembersId returns getIssueLabelIssueLabelTeam.DefaultTemplateForNonMembersId, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelTeam) GetDefaultTemplateForNonMembersId() *string {
	return v.DefaultTemplateForNonMembersId
}

// GetDescription returns getIssueLabelIssueLabelTeam.Description, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelTeam) GetDescription() *string { return v.Description }

// GetGroupIssueHistory returns getIssueLabelIssueLabelTeam.GroupIssueHistory, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelTeam) GetGroupIssueHistory() *bool { return v.GroupIssueHistory }

// GetIcon returns getIssueLabelIssueLabelTeam.Icon, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelTeam) GetIcon() *string { return v.Icon }

// GetInviteHash returns getIssueLabelIssueLabelTeam.InviteHash, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelTeam) GetInviteHash() *string { return v.InviteHash }

// GetIssueEstimationAllowZero returns getIssueLabelIssueLabelTeam.IssueEstimationAllowZero, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelTeam) GetIssueEstimationAllowZero() *bool {
	return v.IssueEstimationAllowZero
}

// GetIssueEstimationExtended returns getIssueLabelIssueLabelTeam.IssueEstimationExtended, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelTeam) GetIssueEstimationExtended() *bool {
	return v.IssueEstimationExtended
}

// GetIssueEstimationType returns getIssueLabelIssueLabelTeam.IssueEstimationType, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelTeam) GetIssueEstimationType() *string { return v.IssueEstimationType }

// GetIssueOrderingNoPriorityFirst returns getIssueLabelIssueLabelTeam.IssueOrderingNoPriorityFirst, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelTeam) GetIssueOrderingNoPriorityFirst() *bool {
	return v.IssueOrderingNoPriorityFirst
}

// GetIssueSortOrderDefaultToBottom returns getIssueLabelIssueLabelTeam.IssueSortOrderDefaultToBottom, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelTeam) GetIssueSortOrderDefaultToBottom() *bool {
	return v.IssueSortOrderDefaultToBottom
}

// GetKey returns getIssueLabelIssueLabelTeam.Key, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelTeam) GetKey() *string { return v.Key }

// GetName returns getIssueLabelIssueLabelTeam.Name, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelTeam) GetName() *string { return v.Name }

// GetPrivate returns getIssueLabelIssueLabelTeam.Private, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelTeam) GetPrivate() *bool { return v.Private }

// GetRequirePriorityToLeaveTriage returns getIssueLabelIssueLabelTeam.RequirePriorityToLeaveTriage, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelTeam) GetRequirePriorityToLeaveTriage() *bool {
	return v.RequirePriorityToLeaveTriage
}

// GetSlackIssueComments returns getIssueLabelIssueLabelTeam.SlackIssueComments, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelTeam) GetSlackIssueComments() *bool { return v.SlackIssueComments }

// GetSlackIssueStatuses returns getIssueLabelIssueLabelTeam.SlackIssueStatuses, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelTeam) GetSlackIssueStatuses() *bool { return v.SlackIssueStatuses }

// GetSlackNewIssue returns getIssueLabelIssueLabelTeam.SlackNewIssue, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelTeam) GetSlackNewIssue() *bool { return v.SlackNewIssue }

// GetTimezone returns getIssueLabelIssueLabelTeam.Timezone, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelTeam) GetTimezone() *string { return v.Timezone }

// GetTriageEnabled returns getIssueLabelIssueLabelTeam.TriageEnabled, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelTeam) GetTriageEnabled() *bool { return v.TriageEnabled }

// GetUpcomingCycleCount returns getIssueLabelIssueLabelTeam.UpcomingCycleCount, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelTeam) GetUpcomingCycleCount() *float64 { return v.UpcomingCycleCount }

// GetUpdatedAt returns getIssueLabelIssueLabelTeam.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getIssueLabelIssueLabelTeam) GetUpdatedAt() *time.Time { return v.UpdatedAt }

func (v *getIssueLabelIssueLabelTeam) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getIssueLabelIssueLabelTeam
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getIssueLabelIssueLabelTeam = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueLabelIssueLabelTeam.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueLabelIssueLabelTeam.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getIssueLabelIssueLabelTeam.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetIssueLabelIssueLabelTeam struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AutoArchivePeriod *float64 `json:"autoArchivePeriod"`

	AutoClosePeriod *float64 `json:"autoClosePeriod"`

	AutoCloseStateId *string `json:"autoCloseStateId"`

	Color *string `json:"color"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CycleCalenderUrl *string `json:"cycleCalenderUrl"`

	CycleCooldownTime *float64 `json:"cycleCooldownTime"`

	CycleDuration *float64 `json:"cycleDuration"`

	CycleIssueAutoAssignCompleted *bool `json:"cycleIssueAutoAssignCompleted"`

	CycleIssueAutoAssignStarted *bool `json:"cycleIssueAutoAssignStarted"`

	CycleLockToActive *bool `json:"cycleLockToActive"`

	CycleStartDay *float64 `json:"cycleStartDay"`

	CyclesEnabled *bool `json:"cyclesEnabled"`

	DefaultIssueEstimate *float64 `json:"defaultIssueEstimate"`

	DefaultTemplateForMembersId *string `json:"defaultTemplateForMembersId"`

	DefaultTemplateForNonMembersId *string `json:"defaultTemplateForNonMembersId"`

	Description *string `json:"description"`

	GroupIssueHistory *bool `json:"groupIssueHistory"`

	Icon *string `json:"icon"`

	InviteHash *string `json:"inviteHash"`

	IssueEstimationAllowZero *bool `json:"issueEstimationAllowZero"`

	IssueEstimationExtended *bool `json:"issueEstimationExtended"`

	IssueEstimationType *string `json:"issueEstimationType"`

	IssueOrderingNoPriorityFirst *bool `json:"issueOrderingNoPriorityFirst"`

	IssueSortOrderDefaultToBottom *bool `json:"issueSortOrderDefaultToBottom"`

	Key *string `json:"key"`

	Name *string `json:"name"`

	Private *bool `json:"private"`

	RequirePriorityToLeaveTriage *bool `json:"requirePriorityToLeaveTriage"`

	SlackIssueComments *bool `json:"slackIssueComments"`

	SlackIssueStatuses *bool `json:"slackIssueStatuses"`

	SlackNewIssue *bool `json:"slackNewIssue"`

	Timezone *string `json:"timezone"`

	TriageEnabled *bool `json:"triageEnabled"`

	UpcomingCycleCount *float64 `json:"upcomingCycleCount"`

	UpdatedAt json.RawMessage `json:"updatedAt"`
}

func (v *getIssueLabelIssueLabelTeam) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getIssueLabelIssueLabelTeam) __premarshalJSON() (*__premarshalgetIssueLabelIssueLabelTeam, error) {
	var retval __premarshalgetIssueLabelIssueLabelTeam

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueLabelIssueLabelTeam.ArchivedAt: %w", err)
			}
		}
	}
	retval.AutoArchivePeriod = v.AutoArchivePeriod
	retval.AutoClosePeriod = v.AutoClosePeriod
	retval.AutoCloseStateId = v.AutoCloseStateId
	retval.Color = v.Color
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueLabelIssueLabelTeam.CreatedAt: %w", err)
			}
		}
	}
	retval.CycleCalenderUrl = v.CycleCalenderUrl
	retval.CycleCooldownTime = v.CycleCooldownTime
	retval.CycleDuration = v.CycleDuration
	retval.CycleIssueAutoAssignCompleted = v.CycleIssueAutoAssignCompleted
	retval.CycleIssueAutoAssignStarted = v.CycleIssueAutoAssignStarted
	retval.CycleLockToActive = v.CycleLockToActive
	retval.CycleStartDay = v.CycleStartDay
	retval.CyclesEnabled = v.CyclesEnabled
	retval.DefaultIssueEstimate = v.DefaultIssueEstimate
	retval.DefaultTemplateForMembersId = v.DefaultTemplateForMembersId
	retval.DefaultTemplateForNonMembersId = v.DefaultTemplateForNonMembersId
	retval.Description = v.Description
	retval.GroupIssueHistory = v.GroupIssueHistory
	retval.Icon = v.Icon
	retval.InviteHash = v.InviteHash
	retval.IssueEstimationAllowZero = v.IssueEstimationAllowZero
	retval.IssueEstimationExtended = v.IssueEstimationExtended
	retval.IssueEstimationType = v.IssueEstimationType
	retval.IssueOrderingNoPriorityFirst = v.IssueOrderingNoPriorityFirst
	retval.IssueSortOrderDefaultToBottom = v.IssueSortOrderDefaultToBottom
	retval.Key = v.Key
	retval.Name = v.Name
	retval.Private = v.Private
	retval.RequirePriorityToLeaveTriage = v.RequirePriorityToLeaveTriage
	retval.SlackIssueComments = v.SlackIssueComments
	retval.SlackIssueStatuses = v.SlackIssueStatuses
	retval.SlackNewIssue = v.SlackNewIssue
	retval.Timezone = v.Timezone
	retval.TriageEnabled = v.TriageEnabled
	retval.UpcomingCycleCount = v.UpcomingCycleCount
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getIssueLabelIssueLabelTeam.UpdatedAt: %w", err)
			}
		}
	}
	return &retval, nil
}

// getIssueLabelResponse is returned by getIssueLabel on success.
type getIssueLabelResponse struct {
	// One specific label.
	IssueLabel *getIssueLabelIssueLabel `json:"issueLabel"`
}

// GetIssueLabel returns getIssueLabelResponse.IssueLabel, and is useful for accessing the field via an interface.
func (v *getIssueLabelResponse) GetIssueLabel() *getIssueLabelIssueLabel { return v.IssueLabel }

// getIssueResponse is returned by getIssue on success.
type getIssueResponse struct {
	// One specific issue.
	Issue *getIssueIssue `json:"issue"`
}

// GetIssue returns getIssueResponse.Issue, and is useful for accessing the field via an interface.
func (v *getIssueResponse) GetIssue() *getIssueIssue { return v.Issue }

// getOrganizationOrganization includes the requested fields of the GraphQL type Organization.
// The GraphQL type's documentation follows.
//
// An organization. Organizations are root-level objects that contain user accounts and teams.
type getOrganizationOrganization struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// Allowed authentication providers, empty array means all are allowed
	AllowedAuthServices []*string `json:"allowedAuthServices"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Number of issues in the organization.
	CreatedIssueCount *int `json:"createdIssueCount"`
	// The time at which deletion of the organization was requested.
	DeletionRequestedAt *time.Time `json:"-"`
	// How git branches are formatted. If null, default formatting will be used.
	GitBranchFormat *string `json:"gitBranchFormat"`
	// Whether the Git integration linkback messages should be sent to private repositories.
	GitLinkbackMessagesEnabled *bool `json:"gitLinkbackMessagesEnabled"`
	// Whether the Git integration linkback messages should be sent to public repositories.
	GitPublicLinkbackMessagesEnabled *bool `json:"gitPublicLinkbackMessagesEnabled"`
	// The organization's logo URL.
	LogoUrl *string `json:"logoUrl"`
	// The organization's name.
	Name *string `json:"name"`
	// Rolling 30-day total upload volume for the organization, in megabytes.
	PeriodUploadVolume *float64 `json:"periodUploadVolume"`
	// Previously used URL keys for the organization (last 3 are kept and redirected).
	PreviousUrlKeys []*string `json:"previousUrlKeys"`
	// The day at which to prompt for project updates.
	ProjectUpdateRemindersDay *Day `json:"projectUpdateRemindersDay"`
	// The hour at which to prompt for project updates.
	ProjectUpdateRemindersHour *float64 `json:"projectUpdateRemindersHour"`
	// The frequency at which to prompt for project updates.
	ProjectUpdatesReminderFrequency *ProjectUpdateReminderFrequency `json:"projectUpdatesReminderFrequency"`
	// The feature release channel the organization belongs to.
	ReleaseChannel *ReleaseChannel `json:"releaseChannel"`
	// Whether the organization is using a roadmap.
	RoadmapEnabled *bool `json:"roadmapEnabled"`
	// Whether SAML authentication is enabled for organization.
	SamlEnabled *bool `json:"samlEnabled"`
	// Whether SCIM provisioning is enabled for organization.
	ScimEnabled *bool `json:"scimEnabled"`
	// The time at which the trial of the plus plan will end.
	TrialEndsAt *time.Time `json:"-"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// The organization's unique URL key.
	UrlKey *string `json:"urlKey"`
	// Number of active users in the organization.
	UserCount *int `json:"userCount"`
	// The organization's subscription to a paid plan.
	Subscription *getOrganizationOrganizationSubscriptionPaidSubscription `json:"subscription"`
}

// GetId returns getOrganizationOrganization.Id, and is useful for accessing the field via an interface.
func (v *getOrganizationOrganization) GetId() *string { return v.Id }

// GetAllowedAuthServices returns getOrganizationOrganization.AllowedAuthServices, and is useful for accessing the field via an interface.
func (v *getOrganizationOrganization) GetAllowedAuthServices() []*string {
	return v.AllowedAuthServices
}

// GetArchivedAt returns getOrganizationOrganization.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getOrganizationOrganization) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetCreatedAt returns getOrganizationOrganization.CreatedAt, and is useful for accessing the field via an interface.
func (v *getOrganizationOrganization) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetCreatedIssueCount returns getOrganizationOrganization.CreatedIssueCount, and is useful for accessing the field via an interface.
func (v *getOrganizationOrganization) GetCreatedIssueCount() *int { return v.CreatedIssueCount }

// GetDeletionRequestedAt returns getOrganizationOrganization.DeletionRequestedAt, and is useful for accessing the field via an interface.
func (v *getOrganizationOrganization) GetDeletionRequestedAt() *time.Time {
	return v.DeletionRequestedAt
}

// GetGitBranchFormat returns getOrganizationOrganization.GitBranchFormat, and is useful for accessing the field via an interface.
func (v *getOrganizationOrganization) GetGitBranchFormat() *string { return v.GitBranchFormat }

// GetGitLinkbackMessagesEnabled returns getOrganizationOrganization.GitLinkbackMessagesEnabled, and is useful for accessing the field via an interface.
func (v *getOrganizationOrganization) GetGitLinkbackMessagesEnabled() *bool {
	return v.GitLinkbackMessagesEnabled
}

// GetGitPublicLinkbackMessagesEnabled returns getOrganizationOrganization.GitPublicLinkbackMessagesEnabled, and is useful for accessing the field via an interface.
func (v *getOrganizationOrganization) GetGitPublicLinkbackMessagesEnabled() *bool {
	return v.GitPublicLinkbackMessagesEnabled
}

// GetLogoUrl returns getOrganizationOrganization.LogoUrl, and is useful for accessing the field via an interface.
func (v *getOrganizationOrganization) GetLogoUrl() *string { return v.LogoUrl }

// GetName returns getOrganizationOrganization.Name, and is useful for accessing the field via an interface.
func (v *getOrganizationOrganization) GetName() *string { return v.Name }

// GetPeriodUploadVolume returns getOrganizationOrganization.PeriodUploadVolume, and is useful for accessing the field via an interface.
func (v *getOrganizationOrganization) GetPeriodUploadVolume() *float64 { return v.PeriodUploadVolume }

// GetPreviousUrlKeys returns getOrganizationOrganization.PreviousUrlKeys, and is useful for accessing the field via an interface.
func (v *getOrganizationOrganization) GetPreviousUrlKeys() []*string { return v.PreviousUrlKeys }

// GetProjectUpdateRemindersDay returns getOrganizationOrganization.ProjectUpdateRemindersDay, and is useful for accessing the field via an interface.
func (v *getOrganizationOrganization) GetProjectUpdateRemindersDay() *Day {
	return v.ProjectUpdateRemindersDay
}

// GetProjectUpdateRemindersHour returns getOrganizationOrganization.ProjectUpdateRemindersHour, and is useful for accessing the field via an interface.
func (v *getOrganizationOrganization) GetProjectUpdateRemindersHour() *float64 {
	return v.ProjectUpdateRemindersHour
}

// GetProjectUpdatesReminderFrequency returns getOrganizationOrganization.ProjectUpdatesReminderFrequency, and is useful for accessing the field via an interface.
func (v *getOrganizationOrganization) GetProjectUpdatesReminderFrequency() *ProjectUpdateReminderFrequency {
	return v.ProjectUpdatesReminderFrequency
}

// GetReleaseChannel returns getOrganizationOrganization.ReleaseChannel, and is useful for accessing the field via an interface.
func (v *getOrganizationOrganization) GetReleaseChannel() *ReleaseChannel { return v.ReleaseChannel }

// GetRoadmapEnabled returns getOrganizationOrganization.RoadmapEnabled, and is useful for accessing the field via an interface.
func (v *getOrganizationOrganization) GetRoadmapEnabled() *bool { return v.RoadmapEnabled }

// GetSamlEnabled returns getOrganizationOrganization.SamlEnabled, and is useful for accessing the field via an interface.
func (v *getOrganizationOrganization) GetSamlEnabled() *bool { return v.SamlEnabled }

// GetScimEnabled returns getOrganizationOrganization.ScimEnabled, and is useful for accessing the field via an interface.
func (v *getOrganizationOrganization) GetScimEnabled() *bool { return v.ScimEnabled }

// GetTrialEndsAt returns getOrganizationOrganization.TrialEndsAt, and is useful for accessing the field via an interface.
func (v *getOrganizationOrganization) GetTrialEndsAt() *time.Time { return v.TrialEndsAt }

// GetUpdatedAt returns getOrganizationOrganization.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getOrganizationOrganization) GetUpdatedAt() *time.Time { return v.UpdatedAt }

// GetUrlKey returns getOrganizationOrganization.UrlKey, and is useful for accessing the field via an interface.
func (v *getOrganizationOrganization) GetUrlKey() *string { return v.UrlKey }

// GetUserCount returns getOrganizationOrganization.UserCount, and is useful for accessing the field via an interface.
func (v *getOrganizationOrganization) GetUserCount() *int { return v.UserCount }

// GetSubscription returns getOrganizationOrganization.Subscription, and is useful for accessing the field via an interface.
func (v *getOrganizationOrganization) GetSubscription() *getOrganizationOrganizationSubscriptionPaidSubscription {
	return v.Subscription
}

func (v *getOrganizationOrganization) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getOrganizationOrganization
		ArchivedAt          json.RawMessage `json:"archivedAt"`
		CreatedAt           json.RawMessage `json:"createdAt"`
		DeletionRequestedAt json.RawMessage `json:"deletionRequestedAt"`
		TrialEndsAt         json.RawMessage `json:"trialEndsAt"`
		UpdatedAt           json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getOrganizationOrganization = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getOrganizationOrganization.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getOrganizationOrganization.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.DeletionRequestedAt
		src := firstPass.DeletionRequestedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getOrganizationOrganization.DeletionRequestedAt: %w", err)
			}
		}
	}

	{
		dst := &v.TrialEndsAt
		src := firstPass.TrialEndsAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getOrganizationOrganization.TrialEndsAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getOrganizationOrganization.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetOrganizationOrganization struct {
	Id *string `json:"id"`

	AllowedAuthServices []*string `json:"allowedAuthServices"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CreatedIssueCount *int `json:"createdIssueCount"`

	DeletionRequestedAt json.RawMessage `json:"deletionRequestedAt"`

	GitBranchFormat *string `json:"gitBranchFormat"`

	GitLinkbackMessagesEnabled *bool `json:"gitLinkbackMessagesEnabled"`

	GitPublicLinkbackMessagesEnabled *bool `json:"gitPublicLinkbackMessagesEnabled"`

	LogoUrl *string `json:"logoUrl"`

	Name *string `json:"name"`

	PeriodUploadVolume *float64 `json:"periodUploadVolume"`

	PreviousUrlKeys []*string `json:"previousUrlKeys"`

	ProjectUpdateRemindersDay *Day `json:"projectUpdateRemindersDay"`

	ProjectUpdateRemindersHour *float64 `json:"projectUpdateRemindersHour"`

	ProjectUpdatesReminderFrequency *ProjectUpdateReminderFrequency `json:"projectUpdatesReminderFrequency"`

	ReleaseChannel *ReleaseChannel `json:"releaseChannel"`

	RoadmapEnabled *bool `json:"roadmapEnabled"`

	SamlEnabled *bool `json:"samlEnabled"`

	ScimEnabled *bool `json:"scimEnabled"`

	TrialEndsAt json.RawMessage `json:"trialEndsAt"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	UrlKey *string `json:"urlKey"`

	UserCount *int `json:"userCount"`

	Subscription *getOrganizationOrganizationSubscriptionPaidSubscription `json:"subscription"`
}

func (v *getOrganizationOrganization) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getOrganizationOrganization) __premarshalJSON() (*__premarshalgetOrganizationOrganization, error) {
	var retval __premarshalgetOrganizationOrganization

	retval.Id = v.Id
	retval.AllowedAuthServices = v.AllowedAuthServices
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getOrganizationOrganization.ArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getOrganizationOrganization.CreatedAt: %w", err)
			}
		}
	}
	retval.CreatedIssueCount = v.CreatedIssueCount
	{

		dst := &retval.DeletionRequestedAt
		src := v.DeletionRequestedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getOrganizationOrganization.DeletionRequestedAt: %w", err)
			}
		}
	}
	retval.GitBranchFormat = v.GitBranchFormat
	retval.GitLinkbackMessagesEnabled = v.GitLinkbackMessagesEnabled
	retval.GitPublicLinkbackMessagesEnabled = v.GitPublicLinkbackMessagesEnabled
	retval.LogoUrl = v.LogoUrl
	retval.Name = v.Name
	retval.PeriodUploadVolume = v.PeriodUploadVolume
	retval.PreviousUrlKeys = v.PreviousUrlKeys
	retval.ProjectUpdateRemindersDay = v.ProjectUpdateRemindersDay
	retval.ProjectUpdateRemindersHour = v.ProjectUpdateRemindersHour
	retval.ProjectUpdatesReminderFrequency = v.ProjectUpdatesReminderFrequency
	retval.ReleaseChannel = v.ReleaseChannel
	retval.RoadmapEnabled = v.RoadmapEnabled
	retval.SamlEnabled = v.SamlEnabled
	retval.ScimEnabled = v.ScimEnabled
	{

		dst := &retval.TrialEndsAt
		src := v.TrialEndsAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getOrganizationOrganization.TrialEndsAt: %w", err)
			}
		}
	}
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getOrganizationOrganization.UpdatedAt: %w", err)
			}
		}
	}
	retval.UrlKey = v.UrlKey
	retval.UserCount = v.UserCount
	retval.Subscription = v.Subscription
	return &retval, nil
}

// getOrganizationOrganizationSubscriptionPaidSubscription includes the requested fields of the GraphQL type PaidSubscription.
// The GraphQL type's documentation follows.
//
// The paid subscription of an organization.
type getOrganizationOrganizationSubscriptionPaidSubscription struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The date the subscription was canceled, if any.
	CanceledAt *time.Time `json:"-"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// The date the subscription will be billed next.
	NextBillingAt *time.Time `json:"-"`
	// The subscription type of a pending change. Null if no change pending.
	PendingChangeType *string `json:"pendingChangeType"`
	// The number of seats in the subscription.
	Seats *float64 `json:"seats"`
	// The maximum number of seats that will be billed in the subscription.
	SeatsMaximum *float64 `json:"seatsMaximum"`
	// The minimum number of seats that will be billed in the subscription.
	SeatsMinimum *float64 `json:"seatsMinimum"`
	// The subscription type.
	Type *string `json:"type"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
}

// GetId returns getOrganizationOrganizationSubscriptionPaidSubscription.Id, and is useful for accessing the field via an interface.
func (v *getOrganizationOrganizationSubscriptionPaidSubscription) GetId() *string { return v.Id }

// GetArchivedAt returns getOrganizationOrganizationSubscriptionPaidSubscription.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getOrganizationOrganizationSubscriptionPaidSubscription) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetCanceledAt returns getOrganizationOrganizationSubscriptionPaidSubscription.CanceledAt, and is useful for accessing the field via an interface.
func (v *getOrganizationOrganizationSubscriptionPaidSubscription) GetCanceledAt() *time.Time {
	return v.CanceledAt
}

// GetCreatedAt returns getOrganizationOrganizationSubscriptionPaidSubscription.CreatedAt, and is useful for accessing the field via an interface.
func (v *getOrganizationOrganizationSubscriptionPaidSubscription) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetNextBillingAt returns getOrganizationOrganizationSubscriptionPaidSubscription.NextBillingAt, and is useful for accessing the field via an interface.
func (v *getOrganizationOrganizationSubscriptionPaidSubscription) GetNextBillingAt() *time.Time {
	return v.NextBillingAt
}

// GetPendingChangeType returns getOrganizationOrganizationSubscriptionPaidSubscription.PendingChangeType, and is useful for accessing the field via an interface.
func (v *getOrganizationOrganizationSubscriptionPaidSubscription) GetPendingChangeType() *string {
	return v.PendingChangeType
}

// GetSeats returns getOrganizationOrganizationSubscriptionPaidSubscription.Seats, and is useful for accessing the field via an interface.
func (v *getOrganizationOrganizationSubscriptionPaidSubscription) GetSeats() *float64 { return v.Seats }

// GetSeatsMaximum returns getOrganizationOrganizationSubscriptionPaidSubscription.SeatsMaximum, and is useful for accessing the field via an interface.
func (v *getOrganizationOrganizationSubscriptionPaidSubscription) GetSeatsMaximum() *float64 {
	return v.SeatsMaximum
}

// GetSeatsMinimum returns getOrganizationOrganizationSubscriptionPaidSubscription.SeatsMinimum, and is useful for accessing the field via an interface.
func (v *getOrganizationOrganizationSubscriptionPaidSubscription) GetSeatsMinimum() *float64 {
	return v.SeatsMinimum
}

// GetType returns getOrganizationOrganizationSubscriptionPaidSubscription.Type, and is useful for accessing the field via an interface.
func (v *getOrganizationOrganizationSubscriptionPaidSubscription) GetType() *string { return v.Type }

// GetUpdatedAt returns getOrganizationOrganizationSubscriptionPaidSubscription.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getOrganizationOrganizationSubscriptionPaidSubscription) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

func (v *getOrganizationOrganizationSubscriptionPaidSubscription) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getOrganizationOrganizationSubscriptionPaidSubscription
		ArchivedAt    json.RawMessage `json:"archivedAt"`
		CanceledAt    json.RawMessage `json:"canceledAt"`
		CreatedAt     json.RawMessage `json:"createdAt"`
		NextBillingAt json.RawMessage `json:"nextBillingAt"`
		UpdatedAt     json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getOrganizationOrganizationSubscriptionPaidSubscription = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getOrganizationOrganizationSubscriptionPaidSubscription.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CanceledAt
		src := firstPass.CanceledAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getOrganizationOrganizationSubscriptionPaidSubscription.CanceledAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getOrganizationOrganizationSubscriptionPaidSubscription.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.NextBillingAt
		src := firstPass.NextBillingAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getOrganizationOrganizationSubscriptionPaidSubscription.NextBillingAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getOrganizationOrganizationSubscriptionPaidSubscription.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetOrganizationOrganizationSubscriptionPaidSubscription struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	CanceledAt json.RawMessage `json:"canceledAt"`

	CreatedAt json.RawMessage `json:"createdAt"`

	NextBillingAt json.RawMessage `json:"nextBillingAt"`

	PendingChangeType *string `json:"pendingChangeType"`

	Seats *float64 `json:"seats"`

	SeatsMaximum *float64 `json:"seatsMaximum"`

	SeatsMinimum *float64 `json:"seatsMinimum"`

	Type *string `json:"type"`

	UpdatedAt json.RawMessage `json:"updatedAt"`
}

func (v *getOrganizationOrganizationSubscriptionPaidSubscription) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getOrganizationOrganizationSubscriptionPaidSubscription) __premarshalJSON() (*__premarshalgetOrganizationOrganizationSubscriptionPaidSubscription, error) {
	var retval __premarshalgetOrganizationOrganizationSubscriptionPaidSubscription

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getOrganizationOrganizationSubscriptionPaidSubscription.ArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CanceledAt
		src := v.CanceledAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getOrganizationOrganizationSubscriptionPaidSubscription.CanceledAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getOrganizationOrganizationSubscriptionPaidSubscription.CreatedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.NextBillingAt
		src := v.NextBillingAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getOrganizationOrganizationSubscriptionPaidSubscription.NextBillingAt: %w", err)
			}
		}
	}
	retval.PendingChangeType = v.PendingChangeType
	retval.Seats = v.Seats
	retval.SeatsMaximum = v.SeatsMaximum
	retval.SeatsMinimum = v.SeatsMinimum
	retval.Type = v.Type
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getOrganizationOrganizationSubscriptionPaidSubscription.UpdatedAt: %w", err)
			}
		}
	}
	return &retval, nil
}

// getOrganizationResponse is returned by getOrganization on success.
type getOrganizationResponse struct {
	// The user's organization.
	Organization *getOrganizationOrganization `json:"organization"`
}

// GetOrganization returns getOrganizationResponse.Organization, and is useful for accessing the field via an interface.
func (v *getOrganizationResponse) GetOrganization() *getOrganizationOrganization {
	return v.Organization
}

// getProjectProject includes the requested fields of the GraphQL type Project.
// The GraphQL type's documentation follows.
//
// A project.
type getProjectProject struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The time at which the project was automatically archived by the auto pruning process.
	AutoArchivedAt *time.Time `json:"-"`
	// The time at which the project was moved into canceled state.
	CanceledAt *time.Time `json:"-"`
	// The project's color.
	Color *string `json:"color"`
	// The time at which the project was moved into completed state.
	CompletedAt *time.Time `json:"-"`
	// The number of completed issues in the project after each week.
	CompletedIssueCountHistory []*float64 `json:"completedIssueCountHistory"`
	// The number of completed estimation points after each week.
	CompletedScopeHistory []*float64 `json:"completedScopeHistory"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// The project's description.
	Description *string `json:"description"`
	// The icon of the project.
	Icon *string `json:"icon"`
	// The number of in progress estimation points after each week.
	InProgressScopeHistory []*float64 `json:"inProgressScopeHistory"`
	// The total number of issues in the project after each week.
	IssueCountHistory []*float64 `json:"issueCountHistory"`
	// The project's name.
	Name *string `json:"name"`
	// The overall progress of the project. This is the (completed estimate points + 0.25 * in progress estimate points) / total estimate points.
	Progress *float64 `json:"progress"`
	// The time until which project update reminders are paused.
	ProjectUpdateRemindersPausedUntilAt *time.Time `json:"-"`
	// The overall scope (total estimate points) of the project.
	Scope *float64 `json:"scope"`
	// The total number of estimation points after each week.
	ScopeHistory []*float64 `json:"scopeHistory"`
	// Whether to send new issue comment notifications to Slack.
	SlackIssueComments *bool `json:"slackIssueComments"`
	// Whether to send new issue status updates to Slack.
	SlackIssueStatuses *bool `json:"slackIssueStatuses"`
	// Whether to send new issue notifications to Slack.
	SlackNewIssue *bool `json:"slackNewIssue"`
	// The project's unique URL slug.
	SlugId *string `json:"slugId"`
	// The sort order for the project within the organization.
	SortOrder *float64 `json:"sortOrder"`
	// [Internal] The estimated start date of the project.
	StartDate *time.Time `json:"-"`
	// The time at which the project was moved into started state.
	StartedAt *time.Time `json:"-"`
	// The type of the state.
	State *string `json:"state"`
	// The estimated completion date of the project.
	TargetDate *time.Time `json:"-"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// Project URL.
	Url *string `json:"url"`
	// The project was created based on this issue.
	ConvertedFromIssue *getProjectProjectConvertedFromIssue `json:"convertedFromIssue"`
	// Settings for all integrations associated with that project.
	IntegrationsSettings *getProjectProjectIntegrationsSettings `json:"integrationsSettings"`
	// The user who created the project.
	Creator *getProjectProjectCreatorUser `json:"creator"`
	// The project lead.
	Lead *getProjectProjectLeadUser `json:"lead"`
}

// GetId returns getProjectProject.Id, and is useful for accessing the field via an interface.
func (v *getProjectProject) GetId() *string { return v.Id }

// GetArchivedAt returns getProjectProject.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getProjectProject) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetAutoArchivedAt returns getProjectProject.AutoArchivedAt, and is useful for accessing the field via an interface.
func (v *getProjectProject) GetAutoArchivedAt() *time.Time { return v.AutoArchivedAt }

// GetCanceledAt returns getProjectProject.CanceledAt, and is useful for accessing the field via an interface.
func (v *getProjectProject) GetCanceledAt() *time.Time { return v.CanceledAt }

// GetColor returns getProjectProject.Color, and is useful for accessing the field via an interface.
func (v *getProjectProject) GetColor() *string { return v.Color }

// GetCompletedAt returns getProjectProject.CompletedAt, and is useful for accessing the field via an interface.
func (v *getProjectProject) GetCompletedAt() *time.Time { return v.CompletedAt }

// GetCompletedIssueCountHistory returns getProjectProject.CompletedIssueCountHistory, and is useful for accessing the field via an interface.
func (v *getProjectProject) GetCompletedIssueCountHistory() []*float64 {
	return v.CompletedIssueCountHistory
}

// GetCompletedScopeHistory returns getProjectProject.CompletedScopeHistory, and is useful for accessing the field via an interface.
func (v *getProjectProject) GetCompletedScopeHistory() []*float64 { return v.CompletedScopeHistory }

// GetCreatedAt returns getProjectProject.CreatedAt, and is useful for accessing the field via an interface.
func (v *getProjectProject) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetDescription returns getProjectProject.Description, and is useful for accessing the field via an interface.
func (v *getProjectProject) GetDescription() *string { return v.Description }

// GetIcon returns getProjectProject.Icon, and is useful for accessing the field via an interface.
func (v *getProjectProject) GetIcon() *string { return v.Icon }

// GetInProgressScopeHistory returns getProjectProject.InProgressScopeHistory, and is useful for accessing the field via an interface.
func (v *getProjectProject) GetInProgressScopeHistory() []*float64 { return v.InProgressScopeHistory }

// GetIssueCountHistory returns getProjectProject.IssueCountHistory, and is useful for accessing the field via an interface.
func (v *getProjectProject) GetIssueCountHistory() []*float64 { return v.IssueCountHistory }

// GetName returns getProjectProject.Name, and is useful for accessing the field via an interface.
func (v *getProjectProject) GetName() *string { return v.Name }

// GetProgress returns getProjectProject.Progress, and is useful for accessing the field via an interface.
func (v *getProjectProject) GetProgress() *float64 { return v.Progress }

// GetProjectUpdateRemindersPausedUntilAt returns getProjectProject.ProjectUpdateRemindersPausedUntilAt, and is useful for accessing the field via an interface.
func (v *getProjectProject) GetProjectUpdateRemindersPausedUntilAt() *time.Time {
	return v.ProjectUpdateRemindersPausedUntilAt
}

// GetScope returns getProjectProject.Scope, and is useful for accessing the field via an interface.
func (v *getProjectProject) GetScope() *float64 { return v.Scope }

// GetScopeHistory returns getProjectProject.ScopeHistory, and is useful for accessing the field via an interface.
func (v *getProjectProject) GetScopeHistory() []*float64 { return v.ScopeHistory }

// GetSlackIssueComments returns getProjectProject.SlackIssueComments, and is useful for accessing the field via an interface.
func (v *getProjectProject) GetSlackIssueComments() *bool { return v.SlackIssueComments }

// GetSlackIssueStatuses returns getProjectProject.SlackIssueStatuses, and is useful for accessing the field via an interface.
func (v *getProjectProject) GetSlackIssueStatuses() *bool { return v.SlackIssueStatuses }

// GetSlackNewIssue returns getProjectProject.SlackNewIssue, and is useful for accessing the field via an interface.
func (v *getProjectProject) GetSlackNewIssue() *bool { return v.SlackNewIssue }

// GetSlugId returns getProjectProject.SlugId, and is useful for accessing the field via an interface.
func (v *getProjectProject) GetSlugId() *string { return v.SlugId }

// GetSortOrder returns getProjectProject.SortOrder, and is useful for accessing the field via an interface.
func (v *getProjectProject) GetSortOrder() *float64 { return v.SortOrder }

// GetStartDate returns getProjectProject.StartDate, and is useful for accessing the field via an interface.
func (v *getProjectProject) GetStartDate() *time.Time { return v.StartDate }

// GetStartedAt returns getProjectProject.StartedAt, and is useful for accessing the field via an interface.
func (v *getProjectProject) GetStartedAt() *time.Time { return v.StartedAt }

// GetState returns getProjectProject.State, and is useful for accessing the field via an interface.
func (v *getProjectProject) GetState() *string { return v.State }

// GetTargetDate returns getProjectProject.TargetDate, and is useful for accessing the field via an interface.
func (v *getProjectProject) GetTargetDate() *time.Time { return v.TargetDate }

// GetUpdatedAt returns getProjectProject.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getProjectProject) GetUpdatedAt() *time.Time { return v.UpdatedAt }

// GetUrl returns getProjectProject.Url, and is useful for accessing the field via an interface.
func (v *getProjectProject) GetUrl() *string { return v.Url }

// GetConvertedFromIssue returns getProjectProject.ConvertedFromIssue, and is useful for accessing the field via an interface.
func (v *getProjectProject) GetConvertedFromIssue() *getProjectProjectConvertedFromIssue {
	return v.ConvertedFromIssue
}

// GetIntegrationsSettings returns getProjectProject.IntegrationsSettings, and is useful for accessing the field via an interface.
func (v *getProjectProject) GetIntegrationsSettings() *getProjectProjectIntegrationsSettings {
	return v.IntegrationsSettings
}

// GetCreator returns getProjectProject.Creator, and is useful for accessing the field via an interface.
func (v *getProjectProject) GetCreator() *getProjectProjectCreatorUser { return v.Creator }

// GetLead returns getProjectProject.Lead, and is useful for accessing the field via an interface.
func (v *getProjectProject) GetLead() *getProjectProjectLeadUser { return v.Lead }

func (v *getProjectProject) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getProjectProject
		ArchivedAt                          json.RawMessage `json:"archivedAt"`
		AutoArchivedAt                      json.RawMessage `json:"autoArchivedAt"`
		CanceledAt                          json.RawMessage `json:"canceledAt"`
		CompletedAt                         json.RawMessage `json:"completedAt"`
		CreatedAt                           json.RawMessage `json:"createdAt"`
		ProjectUpdateRemindersPausedUntilAt json.RawMessage `json:"projectUpdateRemindersPausedUntilAt"`
		StartDate                           json.RawMessage `json:"startDate"`
		StartedAt                           json.RawMessage `json:"startedAt"`
		TargetDate                          json.RawMessage `json:"targetDate"`
		UpdatedAt                           json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getProjectProject = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getProjectProject.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.AutoArchivedAt
		src := firstPass.AutoArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getProjectProject.AutoArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CanceledAt
		src := firstPass.CanceledAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getProjectProject.CanceledAt: %w", err)
			}
		}
	}

	{
		dst := &v.CompletedAt
		src := firstPass.CompletedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getProjectProject.CompletedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getProjectProject.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.ProjectUpdateRemindersPausedUntilAt
		src := firstPass.ProjectUpdateRemindersPausedUntilAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getProjectProject.ProjectUpdateRemindersPausedUntilAt: %w", err)
			}
		}
	}

	{
		dst := &v.StartDate
		src := firstPass.StartDate
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getProjectProject.StartDate: %w", err)
			}
		}
	}

	{
		dst := &v.StartedAt
		src := firstPass.StartedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getProjectProject.StartedAt: %w", err)
			}
		}
	}

	{
		dst := &v.TargetDate
		src := firstPass.TargetDate
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getProjectProject.TargetDate: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getProjectProject.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetProjectProject struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AutoArchivedAt json.RawMessage `json:"autoArchivedAt"`

	CanceledAt json.RawMessage `json:"canceledAt"`

	Color *string `json:"color"`

	CompletedAt json.RawMessage `json:"completedAt"`

	CompletedIssueCountHistory []*float64 `json:"completedIssueCountHistory"`

	CompletedScopeHistory []*float64 `json:"completedScopeHistory"`

	CreatedAt json.RawMessage `json:"createdAt"`

	Description *string `json:"description"`

	Icon *string `json:"icon"`

	InProgressScopeHistory []*float64 `json:"inProgressScopeHistory"`

	IssueCountHistory []*float64 `json:"issueCountHistory"`

	Name *string `json:"name"`

	Progress *float64 `json:"progress"`

	ProjectUpdateRemindersPausedUntilAt json.RawMessage `json:"projectUpdateRemindersPausedUntilAt"`

	Scope *float64 `json:"scope"`

	ScopeHistory []*float64 `json:"scopeHistory"`

	SlackIssueComments *bool `json:"slackIssueComments"`

	SlackIssueStatuses *bool `json:"slackIssueStatuses"`

	SlackNewIssue *bool `json:"slackNewIssue"`

	SlugId *string `json:"slugId"`

	SortOrder *float64 `json:"sortOrder"`

	StartDate json.RawMessage `json:"startDate"`

	StartedAt json.RawMessage `json:"startedAt"`

	State *string `json:"state"`

	TargetDate json.RawMessage `json:"targetDate"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	Url *string `json:"url"`

	ConvertedFromIssue *getProjectProjectConvertedFromIssue `json:"convertedFromIssue"`

	IntegrationsSettings *getProjectProjectIntegrationsSettings `json:"integrationsSettings"`

	Creator *getProjectProjectCreatorUser `json:"creator"`

	Lead *getProjectProjectLeadUser `json:"lead"`
}

func (v *getProjectProject) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getProjectProject) __premarshalJSON() (*__premarshalgetProjectProject, error) {
	var retval __premarshalgetProjectProject

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getProjectProject.ArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.AutoArchivedAt
		src := v.AutoArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getProjectProject.AutoArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CanceledAt
		src := v.CanceledAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getProjectProject.CanceledAt: %w", err)
			}
		}
	}
	retval.Color = v.Color
	{

		dst := &retval.CompletedAt
		src := v.CompletedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getProjectProject.CompletedAt: %w", err)
			}
		}
	}
	retval.CompletedIssueCountHistory = v.CompletedIssueCountHistory
	retval.CompletedScopeHistory = v.CompletedScopeHistory
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getProjectProject.CreatedAt: %w", err)
			}
		}
	}
	retval.Description = v.Description
	retval.Icon = v.Icon
	retval.InProgressScopeHistory = v.InProgressScopeHistory
	retval.IssueCountHistory = v.IssueCountHistory
	retval.Name = v.Name
	retval.Progress = v.Progress
	{

		dst := &retval.ProjectUpdateRemindersPausedUntilAt
		src := v.ProjectUpdateRemindersPausedUntilAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getProjectProject.ProjectUpdateRemindersPausedUntilAt: %w", err)
			}
		}
	}
	retval.Scope = v.Scope
	retval.ScopeHistory = v.ScopeHistory
	retval.SlackIssueComments = v.SlackIssueComments
	retval.SlackIssueStatuses = v.SlackIssueStatuses
	retval.SlackNewIssue = v.SlackNewIssue
	retval.SlugId = v.SlugId
	retval.SortOrder = v.SortOrder
	{

		dst := &retval.StartDate
		src := v.StartDate
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getProjectProject.StartDate: %w", err)
			}
		}
	}
	{

		dst := &retval.StartedAt
		src := v.StartedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getProjectProject.StartedAt: %w", err)
			}
		}
	}
	retval.State = v.State
	{

		dst := &retval.TargetDate
		src := v.TargetDate
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getProjectProject.TargetDate: %w", err)
			}
		}
	}
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getProjectProject.UpdatedAt: %w", err)
			}
		}
	}
	retval.Url = v.Url
	retval.ConvertedFromIssue = v.ConvertedFromIssue
	retval.IntegrationsSettings = v.IntegrationsSettings
	retval.Creator = v.Creator
	retval.Lead = v.Lead
	return &retval, nil
}

// getProjectProjectConvertedFromIssue includes the requested fields of the GraphQL type Issue.
// The GraphQL type's documentation follows.
//
// An issue.
type getProjectProjectConvertedFromIssue struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The issue's unique number.
	Number *float64 `json:"number"`
	// The issue's title.
	Title *string `json:"title"`
	// The issue's description in markdown format.
	Description *string `json:"description"`
	// The priority of the issue. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low.
	Priority *float64 `json:"priority"`
	// The estimate of the complexity of the issue..
	Estimate *float64 `json:"estimate"`
	// The order of the item in relation to other items in the organization.
	SortOrder *float64 `json:"sortOrder"`
	// The time at which the issue was moved into started state.
	StartedAt *time.Time `json:"-"`
	// The time at which the issue was moved into completed state.
	CompletedAt *time.Time `json:"-"`
	// The time at which the issue was moved into canceled state.
	CanceledAt *time.Time `json:"-"`
	// The time at which the issue was automatically closed by the auto pruning process.
	AutoClosedAt *time.Time `json:"-"`
	// The time at which the issue was automatically archived by the auto pruning process.
	AutoArchivedAt *time.Time `json:"-"`
	// The date at which the issue is due.
	DueDate *time.Time `json:"-"`
	// A flag that indicates whether the issue is in the trash bin.
	Trashed *bool `json:"trashed"`
	// The time until an issue will be snoozed in Triage view.
	SnoozedUntilAt *time.Time `json:"-"`
	// Previous identifiers of the issue if it has been moved between teams.
	PreviousIdentifiers []*string `json:"previousIdentifiers"`
	// The order of the item in the sub-issue list. Only set if the issue has a parent.
	SubIssueSortOrder *float64 `json:"subIssueSortOrder"`
	// Label for the priority.
	PriorityLabel *string `json:"priorityLabel"`
	// Issue's human readable identifier (e.g. ENG-123).
	Identifier *string `json:"identifier"`
	// Issue URL.
	Url *string `json:"url"`
	// Suggested branch name for the issue.
	BranchName *string `json:"branchName"`
	// Returns the number of Attachment resources which are created by customer support ticketing systems (e.g. Zendesk).
	CustomerTicketCount *int `json:"customerTicketCount"`
}

// GetId returns getProjectProjectConvertedFromIssue.Id, and is useful for accessing the field via an interface.
func (v *getProjectProjectConvertedFromIssue) GetId() *string { return v.Id }

// GetCreatedAt returns getProjectProjectConvertedFromIssue.CreatedAt, and is useful for accessing the field via an interface.
func (v *getProjectProjectConvertedFromIssue) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetUpdatedAt returns getProjectProjectConvertedFromIssue.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getProjectProjectConvertedFromIssue) GetUpdatedAt() *time.Time { return v.UpdatedAt }

// GetArchivedAt returns getProjectProjectConvertedFromIssue.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getProjectProjectConvertedFromIssue) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetNumber returns getProjectProjectConvertedFromIssue.Number, and is useful for accessing the field via an interface.
func (v *getProjectProjectConvertedFromIssue) GetNumber() *float64 { return v.Number }

// GetTitle returns getProjectProjectConvertedFromIssue.Title, and is useful for accessing the field via an interface.
func (v *getProjectProjectConvertedFromIssue) GetTitle() *string { return v.Title }

// GetDescription returns getProjectProjectConvertedFromIssue.Description, and is useful for accessing the field via an interface.
func (v *getProjectProjectConvertedFromIssue) GetDescription() *string { return v.Description }

// GetPriority returns getProjectProjectConvertedFromIssue.Priority, and is useful for accessing the field via an interface.
func (v *getProjectProjectConvertedFromIssue) GetPriority() *float64 { return v.Priority }

// GetEstimate returns getProjectProjectConvertedFromIssue.Estimate, and is useful for accessing the field via an interface.
func (v *getProjectProjectConvertedFromIssue) GetEstimate() *float64 { return v.Estimate }

// GetSortOrder returns getProjectProjectConvertedFromIssue.SortOrder, and is useful for accessing the field via an interface.
func (v *getProjectProjectConvertedFromIssue) GetSortOrder() *float64 { return v.SortOrder }

// GetStartedAt returns getProjectProjectConvertedFromIssue.StartedAt, and is useful for accessing the field via an interface.
func (v *getProjectProjectConvertedFromIssue) GetStartedAt() *time.Time { return v.StartedAt }

// GetCompletedAt returns getProjectProjectConvertedFromIssue.CompletedAt, and is useful for accessing the field via an interface.
func (v *getProjectProjectConvertedFromIssue) GetCompletedAt() *time.Time { return v.CompletedAt }

// GetCanceledAt returns getProjectProjectConvertedFromIssue.CanceledAt, and is useful for accessing the field via an interface.
func (v *getProjectProjectConvertedFromIssue) GetCanceledAt() *time.Time { return v.CanceledAt }

// GetAutoClosedAt returns getProjectProjectConvertedFromIssue.AutoClosedAt, and is useful for accessing the field via an interface.
func (v *getProjectProjectConvertedFromIssue) GetAutoClosedAt() *time.Time { return v.AutoClosedAt }

// GetAutoArchivedAt returns getProjectProjectConvertedFromIssue.AutoArchivedAt, and is useful for accessing the field via an interface.
func (v *getProjectProjectConvertedFromIssue) GetAutoArchivedAt() *time.Time { return v.AutoArchivedAt }

// GetDueDate returns getProjectProjectConvertedFromIssue.DueDate, and is useful for accessing the field via an interface.
func (v *getProjectProjectConvertedFromIssue) GetDueDate() *time.Time { return v.DueDate }

// GetTrashed returns getProjectProjectConvertedFromIssue.Trashed, and is useful for accessing the field via an interface.
func (v *getProjectProjectConvertedFromIssue) GetTrashed() *bool { return v.Trashed }

// GetSnoozedUntilAt returns getProjectProjectConvertedFromIssue.SnoozedUntilAt, and is useful for accessing the field via an interface.
func (v *getProjectProjectConvertedFromIssue) GetSnoozedUntilAt() *time.Time { return v.SnoozedUntilAt }

// GetPreviousIdentifiers returns getProjectProjectConvertedFromIssue.PreviousIdentifiers, and is useful for accessing the field via an interface.
func (v *getProjectProjectConvertedFromIssue) GetPreviousIdentifiers() []*string {
	return v.PreviousIdentifiers
}

// GetSubIssueSortOrder returns getProjectProjectConvertedFromIssue.SubIssueSortOrder, and is useful for accessing the field via an interface.
func (v *getProjectProjectConvertedFromIssue) GetSubIssueSortOrder() *float64 {
	return v.SubIssueSortOrder
}

// GetPriorityLabel returns getProjectProjectConvertedFromIssue.PriorityLabel, and is useful for accessing the field via an interface.
func (v *getProjectProjectConvertedFromIssue) GetPriorityLabel() *string { return v.PriorityLabel }

// GetIdentifier returns getProjectProjectConvertedFromIssue.Identifier, and is useful for accessing the field via an interface.
func (v *getProjectProjectConvertedFromIssue) GetIdentifier() *string { return v.Identifier }

// GetUrl returns getProjectProjectConvertedFromIssue.Url, and is useful for accessing the field via an interface.
func (v *getProjectProjectConvertedFromIssue) GetUrl() *string { return v.Url }

// GetBranchName returns getProjectProjectConvertedFromIssue.BranchName, and is useful for accessing the field via an interface.
func (v *getProjectProjectConvertedFromIssue) GetBranchName() *string { return v.BranchName }

// GetCustomerTicketCount returns getProjectProjectConvertedFromIssue.CustomerTicketCount, and is useful for accessing the field via an interface.
func (v *getProjectProjectConvertedFromIssue) GetCustomerTicketCount() *int {
	return v.CustomerTicketCount
}

func (v *getProjectProjectConvertedFromIssue) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getProjectProjectConvertedFromIssue
		CreatedAt      json.RawMessage `json:"createdAt"`
		UpdatedAt      json.RawMessage `json:"updatedAt"`
		ArchivedAt     json.RawMessage `json:"archivedAt"`
		StartedAt      json.RawMessage `json:"startedAt"`
		CompletedAt    json.RawMessage `json:"completedAt"`
		CanceledAt     json.RawMessage `json:"canceledAt"`
		AutoClosedAt   json.RawMessage `json:"autoClosedAt"`
		AutoArchivedAt json.RawMessage `json:"autoArchivedAt"`
		DueDate        json.RawMessage `json:"dueDate"`
		SnoozedUntilAt json.RawMessage `json:"snoozedUntilAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getProjectProjectConvertedFromIssue = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getProjectProjectConvertedFromIssue.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getProjectProjectConvertedFromIssue.UpdatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getProjectProjectConvertedFromIssue.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.StartedAt
		src := firstPass.StartedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getProjectProjectConvertedFromIssue.StartedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CompletedAt
		src := firstPass.CompletedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getProjectProjectConvertedFromIssue.CompletedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CanceledAt
		src := firstPass.CanceledAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getProjectProjectConvertedFromIssue.CanceledAt: %w", err)
			}
		}
	}

	{
		dst := &v.AutoClosedAt
		src := firstPass.AutoClosedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getProjectProjectConvertedFromIssue.AutoClosedAt: %w", err)
			}
		}
	}

	{
		dst := &v.AutoArchivedAt
		src := firstPass.AutoArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getProjectProjectConvertedFromIssue.AutoArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.DueDate
		src := firstPass.DueDate
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getProjectProjectConvertedFromIssue.DueDate: %w", err)
			}
		}
	}

	{
		dst := &v.SnoozedUntilAt
		src := firstPass.SnoozedUntilAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getProjectProjectConvertedFromIssue.SnoozedUntilAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetProjectProjectConvertedFromIssue struct {
	Id *string `json:"id"`

	CreatedAt json.RawMessage `json:"createdAt"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	Number *float64 `json:"number"`

	Title *string `json:"title"`

	Description *string `json:"description"`

	Priority *float64 `json:"priority"`

	Estimate *float64 `json:"estimate"`

	SortOrder *float64 `json:"sortOrder"`

	StartedAt json.RawMessage `json:"startedAt"`

	CompletedAt json.RawMessage `json:"completedAt"`

	CanceledAt json.RawMessage `json:"canceledAt"`

	AutoClosedAt json.RawMessage `json:"autoClosedAt"`

	AutoArchivedAt json.RawMessage `json:"autoArchivedAt"`

	DueDate json.RawMessage `json:"dueDate"`

	Trashed *bool `json:"trashed"`

	SnoozedUntilAt json.RawMessage `json:"snoozedUntilAt"`

	PreviousIdentifiers []*string `json:"previousIdentifiers"`

	SubIssueSortOrder *float64 `json:"subIssueSortOrder"`

	PriorityLabel *string `json:"priorityLabel"`

	Identifier *string `json:"identifier"`

	Url *string `json:"url"`

	BranchName *string `json:"branchName"`

	CustomerTicketCount *int `json:"customerTicketCount"`
}

func (v *getProjectProjectConvertedFromIssue) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getProjectProjectConvertedFromIssue) __premarshalJSON() (*__premarshalgetProjectProjectConvertedFromIssue, error) {
	var retval __premarshalgetProjectProjectConvertedFromIssue

	retval.Id = v.Id
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getProjectProjectConvertedFromIssue.CreatedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getProjectProjectConvertedFromIssue.UpdatedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getProjectProjectConvertedFromIssue.ArchivedAt: %w", err)
			}
		}
	}
	retval.Number = v.Number
	retval.Title = v.Title
	retval.Description = v.Description
	retval.Priority = v.Priority
	retval.Estimate = v.Estimate
	retval.SortOrder = v.SortOrder
	{

		dst := &retval.StartedAt
		src := v.StartedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getProjectProjectConvertedFromIssue.StartedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CompletedAt
		src := v.CompletedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getProjectProjectConvertedFromIssue.CompletedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CanceledAt
		src := v.CanceledAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getProjectProjectConvertedFromIssue.CanceledAt: %w", err)
			}
		}
	}
	{

		dst := &retval.AutoClosedAt
		src := v.AutoClosedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getProjectProjectConvertedFromIssue.AutoClosedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.AutoArchivedAt
		src := v.AutoArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getProjectProjectConvertedFromIssue.AutoArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.DueDate
		src := v.DueDate
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getProjectProjectConvertedFromIssue.DueDate: %w", err)
			}
		}
	}
	retval.Trashed = v.Trashed
	{

		dst := &retval.SnoozedUntilAt
		src := v.SnoozedUntilAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getProjectProjectConvertedFromIssue.SnoozedUntilAt: %w", err)
			}
		}
	}
	retval.PreviousIdentifiers = v.PreviousIdentifiers
	retval.SubIssueSortOrder = v.SubIssueSortOrder
	retval.PriorityLabel = v.PriorityLabel
	retval.Identifier = v.Identifier
	retval.Url = v.Url
	retval.BranchName = v.BranchName
	retval.CustomerTicketCount = v.CustomerTicketCount
	return &retval, nil
}

// getProjectProjectCreatorUser includes the requested fields of the GraphQL type User.
// The GraphQL type's documentation follows.
//
// A user that has access to the the resources of an organization.
type getProjectProjectCreatorUser struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// Whether the user account is active or disabled (suspended).
	Active *bool `json:"active"`
	// Whether the user is an organization administrator.
	Admin *bool `json:"admin"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// An URL to the user's avatar image.
	AvatarUrl *string `json:"avatarUrl"`
	// [DEPRECATED] Hash for the user to be used in calendar URLs.
	CalendarHash *string `json:"calendarHash"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Number of issues created.
	CreatedIssueCount *int `json:"createdIssueCount"`
	// A short description of the user, either its title or bio.
	Description *string `json:"description"`
	// Reason why is the account disabled.
	DisableReason *string `json:"disableReason"`
	// The user's display (nick) name. Unique within each organization.
	DisplayName *string `json:"displayName"`
	// The user's email address.
	Email *string `json:"email"`
	// Whether the user is a guest in the workspace and limited to accessing a subset of teams.
	Guest *bool `json:"guest"`
	// Unique hash for the user to be used in invite URLs.
	InviteHash *string `json:"inviteHash"`
	// Whether the user is the currently authenticated user.
	IsMe *bool `json:"isMe"`
	// The last time the user was seen online. If null, the user is currently online.
	LastSeen *time.Time `json:"-"`
	// The user's full name.
	Name *string `json:"name"`
	// The emoji to represent the user current status.
	StatusEmoji *string `json:"statusEmoji"`
	// The label of the user current status.
	StatusLabel *string `json:"statusLabel"`
	// A date at which the user current status should be cleared.
	StatusUntilAt *time.Time `json:"-"`
	// The local timezone of the user.
	Timezone *string `json:"timezone"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// User's profile URL.
	Url *string `json:"url"`
}

// GetId returns getProjectProjectCreatorUser.Id, and is useful for accessing the field via an interface.
func (v *getProjectProjectCreatorUser) GetId() *string { return v.Id }

// GetActive returns getProjectProjectCreatorUser.Active, and is useful for accessing the field via an interface.
func (v *getProjectProjectCreatorUser) GetActive() *bool { return v.Active }

// GetAdmin returns getProjectProjectCreatorUser.Admin, and is useful for accessing the field via an interface.
func (v *getProjectProjectCreatorUser) GetAdmin() *bool { return v.Admin }

// GetArchivedAt returns getProjectProjectCreatorUser.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getProjectProjectCreatorUser) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetAvatarUrl returns getProjectProjectCreatorUser.AvatarUrl, and is useful for accessing the field via an interface.
func (v *getProjectProjectCreatorUser) GetAvatarUrl() *string { return v.AvatarUrl }

// GetCalendarHash returns getProjectProjectCreatorUser.CalendarHash, and is useful for accessing the field via an interface.
func (v *getProjectProjectCreatorUser) GetCalendarHash() *string { return v.CalendarHash }

// GetCreatedAt returns getProjectProjectCreatorUser.CreatedAt, and is useful for accessing the field via an interface.
func (v *getProjectProjectCreatorUser) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetCreatedIssueCount returns getProjectProjectCreatorUser.CreatedIssueCount, and is useful for accessing the field via an interface.
func (v *getProjectProjectCreatorUser) GetCreatedIssueCount() *int { return v.CreatedIssueCount }

// GetDescription returns getProjectProjectCreatorUser.Description, and is useful for accessing the field via an interface.
func (v *getProjectProjectCreatorUser) GetDescription() *string { return v.Description }

// GetDisableReason returns getProjectProjectCreatorUser.DisableReason, and is useful for accessing the field via an interface.
func (v *getProjectProjectCreatorUser) GetDisableReason() *string { return v.DisableReason }

// GetDisplayName returns getProjectProjectCreatorUser.DisplayName, and is useful for accessing the field via an interface.
func (v *getProjectProjectCreatorUser) GetDisplayName() *string { return v.DisplayName }

// GetEmail returns getProjectProjectCreatorUser.Email, and is useful for accessing the field via an interface.
func (v *getProjectProjectCreatorUser) GetEmail() *string { return v.Email }

// GetGuest returns getProjectProjectCreatorUser.Guest, and is useful for accessing the field via an interface.
func (v *getProjectProjectCreatorUser) GetGuest() *bool { return v.Guest }

// GetInviteHash returns getProjectProjectCreatorUser.InviteHash, and is useful for accessing the field via an interface.
func (v *getProjectProjectCreatorUser) GetInviteHash() *string { return v.InviteHash }

// GetIsMe returns getProjectProjectCreatorUser.IsMe, and is useful for accessing the field via an interface.
func (v *getProjectProjectCreatorUser) GetIsMe() *bool { return v.IsMe }

// GetLastSeen returns getProjectProjectCreatorUser.LastSeen, and is useful for accessing the field via an interface.
func (v *getProjectProjectCreatorUser) GetLastSeen() *time.Time { return v.LastSeen }

// GetName returns getProjectProjectCreatorUser.Name, and is useful for accessing the field via an interface.
func (v *getProjectProjectCreatorUser) GetName() *string { return v.Name }

// GetStatusEmoji returns getProjectProjectCreatorUser.StatusEmoji, and is useful for accessing the field via an interface.
func (v *getProjectProjectCreatorUser) GetStatusEmoji() *string { return v.StatusEmoji }

// GetStatusLabel returns getProjectProjectCreatorUser.StatusLabel, and is useful for accessing the field via an interface.
func (v *getProjectProjectCreatorUser) GetStatusLabel() *string { return v.StatusLabel }

// GetStatusUntilAt returns getProjectProjectCreatorUser.StatusUntilAt, and is useful for accessing the field via an interface.
func (v *getProjectProjectCreatorUser) GetStatusUntilAt() *time.Time { return v.StatusUntilAt }

// GetTimezone returns getProjectProjectCreatorUser.Timezone, and is useful for accessing the field via an interface.
func (v *getProjectProjectCreatorUser) GetTimezone() *string { return v.Timezone }

// GetUpdatedAt returns getProjectProjectCreatorUser.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getProjectProjectCreatorUser) GetUpdatedAt() *time.Time { return v.UpdatedAt }

// GetUrl returns getProjectProjectCreatorUser.Url, and is useful for accessing the field via an interface.
func (v *getProjectProjectCreatorUser) GetUrl() *string { return v.Url }

func (v *getProjectProjectCreatorUser) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getProjectProjectCreatorUser
		ArchivedAt    json.RawMessage `json:"archivedAt"`
		CreatedAt     json.RawMessage `json:"createdAt"`
		LastSeen      json.RawMessage `json:"lastSeen"`
		StatusUntilAt json.RawMessage `json:"statusUntilAt"`
		UpdatedAt     json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getProjectProjectCreatorUser = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getProjectProjectCreatorUser.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getProjectProjectCreatorUser.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.LastSeen
		src := firstPass.LastSeen
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getProjectProjectCreatorUser.LastSeen: %w", err)
			}
		}
	}

	{
		dst := &v.StatusUntilAt
		src := firstPass.StatusUntilAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getProjectProjectCreatorUser.StatusUntilAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getProjectProjectCreatorUser.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetProjectProjectCreatorUser struct {
	Id *string `json:"id"`

	Active *bool `json:"active"`

	Admin *bool `json:"admin"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AvatarUrl *string `json:"avatarUrl"`

	CalendarHash *string `json:"calendarHash"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CreatedIssueCount *int `json:"createdIssueCount"`

	Description *string `json:"description"`

	DisableReason *string `json:"disableReason"`

	DisplayName *string `json:"displayName"`

	Email *string `json:"email"`

	Guest *bool `json:"guest"`

	InviteHash *string `json:"inviteHash"`

	IsMe *bool `json:"isMe"`

	LastSeen json.RawMessage `json:"lastSeen"`

	Name *string `json:"name"`

	StatusEmoji *string `json:"statusEmoji"`

	StatusLabel *string `json:"statusLabel"`

	StatusUntilAt json.RawMessage `json:"statusUntilAt"`

	Timezone *string `json:"timezone"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	Url *string `json:"url"`
}

func (v *getProjectProjectCreatorUser) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getProjectProjectCreatorUser) __premarshalJSON() (*__premarshalgetProjectProjectCreatorUser, error) {
	var retval __premarshalgetProjectProjectCreatorUser

	retval.Id = v.Id
	retval.Active = v.Active
	retval.Admin = v.Admin
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getProjectProjectCreatorUser.ArchivedAt: %w", err)
			}
		}
	}
	retval.AvatarUrl = v.AvatarUrl
	retval.CalendarHash = v.CalendarHash
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getProjectProjectCreatorUser.CreatedAt: %w", err)
			}
		}
	}
	retval.CreatedIssueCount = v.CreatedIssueCount
	retval.Description = v.Description
	retval.DisableReason = v.DisableReason
	retval.DisplayName = v.DisplayName
	retval.Email = v.Email
	retval.Guest = v.Guest
	retval.InviteHash = v.InviteHash
	retval.IsMe = v.IsMe
	{

		dst := &retval.LastSeen
		src := v.LastSeen
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getProjectProjectCreatorUser.LastSeen: %w", err)
			}
		}
	}
	retval.Name = v.Name
	retval.StatusEmoji = v.StatusEmoji
	retval.StatusLabel = v.StatusLabel
	{

		dst := &retval.StatusUntilAt
		src := v.StatusUntilAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getProjectProjectCreatorUser.StatusUntilAt: %w", err)
			}
		}
	}
	retval.Timezone = v.Timezone
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getProjectProjectCreatorUser.UpdatedAt: %w", err)
			}
		}
	}
	retval.Url = v.Url
	return &retval, nil
}

// getProjectProjectIntegrationsSettings includes the requested fields of the GraphQL type IntegrationsSettings.
// The GraphQL type's documentation follows.
//
// The configuration of all integrations for a project or a team.
type getProjectProjectIntegrationsSettings struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Whether to send a Slack message when a new issue is added to triage.
	SlackIssueAddedToTriage *bool `json:"slackIssueAddedToTriage"`
	// Whether to send a Slack message when a new issue is created for the project or the team.
	SlackIssueCreated *bool `json:"slackIssueCreated"`
	// Whether to send a Slack message when a comment is created on any of the project or team's issues.
	SlackIssueNewComment *bool `json:"slackIssueNewComment"`
	// Whether to send a Slack message when an SLA is breached
	SlackIssueSlaBreached *bool `json:"slackIssueSlaBreached"`
	// Whether to send a Slack message when an SLA is at high risk
	SlackIssueSlaHighRisk *bool `json:"slackIssueSlaHighRisk"`
	// Whether to send a Slack message when any of the project or team's issues has a change in status.
	SlackIssueStatusChangedAll *bool `json:"slackIssueStatusChangedAll"`
	// Whether to send a Slack message when any of the project or team's issues change to completed or cancelled.
	SlackIssueStatusChangedDone *bool `json:"slackIssueStatusChangedDone"`
	// Whether to send a Slack message when a project update is created.
	SlackProjectUpdateCreated *bool `json:"slackProjectUpdateCreated"`
	// Whether to send a new project update to team Slack channels.
	SlackProjectUpdateCreatedToTeam *bool `json:"slackProjectUpdateCreatedToTeam"`
	// Whether to send a new project update to workspace Slack channel.
	SlackProjectUpdateCreatedToWorkspace *bool `json:"slackProjectUpdateCreatedToWorkspace"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
}

// GetId returns getProjectProjectIntegrationsSettings.Id, and is useful for accessing the field via an interface.
func (v *getProjectProjectIntegrationsSettings) GetId() *string { return v.Id }

// GetArchivedAt returns getProjectProjectIntegrationsSettings.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getProjectProjectIntegrationsSettings) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetCreatedAt returns getProjectProjectIntegrationsSettings.CreatedAt, and is useful for accessing the field via an interface.
func (v *getProjectProjectIntegrationsSettings) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetSlackIssueAddedToTriage returns getProjectProjectIntegrationsSettings.SlackIssueAddedToTriage, and is useful for accessing the field via an interface.
func (v *getProjectProjectIntegrationsSettings) GetSlackIssueAddedToTriage() *bool {
	return v.SlackIssueAddedToTriage
}

// GetSlackIssueCreated returns getProjectProjectIntegrationsSettings.SlackIssueCreated, and is useful for accessing the field via an interface.
func (v *getProjectProjectIntegrationsSettings) GetSlackIssueCreated() *bool {
	return v.SlackIssueCreated
}

// GetSlackIssueNewComment returns getProjectProjectIntegrationsSettings.SlackIssueNewComment, and is useful for accessing the field via an interface.
func (v *getProjectProjectIntegrationsSettings) GetSlackIssueNewComment() *bool {
	return v.SlackIssueNewComment
}

// GetSlackIssueSlaBreached returns getProjectProjectIntegrationsSettings.SlackIssueSlaBreached, and is useful for accessing the field via an interface.
func (v *getProjectProjectIntegrationsSettings) GetSlackIssueSlaBreached() *bool {
	return v.SlackIssueSlaBreached
}

// GetSlackIssueSlaHighRisk returns getProjectProjectIntegrationsSettings.SlackIssueSlaHighRisk, and is useful for accessing the field via an interface.
func (v *getProjectProjectIntegrationsSettings) GetSlackIssueSlaHighRisk() *bool {
	return v.SlackIssueSlaHighRisk
}

// GetSlackIssueStatusChangedAll returns getProjectProjectIntegrationsSettings.SlackIssueStatusChangedAll, and is useful for accessing the field via an interface.
func (v *getProjectProjectIntegrationsSettings) GetSlackIssueStatusChangedAll() *bool {
	return v.SlackIssueStatusChangedAll
}

// GetSlackIssueStatusChangedDone returns getProjectProjectIntegrationsSettings.SlackIssueStatusChangedDone, and is useful for accessing the field via an interface.
func (v *getProjectProjectIntegrationsSettings) GetSlackIssueStatusChangedDone() *bool {
	return v.SlackIssueStatusChangedDone
}

// GetSlackProjectUpdateCreated returns getProjectProjectIntegrationsSettings.SlackProjectUpdateCreated, and is useful for accessing the field via an interface.
func (v *getProjectProjectIntegrationsSettings) GetSlackProjectUpdateCreated() *bool {
	return v.SlackProjectUpdateCreated
}

// GetSlackProjectUpdateCreatedToTeam returns getProjectProjectIntegrationsSettings.SlackProjectUpdateCreatedToTeam, and is useful for accessing the field via an interface.
func (v *getProjectProjectIntegrationsSettings) GetSlackProjectUpdateCreatedToTeam() *bool {
	return v.SlackProjectUpdateCreatedToTeam
}

// GetSlackProjectUpdateCreatedToWorkspace returns getProjectProjectIntegrationsSettings.SlackProjectUpdateCreatedToWorkspace, and is useful for accessing the field via an interface.
func (v *getProjectProjectIntegrationsSettings) GetSlackProjectUpdateCreatedToWorkspace() *bool {
	return v.SlackProjectUpdateCreatedToWorkspace
}

// GetUpdatedAt returns getProjectProjectIntegrationsSettings.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getProjectProjectIntegrationsSettings) GetUpdatedAt() *time.Time { return v.UpdatedAt }

func (v *getProjectProjectIntegrationsSettings) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getProjectProjectIntegrationsSettings
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getProjectProjectIntegrationsSettings = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getProjectProjectIntegrationsSettings.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getProjectProjectIntegrationsSettings.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getProjectProjectIntegrationsSettings.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetProjectProjectIntegrationsSettings struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	CreatedAt json.RawMessage `json:"createdAt"`

	SlackIssueAddedToTriage *bool `json:"slackIssueAddedToTriage"`

	SlackIssueCreated *bool `json:"slackIssueCreated"`

	SlackIssueNewComment *bool `json:"slackIssueNewComment"`

	SlackIssueSlaBreached *bool `json:"slackIssueSlaBreached"`

	SlackIssueSlaHighRisk *bool `json:"slackIssueSlaHighRisk"`

	SlackIssueStatusChangedAll *bool `json:"slackIssueStatusChangedAll"`

	SlackIssueStatusChangedDone *bool `json:"slackIssueStatusChangedDone"`

	SlackProjectUpdateCreated *bool `json:"slackProjectUpdateCreated"`

	SlackProjectUpdateCreatedToTeam *bool `json:"slackProjectUpdateCreatedToTeam"`

	SlackProjectUpdateCreatedToWorkspace *bool `json:"slackProjectUpdateCreatedToWorkspace"`

	UpdatedAt json.RawMessage `json:"updatedAt"`
}

func (v *getProjectProjectIntegrationsSettings) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getProjectProjectIntegrationsSettings) __premarshalJSON() (*__premarshalgetProjectProjectIntegrationsSettings, error) {
	var retval __premarshalgetProjectProjectIntegrationsSettings

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getProjectProjectIntegrationsSettings.ArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getProjectProjectIntegrationsSettings.CreatedAt: %w", err)
			}
		}
	}
	retval.SlackIssueAddedToTriage = v.SlackIssueAddedToTriage
	retval.SlackIssueCreated = v.SlackIssueCreated
	retval.SlackIssueNewComment = v.SlackIssueNewComment
	retval.SlackIssueSlaBreached = v.SlackIssueSlaBreached
	retval.SlackIssueSlaHighRisk = v.SlackIssueSlaHighRisk
	retval.SlackIssueStatusChangedAll = v.SlackIssueStatusChangedAll
	retval.SlackIssueStatusChangedDone = v.SlackIssueStatusChangedDone
	retval.SlackProjectUpdateCreated = v.SlackProjectUpdateCreated
	retval.SlackProjectUpdateCreatedToTeam = v.SlackProjectUpdateCreatedToTeam
	retval.SlackProjectUpdateCreatedToWorkspace = v.SlackProjectUpdateCreatedToWorkspace
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getProjectProjectIntegrationsSettings.UpdatedAt: %w", err)
			}
		}
	}
	return &retval, nil
}

// getProjectProjectLeadUser includes the requested fields of the GraphQL type User.
// The GraphQL type's documentation follows.
//
// A user that has access to the the resources of an organization.
type getProjectProjectLeadUser struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// Whether the user account is active or disabled (suspended).
	Active *bool `json:"active"`
	// Whether the user is an organization administrator.
	Admin *bool `json:"admin"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// An URL to the user's avatar image.
	AvatarUrl *string `json:"avatarUrl"`
	// [DEPRECATED] Hash for the user to be used in calendar URLs.
	CalendarHash *string `json:"calendarHash"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Number of issues created.
	CreatedIssueCount *int `json:"createdIssueCount"`
	// A short description of the user, either its title or bio.
	Description *string `json:"description"`
	// Reason why is the account disabled.
	DisableReason *string `json:"disableReason"`
	// The user's display (nick) name. Unique within each organization.
	DisplayName *string `json:"displayName"`
	// The user's email address.
	Email *string `json:"email"`
	// Whether the user is a guest in the workspace and limited to accessing a subset of teams.
	Guest *bool `json:"guest"`
	// Unique hash for the user to be used in invite URLs.
	InviteHash *string `json:"inviteHash"`
	// Whether the user is the currently authenticated user.
	IsMe *bool `json:"isMe"`
	// The last time the user was seen online. If null, the user is currently online.
	LastSeen *time.Time `json:"-"`
	// The user's full name.
	Name *string `json:"name"`
	// The emoji to represent the user current status.
	StatusEmoji *string `json:"statusEmoji"`
	// The label of the user current status.
	StatusLabel *string `json:"statusLabel"`
	// A date at which the user current status should be cleared.
	StatusUntilAt *time.Time `json:"-"`
	// The local timezone of the user.
	Timezone *string `json:"timezone"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// User's profile URL.
	Url *string `json:"url"`
}

// GetId returns getProjectProjectLeadUser.Id, and is useful for accessing the field via an interface.
func (v *getProjectProjectLeadUser) GetId() *string { return v.Id }

// GetActive returns getProjectProjectLeadUser.Active, and is useful for accessing the field via an interface.
func (v *getProjectProjectLeadUser) GetActive() *bool { return v.Active }

// GetAdmin returns getProjectProjectLeadUser.Admin, and is useful for accessing the field via an interface.
func (v *getProjectProjectLeadUser) GetAdmin() *bool { return v.Admin }

// GetArchivedAt returns getProjectProjectLeadUser.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getProjectProjectLeadUser) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetAvatarUrl returns getProjectProjectLeadUser.AvatarUrl, and is useful for accessing the field via an interface.
func (v *getProjectProjectLeadUser) GetAvatarUrl() *string { return v.AvatarUrl }

// GetCalendarHash returns getProjectProjectLeadUser.CalendarHash, and is useful for accessing the field via an interface.
func (v *getProjectProjectLeadUser) GetCalendarHash() *string { return v.CalendarHash }

// GetCreatedAt returns getProjectProjectLeadUser.CreatedAt, and is useful for accessing the field via an interface.
func (v *getProjectProjectLeadUser) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetCreatedIssueCount returns getProjectProjectLeadUser.CreatedIssueCount, and is useful for accessing the field via an interface.
func (v *getProjectProjectLeadUser) GetCreatedIssueCount() *int { return v.CreatedIssueCount }

// GetDescription returns getProjectProjectLeadUser.Description, and is useful for accessing the field via an interface.
func (v *getProjectProjectLeadUser) GetDescription() *string { return v.Description }

// GetDisableReason returns getProjectProjectLeadUser.DisableReason, and is useful for accessing the field via an interface.
func (v *getProjectProjectLeadUser) GetDisableReason() *string { return v.DisableReason }

// GetDisplayName returns getProjectProjectLeadUser.DisplayName, and is useful for accessing the field via an interface.
func (v *getProjectProjectLeadUser) GetDisplayName() *string { return v.DisplayName }

// GetEmail returns getProjectProjectLeadUser.Email, and is useful for accessing the field via an interface.
func (v *getProjectProjectLeadUser) GetEmail() *string { return v.Email }

// GetGuest returns getProjectProjectLeadUser.Guest, and is useful for accessing the field via an interface.
func (v *getProjectProjectLeadUser) GetGuest() *bool { return v.Guest }

// GetInviteHash returns getProjectProjectLeadUser.InviteHash, and is useful for accessing the field via an interface.
func (v *getProjectProjectLeadUser) GetInviteHash() *string { return v.InviteHash }

// GetIsMe returns getProjectProjectLeadUser.IsMe, and is useful for accessing the field via an interface.
func (v *getProjectProjectLeadUser) GetIsMe() *bool { return v.IsMe }

// GetLastSeen returns getProjectProjectLeadUser.LastSeen, and is useful for accessing the field via an interface.
func (v *getProjectProjectLeadUser) GetLastSeen() *time.Time { return v.LastSeen }

// GetName returns getProjectProjectLeadUser.Name, and is useful for accessing the field via an interface.
func (v *getProjectProjectLeadUser) GetName() *string { return v.Name }

// GetStatusEmoji returns getProjectProjectLeadUser.StatusEmoji, and is useful for accessing the field via an interface.
func (v *getProjectProjectLeadUser) GetStatusEmoji() *string { return v.StatusEmoji }

// GetStatusLabel returns getProjectProjectLeadUser.StatusLabel, and is useful for accessing the field via an interface.
func (v *getProjectProjectLeadUser) GetStatusLabel() *string { return v.StatusLabel }

// GetStatusUntilAt returns getProjectProjectLeadUser.StatusUntilAt, and is useful for accessing the field via an interface.
func (v *getProjectProjectLeadUser) GetStatusUntilAt() *time.Time { return v.StatusUntilAt }

// GetTimezone returns getProjectProjectLeadUser.Timezone, and is useful for accessing the field via an interface.
func (v *getProjectProjectLeadUser) GetTimezone() *string { return v.Timezone }

// GetUpdatedAt returns getProjectProjectLeadUser.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getProjectProjectLeadUser) GetUpdatedAt() *time.Time { return v.UpdatedAt }

// GetUrl returns getProjectProjectLeadUser.Url, and is useful for accessing the field via an interface.
func (v *getProjectProjectLeadUser) GetUrl() *string { return v.Url }

func (v *getProjectProjectLeadUser) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getProjectProjectLeadUser
		ArchivedAt    json.RawMessage `json:"archivedAt"`
		CreatedAt     json.RawMessage `json:"createdAt"`
		LastSeen      json.RawMessage `json:"lastSeen"`
		StatusUntilAt json.RawMessage `json:"statusUntilAt"`
		UpdatedAt     json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getProjectProjectLeadUser = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getProjectProjectLeadUser.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getProjectProjectLeadUser.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.LastSeen
		src := firstPass.LastSeen
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getProjectProjectLeadUser.LastSeen: %w", err)
			}
		}
	}

	{
		dst := &v.StatusUntilAt
		src := firstPass.StatusUntilAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getProjectProjectLeadUser.StatusUntilAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getProjectProjectLeadUser.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetProjectProjectLeadUser struct {
	Id *string `json:"id"`

	Active *bool `json:"active"`

	Admin *bool `json:"admin"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AvatarUrl *string `json:"avatarUrl"`

	CalendarHash *string `json:"calendarHash"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CreatedIssueCount *int `json:"createdIssueCount"`

	Description *string `json:"description"`

	DisableReason *string `json:"disableReason"`

	DisplayName *string `json:"displayName"`

	Email *string `json:"email"`

	Guest *bool `json:"guest"`

	InviteHash *string `json:"inviteHash"`

	IsMe *bool `json:"isMe"`

	LastSeen json.RawMessage `json:"lastSeen"`

	Name *string `json:"name"`

	StatusEmoji *string `json:"statusEmoji"`

	StatusLabel *string `json:"statusLabel"`

	StatusUntilAt json.RawMessage `json:"statusUntilAt"`

	Timezone *string `json:"timezone"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	Url *string `json:"url"`
}

func (v *getProjectProjectLeadUser) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getProjectProjectLeadUser) __premarshalJSON() (*__premarshalgetProjectProjectLeadUser, error) {
	var retval __premarshalgetProjectProjectLeadUser

	retval.Id = v.Id
	retval.Active = v.Active
	retval.Admin = v.Admin
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getProjectProjectLeadUser.ArchivedAt: %w", err)
			}
		}
	}
	retval.AvatarUrl = v.AvatarUrl
	retval.CalendarHash = v.CalendarHash
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getProjectProjectLeadUser.CreatedAt: %w", err)
			}
		}
	}
	retval.CreatedIssueCount = v.CreatedIssueCount
	retval.Description = v.Description
	retval.DisableReason = v.DisableReason
	retval.DisplayName = v.DisplayName
	retval.Email = v.Email
	retval.Guest = v.Guest
	retval.InviteHash = v.InviteHash
	retval.IsMe = v.IsMe
	{

		dst := &retval.LastSeen
		src := v.LastSeen
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getProjectProjectLeadUser.LastSeen: %w", err)
			}
		}
	}
	retval.Name = v.Name
	retval.StatusEmoji = v.StatusEmoji
	retval.StatusLabel = v.StatusLabel
	{

		dst := &retval.StatusUntilAt
		src := v.StatusUntilAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getProjectProjectLeadUser.StatusUntilAt: %w", err)
			}
		}
	}
	retval.Timezone = v.Timezone
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getProjectProjectLeadUser.UpdatedAt: %w", err)
			}
		}
	}
	retval.Url = v.Url
	return &retval, nil
}

// getProjectResponse is returned by getProject on success.
type getProjectResponse struct {
	// One specific project.
	Project *getProjectProject `json:"project"`
}

// GetProject returns getProjectResponse.Project, and is useful for accessing the field via an interface.
func (v *getProjectResponse) GetProject() *getProjectProject { return v.Project }

// getTeamMembershipResponse is returned by getTeamMembership on success.
type getTeamMembershipResponse struct {
	// One specific team membership.
	TeamMembership *getTeamMembershipTeamMembership `json:"teamMembership"`
}

// GetTeamMembership returns getTeamMembershipResponse.TeamMembership, and is useful for accessing the field via an interface.
func (v *getTeamMembershipResponse) GetTeamMembership() *getTeamMembershipTeamMembership {
	return v.TeamMembership
}

// getTeamMembershipTeamMembership includes the requested fields of the GraphQL type TeamMembership.
// The GraphQL type's documentation follows.
//
// Defines the membership of a user to a team.
type getTeamMembershipTeamMembership struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Whether the user is the owner of the team
	Owner *bool `json:"owner"`
	// The order of the item in the users team list.
	SortOrder *float64 `json:"sortOrder"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// The team that the membership is associated with.
	Team *getTeamMembershipTeamMembershipTeam `json:"team"`
	// The user that the membership is associated with.
	User *getTeamMembershipTeamMembershipUser `json:"user"`
}

// GetId returns getTeamMembershipTeamMembership.Id, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembership) GetId() *string { return v.Id }

// GetArchivedAt returns getTeamMembershipTeamMembership.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembership) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetCreatedAt returns getTeamMembershipTeamMembership.CreatedAt, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembership) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetOwner returns getTeamMembershipTeamMembership.Owner, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembership) GetOwner() *bool { return v.Owner }

// GetSortOrder returns getTeamMembershipTeamMembership.SortOrder, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembership) GetSortOrder() *float64 { return v.SortOrder }

// GetUpdatedAt returns getTeamMembershipTeamMembership.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembership) GetUpdatedAt() *time.Time { return v.UpdatedAt }

// GetTeam returns getTeamMembershipTeamMembership.Team, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembership) GetTeam() *getTeamMembershipTeamMembershipTeam {
	return v.Team
}

// GetUser returns getTeamMembershipTeamMembership.User, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembership) GetUser() *getTeamMembershipTeamMembershipUser {
	return v.User
}

func (v *getTeamMembershipTeamMembership) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getTeamMembershipTeamMembership
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getTeamMembershipTeamMembership = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamMembershipTeamMembership.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamMembershipTeamMembership.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamMembershipTeamMembership.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetTeamMembershipTeamMembership struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	CreatedAt json.RawMessage `json:"createdAt"`

	Owner *bool `json:"owner"`

	SortOrder *float64 `json:"sortOrder"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	Team *getTeamMembershipTeamMembershipTeam `json:"team"`

	User *getTeamMembershipTeamMembershipUser `json:"user"`
}

func (v *getTeamMembershipTeamMembership) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getTeamMembershipTeamMembership) __premarshalJSON() (*__premarshalgetTeamMembershipTeamMembership, error) {
	var retval __premarshalgetTeamMembershipTeamMembership

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamMembershipTeamMembership.ArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamMembershipTeamMembership.CreatedAt: %w", err)
			}
		}
	}
	retval.Owner = v.Owner
	retval.SortOrder = v.SortOrder
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamMembershipTeamMembership.UpdatedAt: %w", err)
			}
		}
	}
	retval.Team = v.Team
	retval.User = v.User
	return &retval, nil
}

// getTeamMembershipTeamMembershipTeam includes the requested fields of the GraphQL type Team.
// The GraphQL type's documentation follows.
//
// An organizational unit that contains issues.
type getTeamMembershipTeamMembershipTeam struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// Period after which automatically closed and completed issues are automatically archived in months.
	AutoArchivePeriod *float64 `json:"autoArchivePeriod"`
	// Period after which issues are automatically closed in months. Null/undefined means disabled.
	AutoClosePeriod *float64 `json:"autoClosePeriod"`
	// The canceled workflow state which auto closed issues will be set to. Defaults to the first canceled state.
	AutoCloseStateId *string `json:"autoCloseStateId"`
	// The team's color.
	Color *string `json:"color"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Calendar feed URL (iCal) for cycles.
	CycleCalenderUrl *string `json:"cycleCalenderUrl"`
	// The cooldown time after each cycle in weeks.
	CycleCooldownTime *float64 `json:"cycleCooldownTime"`
	// The duration of a cycle in weeks.
	CycleDuration *float64 `json:"cycleDuration"`
	// Auto assign completed issues to current cycle.
	CycleIssueAutoAssignCompleted *bool `json:"cycleIssueAutoAssignCompleted"`
	// Auto assign started issues to current cycle.
	CycleIssueAutoAssignStarted *bool `json:"cycleIssueAutoAssignStarted"`
	// Only allow issues issues with cycles in Active Issues.
	CycleLockToActive *bool `json:"cycleLockToActive"`
	// The day of the week that a new cycle starts.
	CycleStartDay *float64 `json:"cycleStartDay"`
	// Whether the team uses cycles.
	CyclesEnabled *bool `json:"cyclesEnabled"`
	// What to use as an default estimate for unestimated issues.
	DefaultIssueEstimate *float64 `json:"defaultIssueEstimate"`
	// The id of the default template to use for new issues created by members of the team.
	DefaultTemplateForMembersId *string `json:"defaultTemplateForMembersId"`
	// The id of the default template to use for new issues created by non-members of the team.
	DefaultTemplateForNonMembersId *string `json:"defaultTemplateForNonMembersId"`
	// The team's description.
	Description *string `json:"description"`
	// Whether to group recent issue history entries.
	GroupIssueHistory *bool `json:"groupIssueHistory"`
	// The icon of the team.
	Icon *string `json:"icon"`
	// Unique hash for the team to be used in invite URLs.
	InviteHash *string `json:"inviteHash"`
	// Whether to allow zeros in issues estimates.
	IssueEstimationAllowZero *bool `json:"issueEstimationAllowZero"`
	// Whether to add additional points to the estimate scale.
	IssueEstimationExtended *bool `json:"issueEstimationExtended"`
	// The issue estimation type to use.
	IssueEstimationType *string `json:"issueEstimationType"`
	// Whether issues without priority should be sorted first.
	IssueOrderingNoPriorityFirst *bool `json:"issueOrderingNoPriorityFirst"`
	// Whether to move issues to bottom of the column when changing state.
	IssueSortOrderDefaultToBottom *bool `json:"issueSortOrderDefaultToBottom"`
	// The team's unique key. The key is used in URLs.
	Key *string `json:"key"`
	// The team's name.
	Name *string `json:"name"`
	// Whether the team is private or not.
	Private *bool `json:"private"`
	// Whether an issue needs to have a priority set before leaving triage
	RequirePriorityToLeaveTriage *bool `json:"requirePriorityToLeaveTriage"`
	// Whether to send new issue comment notifications to Slack.
	SlackIssueComments *bool `json:"slackIssueComments"`
	// Whether to send new issue status updates to Slack.
	SlackIssueStatuses *bool `json:"slackIssueStatuses"`
	// Whether to send new issue notifications to Slack.
	SlackNewIssue *bool `json:"slackNewIssue"`
	// The timezone of the team. Defaults to "America/Los_Angeles"
	Timezone *string `json:"timezone"`
	// Whether triage mode is enabled for the team or not.
	TriageEnabled *bool `json:"triageEnabled"`
	// How many upcoming cycles to create.
	UpcomingCycleCount *float64 `json:"upcomingCycleCount"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
}

// GetId returns getTeamMembershipTeamMembershipTeam.Id, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipTeam) GetId() *string { return v.Id }

// GetArchivedAt returns getTeamMembershipTeamMembershipTeam.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipTeam) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetAutoArchivePeriod returns getTeamMembershipTeamMembershipTeam.AutoArchivePeriod, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipTeam) GetAutoArchivePeriod() *float64 {
	return v.AutoArchivePeriod
}

// GetAutoClosePeriod returns getTeamMembershipTeamMembershipTeam.AutoClosePeriod, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipTeam) GetAutoClosePeriod() *float64 { return v.AutoClosePeriod }

// GetAutoCloseStateId returns getTeamMembershipTeamMembershipTeam.AutoCloseStateId, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipTeam) GetAutoCloseStateId() *string {
	return v.AutoCloseStateId
}

// GetColor returns getTeamMembershipTeamMembershipTeam.Color, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipTeam) GetColor() *string { return v.Color }

// GetCreatedAt returns getTeamMembershipTeamMembershipTeam.CreatedAt, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipTeam) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetCycleCalenderUrl returns getTeamMembershipTeamMembershipTeam.CycleCalenderUrl, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipTeam) GetCycleCalenderUrl() *string {
	return v.CycleCalenderUrl
}

// GetCycleCooldownTime returns getTeamMembershipTeamMembershipTeam.CycleCooldownTime, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipTeam) GetCycleCooldownTime() *float64 {
	return v.CycleCooldownTime
}

// GetCycleDuration returns getTeamMembershipTeamMembershipTeam.CycleDuration, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipTeam) GetCycleDuration() *float64 { return v.CycleDuration }

// GetCycleIssueAutoAssignCompleted returns getTeamMembershipTeamMembershipTeam.CycleIssueAutoAssignCompleted, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipTeam) GetCycleIssueAutoAssignCompleted() *bool {
	return v.CycleIssueAutoAssignCompleted
}

// GetCycleIssueAutoAssignStarted returns getTeamMembershipTeamMembershipTeam.CycleIssueAutoAssignStarted, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipTeam) GetCycleIssueAutoAssignStarted() *bool {
	return v.CycleIssueAutoAssignStarted
}

// GetCycleLockToActive returns getTeamMembershipTeamMembershipTeam.CycleLockToActive, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipTeam) GetCycleLockToActive() *bool {
	return v.CycleLockToActive
}

// GetCycleStartDay returns getTeamMembershipTeamMembershipTeam.CycleStartDay, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipTeam) GetCycleStartDay() *float64 { return v.CycleStartDay }

// GetCyclesEnabled returns getTeamMembershipTeamMembershipTeam.CyclesEnabled, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipTeam) GetCyclesEnabled() *bool { return v.CyclesEnabled }

// GetDefaultIssueEstimate returns getTeamMembershipTeamMembershipTeam.DefaultIssueEstimate, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipTeam) GetDefaultIssueEstimate() *float64 {
	return v.DefaultIssueEstimate
}

// GetDefaultTemplateForMembersId returns getTeamMembershipTeamMembershipTeam.DefaultTemplateForMembersId, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipTeam) GetDefaultTemplateForMembersId() *string {
	return v.DefaultTemplateForMembersId
}

// GetDefaultTemplateForNonMembersId returns getTeamMembershipTeamMembershipTeam.DefaultTemplateForNonMembersId, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipTeam) GetDefaultTemplateForNonMembersId() *string {
	return v.DefaultTemplateForNonMembersId
}

// GetDescription returns getTeamMembershipTeamMembershipTeam.Description, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipTeam) GetDescription() *string { return v.Description }

// GetGroupIssueHistory returns getTeamMembershipTeamMembershipTeam.GroupIssueHistory, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipTeam) GetGroupIssueHistory() *bool {
	return v.GroupIssueHistory
}

// GetIcon returns getTeamMembershipTeamMembershipTeam.Icon, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipTeam) GetIcon() *string { return v.Icon }

// GetInviteHash returns getTeamMembershipTeamMembershipTeam.InviteHash, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipTeam) GetInviteHash() *string { return v.InviteHash }

// GetIssueEstimationAllowZero returns getTeamMembershipTeamMembershipTeam.IssueEstimationAllowZero, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipTeam) GetIssueEstimationAllowZero() *bool {
	return v.IssueEstimationAllowZero
}

// GetIssueEstimationExtended returns getTeamMembershipTeamMembershipTeam.IssueEstimationExtended, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipTeam) GetIssueEstimationExtended() *bool {
	return v.IssueEstimationExtended
}

// GetIssueEstimationType returns getTeamMembershipTeamMembershipTeam.IssueEstimationType, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipTeam) GetIssueEstimationType() *string {
	return v.IssueEstimationType
}

// GetIssueOrderingNoPriorityFirst returns getTeamMembershipTeamMembershipTeam.IssueOrderingNoPriorityFirst, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipTeam) GetIssueOrderingNoPriorityFirst() *bool {
	return v.IssueOrderingNoPriorityFirst
}

// GetIssueSortOrderDefaultToBottom returns getTeamMembershipTeamMembershipTeam.IssueSortOrderDefaultToBottom, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipTeam) GetIssueSortOrderDefaultToBottom() *bool {
	return v.IssueSortOrderDefaultToBottom
}

// GetKey returns getTeamMembershipTeamMembershipTeam.Key, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipTeam) GetKey() *string { return v.Key }

// GetName returns getTeamMembershipTeamMembershipTeam.Name, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipTeam) GetName() *string { return v.Name }

// GetPrivate returns getTeamMembershipTeamMembershipTeam.Private, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipTeam) GetPrivate() *bool { return v.Private }

// GetRequirePriorityToLeaveTriage returns getTeamMembershipTeamMembershipTeam.RequirePriorityToLeaveTriage, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipTeam) GetRequirePriorityToLeaveTriage() *bool {
	return v.RequirePriorityToLeaveTriage
}

// GetSlackIssueComments returns getTeamMembershipTeamMembershipTeam.SlackIssueComments, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipTeam) GetSlackIssueComments() *bool {
	return v.SlackIssueComments
}

// GetSlackIssueStatuses returns getTeamMembershipTeamMembershipTeam.SlackIssueStatuses, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipTeam) GetSlackIssueStatuses() *bool {
	return v.SlackIssueStatuses
}

// GetSlackNewIssue returns getTeamMembershipTeamMembershipTeam.SlackNewIssue, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipTeam) GetSlackNewIssue() *bool { return v.SlackNewIssue }

// GetTimezone returns getTeamMembershipTeamMembershipTeam.Timezone, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipTeam) GetTimezone() *string { return v.Timezone }

// GetTriageEnabled returns getTeamMembershipTeamMembershipTeam.TriageEnabled, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipTeam) GetTriageEnabled() *bool { return v.TriageEnabled }

// GetUpcomingCycleCount returns getTeamMembershipTeamMembershipTeam.UpcomingCycleCount, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipTeam) GetUpcomingCycleCount() *float64 {
	return v.UpcomingCycleCount
}

// GetUpdatedAt returns getTeamMembershipTeamMembershipTeam.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipTeam) GetUpdatedAt() *time.Time { return v.UpdatedAt }

func (v *getTeamMembershipTeamMembershipTeam) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getTeamMembershipTeamMembershipTeam
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getTeamMembershipTeamMembershipTeam = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamMembershipTeamMembershipTeam.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamMembershipTeamMembershipTeam.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamMembershipTeamMembershipTeam.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetTeamMembershipTeamMembershipTeam struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AutoArchivePeriod *float64 `json:"autoArchivePeriod"`

	AutoClosePeriod *float64 `json:"autoClosePeriod"`

	AutoCloseStateId *string `json:"autoCloseStateId"`

	Color *string `json:"color"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CycleCalenderUrl *string `json:"cycleCalenderUrl"`

	CycleCooldownTime *float64 `json:"cycleCooldownTime"`

	CycleDuration *float64 `json:"cycleDuration"`

	CycleIssueAutoAssignCompleted *bool `json:"cycleIssueAutoAssignCompleted"`

	CycleIssueAutoAssignStarted *bool `json:"cycleIssueAutoAssignStarted"`

	CycleLockToActive *bool `json:"cycleLockToActive"`

	CycleStartDay *float64 `json:"cycleStartDay"`

	CyclesEnabled *bool `json:"cyclesEnabled"`

	DefaultIssueEstimate *float64 `json:"defaultIssueEstimate"`

	DefaultTemplateForMembersId *string `json:"defaultTemplateForMembersId"`

	DefaultTemplateForNonMembersId *string `json:"defaultTemplateForNonMembersId"`

	Description *string `json:"description"`

	GroupIssueHistory *bool `json:"groupIssueHistory"`

	Icon *string `json:"icon"`

	InviteHash *string `json:"inviteHash"`

	IssueEstimationAllowZero *bool `json:"issueEstimationAllowZero"`

	IssueEstimationExtended *bool `json:"issueEstimationExtended"`

	IssueEstimationType *string `json:"issueEstimationType"`

	IssueOrderingNoPriorityFirst *bool `json:"issueOrderingNoPriorityFirst"`

	IssueSortOrderDefaultToBottom *bool `json:"issueSortOrderDefaultToBottom"`

	Key *string `json:"key"`

	Name *string `json:"name"`

	Private *bool `json:"private"`

	RequirePriorityToLeaveTriage *bool `json:"requirePriorityToLeaveTriage"`

	SlackIssueComments *bool `json:"slackIssueComments"`

	SlackIssueStatuses *bool `json:"slackIssueStatuses"`

	SlackNewIssue *bool `json:"slackNewIssue"`

	Timezone *string `json:"timezone"`

	TriageEnabled *bool `json:"triageEnabled"`

	UpcomingCycleCount *float64 `json:"upcomingCycleCount"`

	UpdatedAt json.RawMessage `json:"updatedAt"`
}

func (v *getTeamMembershipTeamMembershipTeam) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getTeamMembershipTeamMembershipTeam) __premarshalJSON() (*__premarshalgetTeamMembershipTeamMembershipTeam, error) {
	var retval __premarshalgetTeamMembershipTeamMembershipTeam

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamMembershipTeamMembershipTeam.ArchivedAt: %w", err)
			}
		}
	}
	retval.AutoArchivePeriod = v.AutoArchivePeriod
	retval.AutoClosePeriod = v.AutoClosePeriod
	retval.AutoCloseStateId = v.AutoCloseStateId
	retval.Color = v.Color
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamMembershipTeamMembershipTeam.CreatedAt: %w", err)
			}
		}
	}
	retval.CycleCalenderUrl = v.CycleCalenderUrl
	retval.CycleCooldownTime = v.CycleCooldownTime
	retval.CycleDuration = v.CycleDuration
	retval.CycleIssueAutoAssignCompleted = v.CycleIssueAutoAssignCompleted
	retval.CycleIssueAutoAssignStarted = v.CycleIssueAutoAssignStarted
	retval.CycleLockToActive = v.CycleLockToActive
	retval.CycleStartDay = v.CycleStartDay
	retval.CyclesEnabled = v.CyclesEnabled
	retval.DefaultIssueEstimate = v.DefaultIssueEstimate
	retval.DefaultTemplateForMembersId = v.DefaultTemplateForMembersId
	retval.DefaultTemplateForNonMembersId = v.DefaultTemplateForNonMembersId
	retval.Description = v.Description
	retval.GroupIssueHistory = v.GroupIssueHistory
	retval.Icon = v.Icon
	retval.InviteHash = v.InviteHash
	retval.IssueEstimationAllowZero = v.IssueEstimationAllowZero
	retval.IssueEstimationExtended = v.IssueEstimationExtended
	retval.IssueEstimationType = v.IssueEstimationType
	retval.IssueOrderingNoPriorityFirst = v.IssueOrderingNoPriorityFirst
	retval.IssueSortOrderDefaultToBottom = v.IssueSortOrderDefaultToBottom
	retval.Key = v.Key
	retval.Name = v.Name
	retval.Private = v.Private
	retval.RequirePriorityToLeaveTriage = v.RequirePriorityToLeaveTriage
	retval.SlackIssueComments = v.SlackIssueComments
	retval.SlackIssueStatuses = v.SlackIssueStatuses
	retval.SlackNewIssue = v.SlackNewIssue
	retval.Timezone = v.Timezone
	retval.TriageEnabled = v.TriageEnabled
	retval.UpcomingCycleCount = v.UpcomingCycleCount
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamMembershipTeamMembershipTeam.UpdatedAt: %w", err)
			}
		}
	}
	return &retval, nil
}

// getTeamMembershipTeamMembershipUser includes the requested fields of the GraphQL type User.
// The GraphQL type's documentation follows.
//
// A user that has access to the the resources of an organization.
type getTeamMembershipTeamMembershipUser struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// Whether the user account is active or disabled (suspended).
	Active *bool `json:"active"`
	// Whether the user is an organization administrator.
	Admin *bool `json:"admin"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// An URL to the user's avatar image.
	AvatarUrl *string `json:"avatarUrl"`
	// [DEPRECATED] Hash for the user to be used in calendar URLs.
	CalendarHash *string `json:"calendarHash"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Number of issues created.
	CreatedIssueCount *int `json:"createdIssueCount"`
	// A short description of the user, either its title or bio.
	Description *string `json:"description"`
	// Reason why is the account disabled.
	DisableReason *string `json:"disableReason"`
	// The user's display (nick) name. Unique within each organization.
	DisplayName *string `json:"displayName"`
	// The user's email address.
	Email *string `json:"email"`
	// Whether the user is a guest in the workspace and limited to accessing a subset of teams.
	Guest *bool `json:"guest"`
	// Unique hash for the user to be used in invite URLs.
	InviteHash *string `json:"inviteHash"`
	// Whether the user is the currently authenticated user.
	IsMe *bool `json:"isMe"`
	// The last time the user was seen online. If null, the user is currently online.
	LastSeen *time.Time `json:"-"`
	// The user's full name.
	Name *string `json:"name"`
	// The emoji to represent the user current status.
	StatusEmoji *string `json:"statusEmoji"`
	// The label of the user current status.
	StatusLabel *string `json:"statusLabel"`
	// A date at which the user current status should be cleared.
	StatusUntilAt *time.Time `json:"-"`
	// The local timezone of the user.
	Timezone *string `json:"timezone"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// User's profile URL.
	Url *string `json:"url"`
}

// GetId returns getTeamMembershipTeamMembershipUser.Id, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipUser) GetId() *string { return v.Id }

// GetActive returns getTeamMembershipTeamMembershipUser.Active, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipUser) GetActive() *bool { return v.Active }

// GetAdmin returns getTeamMembershipTeamMembershipUser.Admin, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipUser) GetAdmin() *bool { return v.Admin }

// GetArchivedAt returns getTeamMembershipTeamMembershipUser.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipUser) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetAvatarUrl returns getTeamMembershipTeamMembershipUser.AvatarUrl, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipUser) GetAvatarUrl() *string { return v.AvatarUrl }

// GetCalendarHash returns getTeamMembershipTeamMembershipUser.CalendarHash, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipUser) GetCalendarHash() *string { return v.CalendarHash }

// GetCreatedAt returns getTeamMembershipTeamMembershipUser.CreatedAt, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipUser) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetCreatedIssueCount returns getTeamMembershipTeamMembershipUser.CreatedIssueCount, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipUser) GetCreatedIssueCount() *int { return v.CreatedIssueCount }

// GetDescription returns getTeamMembershipTeamMembershipUser.Description, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipUser) GetDescription() *string { return v.Description }

// GetDisableReason returns getTeamMembershipTeamMembershipUser.DisableReason, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipUser) GetDisableReason() *string { return v.DisableReason }

// GetDisplayName returns getTeamMembershipTeamMembershipUser.DisplayName, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipUser) GetDisplayName() *string { return v.DisplayName }

// GetEmail returns getTeamMembershipTeamMembershipUser.Email, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipUser) GetEmail() *string { return v.Email }

// GetGuest returns getTeamMembershipTeamMembershipUser.Guest, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipUser) GetGuest() *bool { return v.Guest }

// GetInviteHash returns getTeamMembershipTeamMembershipUser.InviteHash, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipUser) GetInviteHash() *string { return v.InviteHash }

// GetIsMe returns getTeamMembershipTeamMembershipUser.IsMe, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipUser) GetIsMe() *bool { return v.IsMe }

// GetLastSeen returns getTeamMembershipTeamMembershipUser.LastSeen, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipUser) GetLastSeen() *time.Time { return v.LastSeen }

// GetName returns getTeamMembershipTeamMembershipUser.Name, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipUser) GetName() *string { return v.Name }

// GetStatusEmoji returns getTeamMembershipTeamMembershipUser.StatusEmoji, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipUser) GetStatusEmoji() *string { return v.StatusEmoji }

// GetStatusLabel returns getTeamMembershipTeamMembershipUser.StatusLabel, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipUser) GetStatusLabel() *string { return v.StatusLabel }

// GetStatusUntilAt returns getTeamMembershipTeamMembershipUser.StatusUntilAt, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipUser) GetStatusUntilAt() *time.Time { return v.StatusUntilAt }

// GetTimezone returns getTeamMembershipTeamMembershipUser.Timezone, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipUser) GetTimezone() *string { return v.Timezone }

// GetUpdatedAt returns getTeamMembershipTeamMembershipUser.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipUser) GetUpdatedAt() *time.Time { return v.UpdatedAt }

// GetUrl returns getTeamMembershipTeamMembershipUser.Url, and is useful for accessing the field via an interface.
func (v *getTeamMembershipTeamMembershipUser) GetUrl() *string { return v.Url }

func (v *getTeamMembershipTeamMembershipUser) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getTeamMembershipTeamMembershipUser
		ArchivedAt    json.RawMessage `json:"archivedAt"`
		CreatedAt     json.RawMessage `json:"createdAt"`
		LastSeen      json.RawMessage `json:"lastSeen"`
		StatusUntilAt json.RawMessage `json:"statusUntilAt"`
		UpdatedAt     json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getTeamMembershipTeamMembershipUser = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamMembershipTeamMembershipUser.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamMembershipTeamMembershipUser.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.LastSeen
		src := firstPass.LastSeen
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamMembershipTeamMembershipUser.LastSeen: %w", err)
			}
		}
	}

	{
		dst := &v.StatusUntilAt
		src := firstPass.StatusUntilAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamMembershipTeamMembershipUser.StatusUntilAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamMembershipTeamMembershipUser.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetTeamMembershipTeamMembershipUser struct {
	Id *string `json:"id"`

	Active *bool `json:"active"`

	Admin *bool `json:"admin"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AvatarUrl *string `json:"avatarUrl"`

	CalendarHash *string `json:"calendarHash"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CreatedIssueCount *int `json:"createdIssueCount"`

	Description *string `json:"description"`

	DisableReason *string `json:"disableReason"`

	DisplayName *string `json:"displayName"`

	Email *string `json:"email"`

	Guest *bool `json:"guest"`

	InviteHash *string `json:"inviteHash"`

	IsMe *bool `json:"isMe"`

	LastSeen json.RawMessage `json:"lastSeen"`

	Name *string `json:"name"`

	StatusEmoji *string `json:"statusEmoji"`

	StatusLabel *string `json:"statusLabel"`

	StatusUntilAt json.RawMessage `json:"statusUntilAt"`

	Timezone *string `json:"timezone"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	Url *string `json:"url"`
}

func (v *getTeamMembershipTeamMembershipUser) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getTeamMembershipTeamMembershipUser) __premarshalJSON() (*__premarshalgetTeamMembershipTeamMembershipUser, error) {
	var retval __premarshalgetTeamMembershipTeamMembershipUser

	retval.Id = v.Id
	retval.Active = v.Active
	retval.Admin = v.Admin
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamMembershipTeamMembershipUser.ArchivedAt: %w", err)
			}
		}
	}
	retval.AvatarUrl = v.AvatarUrl
	retval.CalendarHash = v.CalendarHash
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamMembershipTeamMembershipUser.CreatedAt: %w", err)
			}
		}
	}
	retval.CreatedIssueCount = v.CreatedIssueCount
	retval.Description = v.Description
	retval.DisableReason = v.DisableReason
	retval.DisplayName = v.DisplayName
	retval.Email = v.Email
	retval.Guest = v.Guest
	retval.InviteHash = v.InviteHash
	retval.IsMe = v.IsMe
	{

		dst := &retval.LastSeen
		src := v.LastSeen
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamMembershipTeamMembershipUser.LastSeen: %w", err)
			}
		}
	}
	retval.Name = v.Name
	retval.StatusEmoji = v.StatusEmoji
	retval.StatusLabel = v.StatusLabel
	{

		dst := &retval.StatusUntilAt
		src := v.StatusUntilAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamMembershipTeamMembershipUser.StatusUntilAt: %w", err)
			}
		}
	}
	retval.Timezone = v.Timezone
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamMembershipTeamMembershipUser.UpdatedAt: %w", err)
			}
		}
	}
	retval.Url = v.Url
	return &retval, nil
}

// getTeamResponse is returned by getTeam on success.
type getTeamResponse struct {
	// One specific team.
	Team *getTeamTeam `json:"team"`
}

// GetTeam returns getTeamResponse.Team, and is useful for accessing the field via an interface.
func (v *getTeamResponse) GetTeam() *getTeamTeam { return v.Team }

// getTeamTeam includes the requested fields of the GraphQL type Team.
// The GraphQL type's documentation follows.
//
// An organizational unit that contains issues.
type getTeamTeam struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// Period after which automatically closed and completed issues are automatically archived in months.
	AutoArchivePeriod *float64 `json:"autoArchivePeriod"`
	// Period after which issues are automatically closed in months. Null/undefined means disabled.
	AutoClosePeriod *float64 `json:"autoClosePeriod"`
	// The canceled workflow state which auto closed issues will be set to. Defaults to the first canceled state.
	AutoCloseStateId *string `json:"autoCloseStateId"`
	// The team's color.
	Color *string `json:"color"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Calendar feed URL (iCal) for cycles.
	CycleCalenderUrl *string `json:"cycleCalenderUrl"`
	// The cooldown time after each cycle in weeks.
	CycleCooldownTime *float64 `json:"cycleCooldownTime"`
	// The duration of a cycle in weeks.
	CycleDuration *float64 `json:"cycleDuration"`
	// Auto assign completed issues to current cycle.
	CycleIssueAutoAssignCompleted *bool `json:"cycleIssueAutoAssignCompleted"`
	// Auto assign started issues to current cycle.
	CycleIssueAutoAssignStarted *bool `json:"cycleIssueAutoAssignStarted"`
	// Only allow issues issues with cycles in Active Issues.
	CycleLockToActive *bool `json:"cycleLockToActive"`
	// The day of the week that a new cycle starts.
	CycleStartDay *float64 `json:"cycleStartDay"`
	// Whether the team uses cycles.
	CyclesEnabled *bool `json:"cyclesEnabled"`
	// What to use as an default estimate for unestimated issues.
	DefaultIssueEstimate *float64 `json:"defaultIssueEstimate"`
	// The id of the default template to use for new issues created by members of the team.
	DefaultTemplateForMembersId *string `json:"defaultTemplateForMembersId"`
	// The id of the default template to use for new issues created by non-members of the team.
	DefaultTemplateForNonMembersId *string `json:"defaultTemplateForNonMembersId"`
	// The team's description.
	Description *string `json:"description"`
	// Whether to group recent issue history entries.
	GroupIssueHistory *bool `json:"groupIssueHistory"`
	// The icon of the team.
	Icon *string `json:"icon"`
	// Unique hash for the team to be used in invite URLs.
	InviteHash *string `json:"inviteHash"`
	// Whether to allow zeros in issues estimates.
	IssueEstimationAllowZero *bool `json:"issueEstimationAllowZero"`
	// Whether to add additional points to the estimate scale.
	IssueEstimationExtended *bool `json:"issueEstimationExtended"`
	// The issue estimation type to use.
	IssueEstimationType *string `json:"issueEstimationType"`
	// Whether issues without priority should be sorted first.
	IssueOrderingNoPriorityFirst *bool `json:"issueOrderingNoPriorityFirst"`
	// Whether to move issues to bottom of the column when changing state.
	IssueSortOrderDefaultToBottom *bool `json:"issueSortOrderDefaultToBottom"`
	// The team's unique key. The key is used in URLs.
	Key *string `json:"key"`
	// The team's name.
	Name *string `json:"name"`
	// Whether the team is private or not.
	Private *bool `json:"private"`
	// Whether an issue needs to have a priority set before leaving triage
	RequirePriorityToLeaveTriage *bool `json:"requirePriorityToLeaveTriage"`
	// Whether to send new issue comment notifications to Slack.
	SlackIssueComments *bool `json:"slackIssueComments"`
	// Whether to send new issue status updates to Slack.
	SlackIssueStatuses *bool `json:"slackIssueStatuses"`
	// Whether to send new issue notifications to Slack.
	SlackNewIssue *bool `json:"slackNewIssue"`
	// The timezone of the team. Defaults to "America/Los_Angeles"
	Timezone *string `json:"timezone"`
	// Whether triage mode is enabled for the team or not.
	TriageEnabled *bool `json:"triageEnabled"`
	// How many upcoming cycles to create.
	UpcomingCycleCount *float64 `json:"upcomingCycleCount"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// Team's currently active cycle.
	ActiveCycle *getTeamTeamActiveCycle `json:"activeCycle"`
	// The default workflow state into which issues are set when they are opened by team members.
	DefaultIssueState *getTeamTeamDefaultIssueStateWorkflowState `json:"defaultIssueState"`
	// The default template to use for new issues created by members of the team.
	DefaultTemplateForMembers *getTeamTeamDefaultTemplateForMembersTemplate `json:"defaultTemplateForMembers"`
	// The default template to use for new issues created by non-members of the team.
	DefaultTemplateForNonMembers *getTeamTeamDefaultTemplateForNonMembersTemplate `json:"defaultTemplateForNonMembers"`
	// The workflow state into which issues are moved when a PR has been opened as draft.
	DraftWorkflowState *getTeamTeamDraftWorkflowState `json:"draftWorkflowState"`
	// Settings for all integrations associated with that team.
	IntegrationsSettings *getTeamTeamIntegrationsSettings `json:"integrationsSettings"`
	// The workflow state into which issues are moved when they are marked as a duplicate of another issue. Defaults to the first canceled state.
	MarkedAsDuplicateWorkflowState *getTeamTeamMarkedAsDuplicateWorkflowState `json:"markedAsDuplicateWorkflowState"`
	// The organization that the team is associated with.
	Organization *getTeamTeamOrganization `json:"organization"`
	// The workflow state into which issues are moved when a review has been requested for the PR.
	ReviewWorkflowState *getTeamTeamReviewWorkflowState `json:"reviewWorkflowState"`
	// The workflow state into which issues are moved when a PR has been opened.
	StartWorkflowState *getTeamTeamStartWorkflowState `json:"startWorkflowState"`
	// The workflow state into which issues are set when they are opened by non-team members or integrations if triage is enabled.
	TriageIssueState *getTeamTeamTriageIssueStateWorkflowState `json:"triageIssueState"`
}

// GetId returns getTeamTeam.Id, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetId() *string { return v.Id }

// GetArchivedAt returns getTeamTeam.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetAutoArchivePeriod returns getTeamTeam.AutoArchivePeriod, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetAutoArchivePeriod() *float64 { return v.AutoArchivePeriod }

// GetAutoClosePeriod returns getTeamTeam.AutoClosePeriod, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetAutoClosePeriod() *float64 { return v.AutoClosePeriod }

// GetAutoCloseStateId returns getTeamTeam.AutoCloseStateId, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetAutoCloseStateId() *string { return v.AutoCloseStateId }

// GetColor returns getTeamTeam.Color, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetColor() *string { return v.Color }

// GetCreatedAt returns getTeamTeam.CreatedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetCycleCalenderUrl returns getTeamTeam.CycleCalenderUrl, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetCycleCalenderUrl() *string { return v.CycleCalenderUrl }

// GetCycleCooldownTime returns getTeamTeam.CycleCooldownTime, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetCycleCooldownTime() *float64 { return v.CycleCooldownTime }

// GetCycleDuration returns getTeamTeam.CycleDuration, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetCycleDuration() *float64 { return v.CycleDuration }

// GetCycleIssueAutoAssignCompleted returns getTeamTeam.CycleIssueAutoAssignCompleted, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetCycleIssueAutoAssignCompleted() *bool {
	return v.CycleIssueAutoAssignCompleted
}

// GetCycleIssueAutoAssignStarted returns getTeamTeam.CycleIssueAutoAssignStarted, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetCycleIssueAutoAssignStarted() *bool { return v.CycleIssueAutoAssignStarted }

// GetCycleLockToActive returns getTeamTeam.CycleLockToActive, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetCycleLockToActive() *bool { return v.CycleLockToActive }

// GetCycleStartDay returns getTeamTeam.CycleStartDay, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetCycleStartDay() *float64 { return v.CycleStartDay }

// GetCyclesEnabled returns getTeamTeam.CyclesEnabled, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetCyclesEnabled() *bool { return v.CyclesEnabled }

// GetDefaultIssueEstimate returns getTeamTeam.DefaultIssueEstimate, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetDefaultIssueEstimate() *float64 { return v.DefaultIssueEstimate }

// GetDefaultTemplateForMembersId returns getTeamTeam.DefaultTemplateForMembersId, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetDefaultTemplateForMembersId() *string { return v.DefaultTemplateForMembersId }

// GetDefaultTemplateForNonMembersId returns getTeamTeam.DefaultTemplateForNonMembersId, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetDefaultTemplateForNonMembersId() *string {
	return v.DefaultTemplateForNonMembersId
}

// GetDescription returns getTeamTeam.Description, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetDescription() *string { return v.Description }

// GetGroupIssueHistory returns getTeamTeam.GroupIssueHistory, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetGroupIssueHistory() *bool { return v.GroupIssueHistory }

// GetIcon returns getTeamTeam.Icon, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetIcon() *string { return v.Icon }

// GetInviteHash returns getTeamTeam.InviteHash, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetInviteHash() *string { return v.InviteHash }

// GetIssueEstimationAllowZero returns getTeamTeam.IssueEstimationAllowZero, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetIssueEstimationAllowZero() *bool { return v.IssueEstimationAllowZero }

// GetIssueEstimationExtended returns getTeamTeam.IssueEstimationExtended, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetIssueEstimationExtended() *bool { return v.IssueEstimationExtended }

// GetIssueEstimationType returns getTeamTeam.IssueEstimationType, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetIssueEstimationType() *string { return v.IssueEstimationType }

// GetIssueOrderingNoPriorityFirst returns getTeamTeam.IssueOrderingNoPriorityFirst, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetIssueOrderingNoPriorityFirst() *bool { return v.IssueOrderingNoPriorityFirst }

// GetIssueSortOrderDefaultToBottom returns getTeamTeam.IssueSortOrderDefaultToBottom, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetIssueSortOrderDefaultToBottom() *bool {
	return v.IssueSortOrderDefaultToBottom
}

// GetKey returns getTeamTeam.Key, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetKey() *string { return v.Key }

// GetName returns getTeamTeam.Name, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetName() *string { return v.Name }

// GetPrivate returns getTeamTeam.Private, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetPrivate() *bool { return v.Private }

// GetRequirePriorityToLeaveTriage returns getTeamTeam.RequirePriorityToLeaveTriage, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetRequirePriorityToLeaveTriage() *bool { return v.RequirePriorityToLeaveTriage }

// GetSlackIssueComments returns getTeamTeam.SlackIssueComments, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetSlackIssueComments() *bool { return v.SlackIssueComments }

// GetSlackIssueStatuses returns getTeamTeam.SlackIssueStatuses, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetSlackIssueStatuses() *bool { return v.SlackIssueStatuses }

// GetSlackNewIssue returns getTeamTeam.SlackNewIssue, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetSlackNewIssue() *bool { return v.SlackNewIssue }

// GetTimezone returns getTeamTeam.Timezone, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetTimezone() *string { return v.Timezone }

// GetTriageEnabled returns getTeamTeam.TriageEnabled, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetTriageEnabled() *bool { return v.TriageEnabled }

// GetUpcomingCycleCount returns getTeamTeam.UpcomingCycleCount, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetUpcomingCycleCount() *float64 { return v.UpcomingCycleCount }

// GetUpdatedAt returns getTeamTeam.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetUpdatedAt() *time.Time { return v.UpdatedAt }

// GetActiveCycle returns getTeamTeam.ActiveCycle, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetActiveCycle() *getTeamTeamActiveCycle { return v.ActiveCycle }

// GetDefaultIssueState returns getTeamTeam.DefaultIssueState, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetDefaultIssueState() *getTeamTeamDefaultIssueStateWorkflowState {
	return v.DefaultIssueState
}

// GetDefaultTemplateForMembers returns getTeamTeam.DefaultTemplateForMembers, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetDefaultTemplateForMembers() *getTeamTeamDefaultTemplateForMembersTemplate {
	return v.DefaultTemplateForMembers
}

// GetDefaultTemplateForNonMembers returns getTeamTeam.DefaultTemplateForNonMembers, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetDefaultTemplateForNonMembers() *getTeamTeamDefaultTemplateForNonMembersTemplate {
	return v.DefaultTemplateForNonMembers
}

// GetDraftWorkflowState returns getTeamTeam.DraftWorkflowState, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetDraftWorkflowState() *getTeamTeamDraftWorkflowState {
	return v.DraftWorkflowState
}

// GetIntegrationsSettings returns getTeamTeam.IntegrationsSettings, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetIntegrationsSettings() *getTeamTeamIntegrationsSettings {
	return v.IntegrationsSettings
}

// GetMarkedAsDuplicateWorkflowState returns getTeamTeam.MarkedAsDuplicateWorkflowState, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetMarkedAsDuplicateWorkflowState() *getTeamTeamMarkedAsDuplicateWorkflowState {
	return v.MarkedAsDuplicateWorkflowState
}

// GetOrganization returns getTeamTeam.Organization, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetOrganization() *getTeamTeamOrganization { return v.Organization }

// GetReviewWorkflowState returns getTeamTeam.ReviewWorkflowState, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetReviewWorkflowState() *getTeamTeamReviewWorkflowState {
	return v.ReviewWorkflowState
}

// GetStartWorkflowState returns getTeamTeam.StartWorkflowState, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetStartWorkflowState() *getTeamTeamStartWorkflowState {
	return v.StartWorkflowState
}

// GetTriageIssueState returns getTeamTeam.TriageIssueState, and is useful for accessing the field via an interface.
func (v *getTeamTeam) GetTriageIssueState() *getTeamTeamTriageIssueStateWorkflowState {
	return v.TriageIssueState
}

func (v *getTeamTeam) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getTeamTeam
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getTeamTeam = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeam.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeam.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeam.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetTeamTeam struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AutoArchivePeriod *float64 `json:"autoArchivePeriod"`

	AutoClosePeriod *float64 `json:"autoClosePeriod"`

	AutoCloseStateId *string `json:"autoCloseStateId"`

	Color *string `json:"color"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CycleCalenderUrl *string `json:"cycleCalenderUrl"`

	CycleCooldownTime *float64 `json:"cycleCooldownTime"`

	CycleDuration *float64 `json:"cycleDuration"`

	CycleIssueAutoAssignCompleted *bool `json:"cycleIssueAutoAssignCompleted"`

	CycleIssueAutoAssignStarted *bool `json:"cycleIssueAutoAssignStarted"`

	CycleLockToActive *bool `json:"cycleLockToActive"`

	CycleStartDay *float64 `json:"cycleStartDay"`

	CyclesEnabled *bool `json:"cyclesEnabled"`

	DefaultIssueEstimate *float64 `json:"defaultIssueEstimate"`

	DefaultTemplateForMembersId *string `json:"defaultTemplateForMembersId"`

	DefaultTemplateForNonMembersId *string `json:"defaultTemplateForNonMembersId"`

	Description *string `json:"description"`

	GroupIssueHistory *bool `json:"groupIssueHistory"`

	Icon *string `json:"icon"`

	InviteHash *string `json:"inviteHash"`

	IssueEstimationAllowZero *bool `json:"issueEstimationAllowZero"`

	IssueEstimationExtended *bool `json:"issueEstimationExtended"`

	IssueEstimationType *string `json:"issueEstimationType"`

	IssueOrderingNoPriorityFirst *bool `json:"issueOrderingNoPriorityFirst"`

	IssueSortOrderDefaultToBottom *bool `json:"issueSortOrderDefaultToBottom"`

	Key *string `json:"key"`

	Name *string `json:"name"`

	Private *bool `json:"private"`

	RequirePriorityToLeaveTriage *bool `json:"requirePriorityToLeaveTriage"`

	SlackIssueComments *bool `json:"slackIssueComments"`

	SlackIssueStatuses *bool `json:"slackIssueStatuses"`

	SlackNewIssue *bool `json:"slackNewIssue"`

	Timezone *string `json:"timezone"`

	TriageEnabled *bool `json:"triageEnabled"`

	UpcomingCycleCount *float64 `json:"upcomingCycleCount"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	ActiveCycle *getTeamTeamActiveCycle `json:"activeCycle"`

	DefaultIssueState *getTeamTeamDefaultIssueStateWorkflowState `json:"defaultIssueState"`

	DefaultTemplateForMembers *getTeamTeamDefaultTemplateForMembersTemplate `json:"defaultTemplateForMembers"`

	DefaultTemplateForNonMembers *getTeamTeamDefaultTemplateForNonMembersTemplate `json:"defaultTemplateForNonMembers"`

	DraftWorkflowState *getTeamTeamDraftWorkflowState `json:"draftWorkflowState"`

	IntegrationsSettings *getTeamTeamIntegrationsSettings `json:"integrationsSettings"`

	MarkedAsDuplicateWorkflowState *getTeamTeamMarkedAsDuplicateWorkflowState `json:"markedAsDuplicateWorkflowState"`

	Organization *getTeamTeamOrganization `json:"organization"`

	ReviewWorkflowState *getTeamTeamReviewWorkflowState `json:"reviewWorkflowState"`

	StartWorkflowState *getTeamTeamStartWorkflowState `json:"startWorkflowState"`

	TriageIssueState *getTeamTeamTriageIssueStateWorkflowState `json:"triageIssueState"`
}

func (v *getTeamTeam) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getTeamTeam) __premarshalJSON() (*__premarshalgetTeamTeam, error) {
	var retval __premarshalgetTeamTeam

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeam.ArchivedAt: %w", err)
			}
		}
	}
	retval.AutoArchivePeriod = v.AutoArchivePeriod
	retval.AutoClosePeriod = v.AutoClosePeriod
	retval.AutoCloseStateId = v.AutoCloseStateId
	retval.Color = v.Color
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeam.CreatedAt: %w", err)
			}
		}
	}
	retval.CycleCalenderUrl = v.CycleCalenderUrl
	retval.CycleCooldownTime = v.CycleCooldownTime
	retval.CycleDuration = v.CycleDuration
	retval.CycleIssueAutoAssignCompleted = v.CycleIssueAutoAssignCompleted
	retval.CycleIssueAutoAssignStarted = v.CycleIssueAutoAssignStarted
	retval.CycleLockToActive = v.CycleLockToActive
	retval.CycleStartDay = v.CycleStartDay
	retval.CyclesEnabled = v.CyclesEnabled
	retval.DefaultIssueEstimate = v.DefaultIssueEstimate
	retval.DefaultTemplateForMembersId = v.DefaultTemplateForMembersId
	retval.DefaultTemplateForNonMembersId = v.DefaultTemplateForNonMembersId
	retval.Description = v.Description
	retval.GroupIssueHistory = v.GroupIssueHistory
	retval.Icon = v.Icon
	retval.InviteHash = v.InviteHash
	retval.IssueEstimationAllowZero = v.IssueEstimationAllowZero
	retval.IssueEstimationExtended = v.IssueEstimationExtended
	retval.IssueEstimationType = v.IssueEstimationType
	retval.IssueOrderingNoPriorityFirst = v.IssueOrderingNoPriorityFirst
	retval.IssueSortOrderDefaultToBottom = v.IssueSortOrderDefaultToBottom
	retval.Key = v.Key
	retval.Name = v.Name
	retval.Private = v.Private
	retval.RequirePriorityToLeaveTriage = v.RequirePriorityToLeaveTriage
	retval.SlackIssueComments = v.SlackIssueComments
	retval.SlackIssueStatuses = v.SlackIssueStatuses
	retval.SlackNewIssue = v.SlackNewIssue
	retval.Timezone = v.Timezone
	retval.TriageEnabled = v.TriageEnabled
	retval.UpcomingCycleCount = v.UpcomingCycleCount
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeam.UpdatedAt: %w", err)
			}
		}
	}
	retval.ActiveCycle = v.ActiveCycle
	retval.DefaultIssueState = v.DefaultIssueState
	retval.DefaultTemplateForMembers = v.DefaultTemplateForMembers
	retval.DefaultTemplateForNonMembers = v.DefaultTemplateForNonMembers
	retval.DraftWorkflowState = v.DraftWorkflowState
	retval.IntegrationsSettings = v.IntegrationsSettings
	retval.MarkedAsDuplicateWorkflowState = v.MarkedAsDuplicateWorkflowState
	retval.Organization = v.Organization
	retval.ReviewWorkflowState = v.ReviewWorkflowState
	retval.StartWorkflowState = v.StartWorkflowState
	retval.TriageIssueState = v.TriageIssueState
	return &retval, nil
}

// getTeamTeamActiveCycle includes the requested fields of the GraphQL type Cycle.
// The GraphQL type's documentation follows.
//
// A set of issues to be resolved in a specified amount of time.
type getTeamTeamActiveCycle struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The time at which the cycle was automatically archived by the auto pruning process.
	AutoArchivedAt *time.Time `json:"-"`
	// The completion time of the cycle. If null, the cycle hasn't been completed.
	CompletedAt *time.Time `json:"-"`
	// The number of completed issues in the cycle after each day.
	CompletedIssueCountHistory []*float64 `json:"completedIssueCountHistory"`
	// The number of completed estimation points after each day.
	CompletedScopeHistory []*float64 `json:"completedScopeHistory"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// The cycle's description.
	Description *string `json:"description"`
	// The end time of the cycle.
	EndsAt *time.Time `json:"-"`
	// The number of in progress estimation points after each day.
	InProgressScopeHistory []*float64 `json:"inProgressScopeHistory"`
	// The total number of issues in the cycle after each day.
	IssueCountHistory []*float64 `json:"issueCountHistory"`
	// The custom name of the cycle.
	Name *string `json:"name"`
	// The number of the cycle.
	Number *float64 `json:"number"`
	// The overall progress of the cycle. This is the (completed estimate points + 0.25 * in progress estimate points) / total estimate points.
	Progress *float64 `json:"progress"`
	// The total number of estimation points after each day.
	ScopeHistory []*float64 `json:"scopeHistory"`
	// The start time of the cycle.
	StartsAt *time.Time `json:"-"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
}

// GetId returns getTeamTeamActiveCycle.Id, and is useful for accessing the field via an interface.
func (v *getTeamTeamActiveCycle) GetId() *string { return v.Id }

// GetArchivedAt returns getTeamTeamActiveCycle.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamActiveCycle) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetAutoArchivedAt returns getTeamTeamActiveCycle.AutoArchivedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamActiveCycle) GetAutoArchivedAt() *time.Time { return v.AutoArchivedAt }

// GetCompletedAt returns getTeamTeamActiveCycle.CompletedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamActiveCycle) GetCompletedAt() *time.Time { return v.CompletedAt }

// GetCompletedIssueCountHistory returns getTeamTeamActiveCycle.CompletedIssueCountHistory, and is useful for accessing the field via an interface.
func (v *getTeamTeamActiveCycle) GetCompletedIssueCountHistory() []*float64 {
	return v.CompletedIssueCountHistory
}

// GetCompletedScopeHistory returns getTeamTeamActiveCycle.CompletedScopeHistory, and is useful for accessing the field via an interface.
func (v *getTeamTeamActiveCycle) GetCompletedScopeHistory() []*float64 {
	return v.CompletedScopeHistory
}

// GetCreatedAt returns getTeamTeamActiveCycle.CreatedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamActiveCycle) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetDescription returns getTeamTeamActiveCycle.Description, and is useful for accessing the field via an interface.
func (v *getTeamTeamActiveCycle) GetDescription() *string { return v.Description }

// GetEndsAt returns getTeamTeamActiveCycle.EndsAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamActiveCycle) GetEndsAt() *time.Time { return v.EndsAt }

// GetInProgressScopeHistory returns getTeamTeamActiveCycle.InProgressScopeHistory, and is useful for accessing the field via an interface.
func (v *getTeamTeamActiveCycle) GetInProgressScopeHistory() []*float64 {
	return v.InProgressScopeHistory
}

// GetIssueCountHistory returns getTeamTeamActiveCycle.IssueCountHistory, and is useful for accessing the field via an interface.
func (v *getTeamTeamActiveCycle) GetIssueCountHistory() []*float64 { return v.IssueCountHistory }

// GetName returns getTeamTeamActiveCycle.Name, and is useful for accessing the field via an interface.
func (v *getTeamTeamActiveCycle) GetName() *string { return v.Name }

// GetNumber returns getTeamTeamActiveCycle.Number, and is useful for accessing the field via an interface.
func (v *getTeamTeamActiveCycle) GetNumber() *float64 { return v.Number }

// GetProgress returns getTeamTeamActiveCycle.Progress, and is useful for accessing the field via an interface.
func (v *getTeamTeamActiveCycle) GetProgress() *float64 { return v.Progress }

// GetScopeHistory returns getTeamTeamActiveCycle.ScopeHistory, and is useful for accessing the field via an interface.
func (v *getTeamTeamActiveCycle) GetScopeHistory() []*float64 { return v.ScopeHistory }

// GetStartsAt returns getTeamTeamActiveCycle.StartsAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamActiveCycle) GetStartsAt() *time.Time { return v.StartsAt }

// GetUpdatedAt returns getTeamTeamActiveCycle.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamActiveCycle) GetUpdatedAt() *time.Time { return v.UpdatedAt }

func (v *getTeamTeamActiveCycle) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getTeamTeamActiveCycle
		ArchivedAt     json.RawMessage `json:"archivedAt"`
		AutoArchivedAt json.RawMessage `json:"autoArchivedAt"`
		CompletedAt    json.RawMessage `json:"completedAt"`
		CreatedAt      json.RawMessage `json:"createdAt"`
		EndsAt         json.RawMessage `json:"endsAt"`
		StartsAt       json.RawMessage `json:"startsAt"`
		UpdatedAt      json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getTeamTeamActiveCycle = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamActiveCycle.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.AutoArchivedAt
		src := firstPass.AutoArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamActiveCycle.AutoArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CompletedAt
		src := firstPass.CompletedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamActiveCycle.CompletedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamActiveCycle.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.EndsAt
		src := firstPass.EndsAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamActiveCycle.EndsAt: %w", err)
			}
		}
	}

	{
		dst := &v.StartsAt
		src := firstPass.StartsAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamActiveCycle.StartsAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamActiveCycle.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetTeamTeamActiveCycle struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AutoArchivedAt json.RawMessage `json:"autoArchivedAt"`

	CompletedAt json.RawMessage `json:"completedAt"`

	CompletedIssueCountHistory []*float64 `json:"completedIssueCountHistory"`

	CompletedScopeHistory []*float64 `json:"completedScopeHistory"`

	CreatedAt json.RawMessage `json:"createdAt"`

	Description *string `json:"description"`

	EndsAt json.RawMessage `json:"endsAt"`

	InProgressScopeHistory []*float64 `json:"inProgressScopeHistory"`

	IssueCountHistory []*float64 `json:"issueCountHistory"`

	Name *string `json:"name"`

	Number *float64 `json:"number"`

	Progress *float64 `json:"progress"`

	ScopeHistory []*float64 `json:"scopeHistory"`

	StartsAt json.RawMessage `json:"startsAt"`

	UpdatedAt json.RawMessage `json:"updatedAt"`
}

func (v *getTeamTeamActiveCycle) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getTeamTeamActiveCycle) __premarshalJSON() (*__premarshalgetTeamTeamActiveCycle, error) {
	var retval __premarshalgetTeamTeamActiveCycle

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamActiveCycle.ArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.AutoArchivedAt
		src := v.AutoArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamActiveCycle.AutoArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CompletedAt
		src := v.CompletedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamActiveCycle.CompletedAt: %w", err)
			}
		}
	}
	retval.CompletedIssueCountHistory = v.CompletedIssueCountHistory
	retval.CompletedScopeHistory = v.CompletedScopeHistory
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamActiveCycle.CreatedAt: %w", err)
			}
		}
	}
	retval.Description = v.Description
	{

		dst := &retval.EndsAt
		src := v.EndsAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamActiveCycle.EndsAt: %w", err)
			}
		}
	}
	retval.InProgressScopeHistory = v.InProgressScopeHistory
	retval.IssueCountHistory = v.IssueCountHistory
	retval.Name = v.Name
	retval.Number = v.Number
	retval.Progress = v.Progress
	retval.ScopeHistory = v.ScopeHistory
	{

		dst := &retval.StartsAt
		src := v.StartsAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamActiveCycle.StartsAt: %w", err)
			}
		}
	}
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamActiveCycle.UpdatedAt: %w", err)
			}
		}
	}
	return &retval, nil
}

// getTeamTeamDefaultIssueStateWorkflowState includes the requested fields of the GraphQL type WorkflowState.
// The GraphQL type's documentation follows.
//
// A state in a team workflow.
type getTeamTeamDefaultIssueStateWorkflowState struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The state's UI color as a HEX string.
	Color *string `json:"color"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Description of the state.
	Description *string `json:"description"`
	// The state's name.
	Name *string `json:"name"`
	// The position of the state in the team flow.
	Position *float64 `json:"position"`
	// The type of the state.
	Type *string `json:"type"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
}

// GetId returns getTeamTeamDefaultIssueStateWorkflowState.Id, and is useful for accessing the field via an interface.
func (v *getTeamTeamDefaultIssueStateWorkflowState) GetId() *string { return v.Id }

// GetArchivedAt returns getTeamTeamDefaultIssueStateWorkflowState.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamDefaultIssueStateWorkflowState) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetColor returns getTeamTeamDefaultIssueStateWorkflowState.Color, and is useful for accessing the field via an interface.
func (v *getTeamTeamDefaultIssueStateWorkflowState) GetColor() *string { return v.Color }

// GetCreatedAt returns getTeamTeamDefaultIssueStateWorkflowState.CreatedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamDefaultIssueStateWorkflowState) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetDescription returns getTeamTeamDefaultIssueStateWorkflowState.Description, and is useful for accessing the field via an interface.
func (v *getTeamTeamDefaultIssueStateWorkflowState) GetDescription() *string { return v.Description }

// GetName returns getTeamTeamDefaultIssueStateWorkflowState.Name, and is useful for accessing the field via an interface.
func (v *getTeamTeamDefaultIssueStateWorkflowState) GetName() *string { return v.Name }

// GetPosition returns getTeamTeamDefaultIssueStateWorkflowState.Position, and is useful for accessing the field via an interface.
func (v *getTeamTeamDefaultIssueStateWorkflowState) GetPosition() *float64 { return v.Position }

// GetType returns getTeamTeamDefaultIssueStateWorkflowState.Type, and is useful for accessing the field via an interface.
func (v *getTeamTeamDefaultIssueStateWorkflowState) GetType() *string { return v.Type }

// GetUpdatedAt returns getTeamTeamDefaultIssueStateWorkflowState.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamDefaultIssueStateWorkflowState) GetUpdatedAt() *time.Time { return v.UpdatedAt }

func (v *getTeamTeamDefaultIssueStateWorkflowState) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getTeamTeamDefaultIssueStateWorkflowState
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getTeamTeamDefaultIssueStateWorkflowState = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamDefaultIssueStateWorkflowState.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamDefaultIssueStateWorkflowState.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamDefaultIssueStateWorkflowState.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetTeamTeamDefaultIssueStateWorkflowState struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	Color *string `json:"color"`

	CreatedAt json.RawMessage `json:"createdAt"`

	Description *string `json:"description"`

	Name *string `json:"name"`

	Position *float64 `json:"position"`

	Type *string `json:"type"`

	UpdatedAt json.RawMessage `json:"updatedAt"`
}

func (v *getTeamTeamDefaultIssueStateWorkflowState) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getTeamTeamDefaultIssueStateWorkflowState) __premarshalJSON() (*__premarshalgetTeamTeamDefaultIssueStateWorkflowState, error) {
	var retval __premarshalgetTeamTeamDefaultIssueStateWorkflowState

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamDefaultIssueStateWorkflowState.ArchivedAt: %w", err)
			}
		}
	}
	retval.Color = v.Color
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamDefaultIssueStateWorkflowState.CreatedAt: %w", err)
			}
		}
	}
	retval.Description = v.Description
	retval.Name = v.Name
	retval.Position = v.Position
	retval.Type = v.Type
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamDefaultIssueStateWorkflowState.UpdatedAt: %w", err)
			}
		}
	}
	return &retval, nil
}

// getTeamTeamDefaultTemplateForMembersTemplate includes the requested fields of the GraphQL type Template.
// The GraphQL type's documentation follows.
//
// A template object used for creating entities faster.
type getTeamTeamDefaultTemplateForMembersTemplate struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// Template description.
	Description *string `json:"description"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// The entity type this template is for.
	Type *string `json:"type"`
	// The name of the template.
	Name *string `json:"name"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// Template data.
	TemplateData *json.RawMessage `json:"templateData"`
}

// GetId returns getTeamTeamDefaultTemplateForMembersTemplate.Id, and is useful for accessing the field via an interface.
func (v *getTeamTeamDefaultTemplateForMembersTemplate) GetId() *string { return v.Id }

// GetArchivedAt returns getTeamTeamDefaultTemplateForMembersTemplate.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamDefaultTemplateForMembersTemplate) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetDescription returns getTeamTeamDefaultTemplateForMembersTemplate.Description, and is useful for accessing the field via an interface.
func (v *getTeamTeamDefaultTemplateForMembersTemplate) GetDescription() *string { return v.Description }

// GetCreatedAt returns getTeamTeamDefaultTemplateForMembersTemplate.CreatedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamDefaultTemplateForMembersTemplate) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetType returns getTeamTeamDefaultTemplateForMembersTemplate.Type, and is useful for accessing the field via an interface.
func (v *getTeamTeamDefaultTemplateForMembersTemplate) GetType() *string { return v.Type }

// GetName returns getTeamTeamDefaultTemplateForMembersTemplate.Name, and is useful for accessing the field via an interface.
func (v *getTeamTeamDefaultTemplateForMembersTemplate) GetName() *string { return v.Name }

// GetUpdatedAt returns getTeamTeamDefaultTemplateForMembersTemplate.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamDefaultTemplateForMembersTemplate) GetUpdatedAt() *time.Time { return v.UpdatedAt }

// GetTemplateData returns getTeamTeamDefaultTemplateForMembersTemplate.TemplateData, and is useful for accessing the field via an interface.
func (v *getTeamTeamDefaultTemplateForMembersTemplate) GetTemplateData() *json.RawMessage {
	return v.TemplateData
}

func (v *getTeamTeamDefaultTemplateForMembersTemplate) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getTeamTeamDefaultTemplateForMembersTemplate
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getTeamTeamDefaultTemplateForMembersTemplate = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamDefaultTemplateForMembersTemplate.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamDefaultTemplateForMembersTemplate.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamDefaultTemplateForMembersTemplate.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetTeamTeamDefaultTemplateForMembersTemplate struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	Description *string `json:"description"`

	CreatedAt json.RawMessage `json:"createdAt"`

	Type *string `json:"type"`

	Name *string `json:"name"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	TemplateData *json.RawMessage `json:"templateData"`
}

func (v *getTeamTeamDefaultTemplateForMembersTemplate) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getTeamTeamDefaultTemplateForMembersTemplate) __premarshalJSON() (*__premarshalgetTeamTeamDefaultTemplateForMembersTemplate, error) {
	var retval __premarshalgetTeamTeamDefaultTemplateForMembersTemplate

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamDefaultTemplateForMembersTemplate.ArchivedAt: %w", err)
			}
		}
	}
	retval.Description = v.Description
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamDefaultTemplateForMembersTemplate.CreatedAt: %w", err)
			}
		}
	}
	retval.Type = v.Type
	retval.Name = v.Name
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamDefaultTemplateForMembersTemplate.UpdatedAt: %w", err)
			}
		}
	}
	retval.TemplateData = v.TemplateData
	return &retval, nil
}

// getTeamTeamDefaultTemplateForNonMembersTemplate includes the requested fields of the GraphQL type Template.
// The GraphQL type's documentation follows.
//
// A template object used for creating entities faster.
type getTeamTeamDefaultTemplateForNonMembersTemplate struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// Template description.
	Description *string `json:"description"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// The entity type this template is for.
	Type *string `json:"type"`
	// The name of the template.
	Name *string `json:"name"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// Template data.
	TemplateData *json.RawMessage `json:"templateData"`
}

// GetId returns getTeamTeamDefaultTemplateForNonMembersTemplate.Id, and is useful for accessing the field via an interface.
func (v *getTeamTeamDefaultTemplateForNonMembersTemplate) GetId() *string { return v.Id }

// GetArchivedAt returns getTeamTeamDefaultTemplateForNonMembersTemplate.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamDefaultTemplateForNonMembersTemplate) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetDescription returns getTeamTeamDefaultTemplateForNonMembersTemplate.Description, and is useful for accessing the field via an interface.
func (v *getTeamTeamDefaultTemplateForNonMembersTemplate) GetDescription() *string {
	return v.Description
}

// GetCreatedAt returns getTeamTeamDefaultTemplateForNonMembersTemplate.CreatedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamDefaultTemplateForNonMembersTemplate) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetType returns getTeamTeamDefaultTemplateForNonMembersTemplate.Type, and is useful for accessing the field via an interface.
func (v *getTeamTeamDefaultTemplateForNonMembersTemplate) GetType() *string { return v.Type }

// GetName returns getTeamTeamDefaultTemplateForNonMembersTemplate.Name, and is useful for accessing the field via an interface.
func (v *getTeamTeamDefaultTemplateForNonMembersTemplate) GetName() *string { return v.Name }

// GetUpdatedAt returns getTeamTeamDefaultTemplateForNonMembersTemplate.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamDefaultTemplateForNonMembersTemplate) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

// GetTemplateData returns getTeamTeamDefaultTemplateForNonMembersTemplate.TemplateData, and is useful for accessing the field via an interface.
func (v *getTeamTeamDefaultTemplateForNonMembersTemplate) GetTemplateData() *json.RawMessage {
	return v.TemplateData
}

func (v *getTeamTeamDefaultTemplateForNonMembersTemplate) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getTeamTeamDefaultTemplateForNonMembersTemplate
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getTeamTeamDefaultTemplateForNonMembersTemplate = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamDefaultTemplateForNonMembersTemplate.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamDefaultTemplateForNonMembersTemplate.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamDefaultTemplateForNonMembersTemplate.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetTeamTeamDefaultTemplateForNonMembersTemplate struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	Description *string `json:"description"`

	CreatedAt json.RawMessage `json:"createdAt"`

	Type *string `json:"type"`

	Name *string `json:"name"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	TemplateData *json.RawMessage `json:"templateData"`
}

func (v *getTeamTeamDefaultTemplateForNonMembersTemplate) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getTeamTeamDefaultTemplateForNonMembersTemplate) __premarshalJSON() (*__premarshalgetTeamTeamDefaultTemplateForNonMembersTemplate, error) {
	var retval __premarshalgetTeamTeamDefaultTemplateForNonMembersTemplate

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamDefaultTemplateForNonMembersTemplate.ArchivedAt: %w", err)
			}
		}
	}
	retval.Description = v.Description
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamDefaultTemplateForNonMembersTemplate.CreatedAt: %w", err)
			}
		}
	}
	retval.Type = v.Type
	retval.Name = v.Name
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamDefaultTemplateForNonMembersTemplate.UpdatedAt: %w", err)
			}
		}
	}
	retval.TemplateData = v.TemplateData
	return &retval, nil
}

// getTeamTeamDraftWorkflowState includes the requested fields of the GraphQL type WorkflowState.
// The GraphQL type's documentation follows.
//
// A state in a team workflow.
type getTeamTeamDraftWorkflowState struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The state's UI color as a HEX string.
	Color *string `json:"color"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Description of the state.
	Description *string `json:"description"`
	// The state's name.
	Name *string `json:"name"`
	// The position of the state in the team flow.
	Position *float64 `json:"position"`
	// The type of the state.
	Type *string `json:"type"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
}

// GetId returns getTeamTeamDraftWorkflowState.Id, and is useful for accessing the field via an interface.
func (v *getTeamTeamDraftWorkflowState) GetId() *string { return v.Id }

// GetArchivedAt returns getTeamTeamDraftWorkflowState.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamDraftWorkflowState) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetColor returns getTeamTeamDraftWorkflowState.Color, and is useful for accessing the field via an interface.
func (v *getTeamTeamDraftWorkflowState) GetColor() *string { return v.Color }

// GetCreatedAt returns getTeamTeamDraftWorkflowState.CreatedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamDraftWorkflowState) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetDescription returns getTeamTeamDraftWorkflowState.Description, and is useful for accessing the field via an interface.
func (v *getTeamTeamDraftWorkflowState) GetDescription() *string { return v.Description }

// GetName returns getTeamTeamDraftWorkflowState.Name, and is useful for accessing the field via an interface.
func (v *getTeamTeamDraftWorkflowState) GetName() *string { return v.Name }

// GetPosition returns getTeamTeamDraftWorkflowState.Position, and is useful for accessing the field via an interface.
func (v *getTeamTeamDraftWorkflowState) GetPosition() *float64 { return v.Position }

// GetType returns getTeamTeamDraftWorkflowState.Type, and is useful for accessing the field via an interface.
func (v *getTeamTeamDraftWorkflowState) GetType() *string { return v.Type }

// GetUpdatedAt returns getTeamTeamDraftWorkflowState.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamDraftWorkflowState) GetUpdatedAt() *time.Time { return v.UpdatedAt }

func (v *getTeamTeamDraftWorkflowState) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getTeamTeamDraftWorkflowState
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getTeamTeamDraftWorkflowState = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamDraftWorkflowState.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamDraftWorkflowState.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamDraftWorkflowState.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetTeamTeamDraftWorkflowState struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	Color *string `json:"color"`

	CreatedAt json.RawMessage `json:"createdAt"`

	Description *string `json:"description"`

	Name *string `json:"name"`

	Position *float64 `json:"position"`

	Type *string `json:"type"`

	UpdatedAt json.RawMessage `json:"updatedAt"`
}

func (v *getTeamTeamDraftWorkflowState) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getTeamTeamDraftWorkflowState) __premarshalJSON() (*__premarshalgetTeamTeamDraftWorkflowState, error) {
	var retval __premarshalgetTeamTeamDraftWorkflowState

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamDraftWorkflowState.ArchivedAt: %w", err)
			}
		}
	}
	retval.Color = v.Color
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamDraftWorkflowState.CreatedAt: %w", err)
			}
		}
	}
	retval.Description = v.Description
	retval.Name = v.Name
	retval.Position = v.Position
	retval.Type = v.Type
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamDraftWorkflowState.UpdatedAt: %w", err)
			}
		}
	}
	return &retval, nil
}

// getTeamTeamIntegrationsSettings includes the requested fields of the GraphQL type IntegrationsSettings.
// The GraphQL type's documentation follows.
//
// The configuration of all integrations for a project or a team.
type getTeamTeamIntegrationsSettings struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Whether to send a Slack message when a new issue is added to triage.
	SlackIssueAddedToTriage *bool `json:"slackIssueAddedToTriage"`
	// Whether to send a Slack message when a new issue is created for the project or the team.
	SlackIssueCreated *bool `json:"slackIssueCreated"`
	// Whether to send a Slack message when a comment is created on any of the project or team's issues.
	SlackIssueNewComment *bool `json:"slackIssueNewComment"`
	// Whether to send a Slack message when an SLA is breached
	SlackIssueSlaBreached *bool `json:"slackIssueSlaBreached"`
	// Whether to send a Slack message when an SLA is at high risk
	SlackIssueSlaHighRisk *bool `json:"slackIssueSlaHighRisk"`
	// Whether to send a Slack message when any of the project or team's issues has a change in status.
	SlackIssueStatusChangedAll *bool `json:"slackIssueStatusChangedAll"`
	// Whether to send a Slack message when any of the project or team's issues change to completed or cancelled.
	SlackIssueStatusChangedDone *bool `json:"slackIssueStatusChangedDone"`
	// Whether to send a Slack message when a project update is created.
	SlackProjectUpdateCreated *bool `json:"slackProjectUpdateCreated"`
	// Whether to send a new project update to team Slack channels.
	SlackProjectUpdateCreatedToTeam *bool `json:"slackProjectUpdateCreatedToTeam"`
	// Whether to send a new project update to workspace Slack channel.
	SlackProjectUpdateCreatedToWorkspace *bool `json:"slackProjectUpdateCreatedToWorkspace"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
}

// GetId returns getTeamTeamIntegrationsSettings.Id, and is useful for accessing the field via an interface.
func (v *getTeamTeamIntegrationsSettings) GetId() *string { return v.Id }

// GetArchivedAt returns getTeamTeamIntegrationsSettings.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamIntegrationsSettings) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetCreatedAt returns getTeamTeamIntegrationsSettings.CreatedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamIntegrationsSettings) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetSlackIssueAddedToTriage returns getTeamTeamIntegrationsSettings.SlackIssueAddedToTriage, and is useful for accessing the field via an interface.
func (v *getTeamTeamIntegrationsSettings) GetSlackIssueAddedToTriage() *bool {
	return v.SlackIssueAddedToTriage
}

// GetSlackIssueCreated returns getTeamTeamIntegrationsSettings.SlackIssueCreated, and is useful for accessing the field via an interface.
func (v *getTeamTeamIntegrationsSettings) GetSlackIssueCreated() *bool { return v.SlackIssueCreated }

// GetSlackIssueNewComment returns getTeamTeamIntegrationsSettings.SlackIssueNewComment, and is useful for accessing the field via an interface.
func (v *getTeamTeamIntegrationsSettings) GetSlackIssueNewComment() *bool {
	return v.SlackIssueNewComment
}

// GetSlackIssueSlaBreached returns getTeamTeamIntegrationsSettings.SlackIssueSlaBreached, and is useful for accessing the field via an interface.
func (v *getTeamTeamIntegrationsSettings) GetSlackIssueSlaBreached() *bool {
	return v.SlackIssueSlaBreached
}

// GetSlackIssueSlaHighRisk returns getTeamTeamIntegrationsSettings.SlackIssueSlaHighRisk, and is useful for accessing the field via an interface.
func (v *getTeamTeamIntegrationsSettings) GetSlackIssueSlaHighRisk() *bool {
	return v.SlackIssueSlaHighRisk
}

// GetSlackIssueStatusChangedAll returns getTeamTeamIntegrationsSettings.SlackIssueStatusChangedAll, and is useful for accessing the field via an interface.
func (v *getTeamTeamIntegrationsSettings) GetSlackIssueStatusChangedAll() *bool {
	return v.SlackIssueStatusChangedAll
}

// GetSlackIssueStatusChangedDone returns getTeamTeamIntegrationsSettings.SlackIssueStatusChangedDone, and is useful for accessing the field via an interface.
func (v *getTeamTeamIntegrationsSettings) GetSlackIssueStatusChangedDone() *bool {
	return v.SlackIssueStatusChangedDone
}

// GetSlackProjectUpdateCreated returns getTeamTeamIntegrationsSettings.SlackProjectUpdateCreated, and is useful for accessing the field via an interface.
func (v *getTeamTeamIntegrationsSettings) GetSlackProjectUpdateCreated() *bool {
	return v.SlackProjectUpdateCreated
}

// GetSlackProjectUpdateCreatedToTeam returns getTeamTeamIntegrationsSettings.SlackProjectUpdateCreatedToTeam, and is useful for accessing the field via an interface.
func (v *getTeamTeamIntegrationsSettings) GetSlackProjectUpdateCreatedToTeam() *bool {
	return v.SlackProjectUpdateCreatedToTeam
}

// GetSlackProjectUpdateCreatedToWorkspace returns getTeamTeamIntegrationsSettings.SlackProjectUpdateCreatedToWorkspace, and is useful for accessing the field via an interface.
func (v *getTeamTeamIntegrationsSettings) GetSlackProjectUpdateCreatedToWorkspace() *bool {
	return v.SlackProjectUpdateCreatedToWorkspace
}

// GetUpdatedAt returns getTeamTeamIntegrationsSettings.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamIntegrationsSettings) GetUpdatedAt() *time.Time { return v.UpdatedAt }

func (v *getTeamTeamIntegrationsSettings) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getTeamTeamIntegrationsSettings
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getTeamTeamIntegrationsSettings = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamIntegrationsSettings.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamIntegrationsSettings.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamIntegrationsSettings.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetTeamTeamIntegrationsSettings struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	CreatedAt json.RawMessage `json:"createdAt"`

	SlackIssueAddedToTriage *bool `json:"slackIssueAddedToTriage"`

	SlackIssueCreated *bool `json:"slackIssueCreated"`

	SlackIssueNewComment *bool `json:"slackIssueNewComment"`

	SlackIssueSlaBreached *bool `json:"slackIssueSlaBreached"`

	SlackIssueSlaHighRisk *bool `json:"slackIssueSlaHighRisk"`

	SlackIssueStatusChangedAll *bool `json:"slackIssueStatusChangedAll"`

	SlackIssueStatusChangedDone *bool `json:"slackIssueStatusChangedDone"`

	SlackProjectUpdateCreated *bool `json:"slackProjectUpdateCreated"`

	SlackProjectUpdateCreatedToTeam *bool `json:"slackProjectUpdateCreatedToTeam"`

	SlackProjectUpdateCreatedToWorkspace *bool `json:"slackProjectUpdateCreatedToWorkspace"`

	UpdatedAt json.RawMessage `json:"updatedAt"`
}

func (v *getTeamTeamIntegrationsSettings) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getTeamTeamIntegrationsSettings) __premarshalJSON() (*__premarshalgetTeamTeamIntegrationsSettings, error) {
	var retval __premarshalgetTeamTeamIntegrationsSettings

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamIntegrationsSettings.ArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamIntegrationsSettings.CreatedAt: %w", err)
			}
		}
	}
	retval.SlackIssueAddedToTriage = v.SlackIssueAddedToTriage
	retval.SlackIssueCreated = v.SlackIssueCreated
	retval.SlackIssueNewComment = v.SlackIssueNewComment
	retval.SlackIssueSlaBreached = v.SlackIssueSlaBreached
	retval.SlackIssueSlaHighRisk = v.SlackIssueSlaHighRisk
	retval.SlackIssueStatusChangedAll = v.SlackIssueStatusChangedAll
	retval.SlackIssueStatusChangedDone = v.SlackIssueStatusChangedDone
	retval.SlackProjectUpdateCreated = v.SlackProjectUpdateCreated
	retval.SlackProjectUpdateCreatedToTeam = v.SlackProjectUpdateCreatedToTeam
	retval.SlackProjectUpdateCreatedToWorkspace = v.SlackProjectUpdateCreatedToWorkspace
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamIntegrationsSettings.UpdatedAt: %w", err)
			}
		}
	}
	return &retval, nil
}

// getTeamTeamMarkedAsDuplicateWorkflowState includes the requested fields of the GraphQL type WorkflowState.
// The GraphQL type's documentation follows.
//
// A state in a team workflow.
type getTeamTeamMarkedAsDuplicateWorkflowState struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The state's UI color as a HEX string.
	Color *string `json:"color"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Description of the state.
	Description *string `json:"description"`
	// The state's name.
	Name *string `json:"name"`
	// The position of the state in the team flow.
	Position *float64 `json:"position"`
	// The type of the state.
	Type *string `json:"type"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
}

// GetId returns getTeamTeamMarkedAsDuplicateWorkflowState.Id, and is useful for accessing the field via an interface.
func (v *getTeamTeamMarkedAsDuplicateWorkflowState) GetId() *string { return v.Id }

// GetArchivedAt returns getTeamTeamMarkedAsDuplicateWorkflowState.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamMarkedAsDuplicateWorkflowState) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetColor returns getTeamTeamMarkedAsDuplicateWorkflowState.Color, and is useful for accessing the field via an interface.
func (v *getTeamTeamMarkedAsDuplicateWorkflowState) GetColor() *string { return v.Color }

// GetCreatedAt returns getTeamTeamMarkedAsDuplicateWorkflowState.CreatedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamMarkedAsDuplicateWorkflowState) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetDescription returns getTeamTeamMarkedAsDuplicateWorkflowState.Description, and is useful for accessing the field via an interface.
func (v *getTeamTeamMarkedAsDuplicateWorkflowState) GetDescription() *string { return v.Description }

// GetName returns getTeamTeamMarkedAsDuplicateWorkflowState.Name, and is useful for accessing the field via an interface.
func (v *getTeamTeamMarkedAsDuplicateWorkflowState) GetName() *string { return v.Name }

// GetPosition returns getTeamTeamMarkedAsDuplicateWorkflowState.Position, and is useful for accessing the field via an interface.
func (v *getTeamTeamMarkedAsDuplicateWorkflowState) GetPosition() *float64 { return v.Position }

// GetType returns getTeamTeamMarkedAsDuplicateWorkflowState.Type, and is useful for accessing the field via an interface.
func (v *getTeamTeamMarkedAsDuplicateWorkflowState) GetType() *string { return v.Type }

// GetUpdatedAt returns getTeamTeamMarkedAsDuplicateWorkflowState.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamMarkedAsDuplicateWorkflowState) GetUpdatedAt() *time.Time { return v.UpdatedAt }

func (v *getTeamTeamMarkedAsDuplicateWorkflowState) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getTeamTeamMarkedAsDuplicateWorkflowState
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getTeamTeamMarkedAsDuplicateWorkflowState = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamMarkedAsDuplicateWorkflowState.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamMarkedAsDuplicateWorkflowState.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamMarkedAsDuplicateWorkflowState.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetTeamTeamMarkedAsDuplicateWorkflowState struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	Color *string `json:"color"`

	CreatedAt json.RawMessage `json:"createdAt"`

	Description *string `json:"description"`

	Name *string `json:"name"`

	Position *float64 `json:"position"`

	Type *string `json:"type"`

	UpdatedAt json.RawMessage `json:"updatedAt"`
}

func (v *getTeamTeamMarkedAsDuplicateWorkflowState) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getTeamTeamMarkedAsDuplicateWorkflowState) __premarshalJSON() (*__premarshalgetTeamTeamMarkedAsDuplicateWorkflowState, error) {
	var retval __premarshalgetTeamTeamMarkedAsDuplicateWorkflowState

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamMarkedAsDuplicateWorkflowState.ArchivedAt: %w", err)
			}
		}
	}
	retval.Color = v.Color
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamMarkedAsDuplicateWorkflowState.CreatedAt: %w", err)
			}
		}
	}
	retval.Description = v.Description
	retval.Name = v.Name
	retval.Position = v.Position
	retval.Type = v.Type
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamMarkedAsDuplicateWorkflowState.UpdatedAt: %w", err)
			}
		}
	}
	return &retval, nil
}

// getTeamTeamOrganization includes the requested fields of the GraphQL type Organization.
// The GraphQL type's documentation follows.
//
// An organization. Organizations are root-level objects that contain user accounts and teams.
type getTeamTeamOrganization struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// Allowed authentication providers, empty array means all are allowed
	AllowedAuthServices []*string `json:"allowedAuthServices"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Number of issues in the organization.
	CreatedIssueCount *int `json:"createdIssueCount"`
	// The time at which deletion of the organization was requested.
	DeletionRequestedAt *time.Time `json:"-"`
	// How git branches are formatted. If null, default formatting will be used.
	GitBranchFormat *string `json:"gitBranchFormat"`
	// Whether the Git integration linkback messages should be sent to private repositories.
	GitLinkbackMessagesEnabled *bool `json:"gitLinkbackMessagesEnabled"`
	// Whether the Git integration linkback messages should be sent to public repositories.
	GitPublicLinkbackMessagesEnabled *bool `json:"gitPublicLinkbackMessagesEnabled"`
	// The organization's logo URL.
	LogoUrl *string `json:"logoUrl"`
	// The organization's name.
	Name *string `json:"name"`
	// Rolling 30-day total upload volume for the organization, in megabytes.
	PeriodUploadVolume *float64 `json:"periodUploadVolume"`
	// Previously used URL keys for the organization (last 3 are kept and redirected).
	PreviousUrlKeys []*string `json:"previousUrlKeys"`
	// The day at which to prompt for project updates.
	ProjectUpdateRemindersDay *Day `json:"projectUpdateRemindersDay"`
	// The hour at which to prompt for project updates.
	ProjectUpdateRemindersHour *float64 `json:"projectUpdateRemindersHour"`
	// The frequency at which to prompt for project updates.
	ProjectUpdatesReminderFrequency *ProjectUpdateReminderFrequency `json:"projectUpdatesReminderFrequency"`
	// The feature release channel the organization belongs to.
	ReleaseChannel *ReleaseChannel `json:"releaseChannel"`
	// Whether the organization is using a roadmap.
	RoadmapEnabled *bool `json:"roadmapEnabled"`
	// Whether SAML authentication is enabled for organization.
	SamlEnabled *bool `json:"samlEnabled"`
	// Whether SCIM provisioning is enabled for organization.
	ScimEnabled *bool `json:"scimEnabled"`
	// The time at which the trial of the plus plan will end.
	TrialEndsAt *time.Time `json:"-"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// The organization's unique URL key.
	UrlKey *string `json:"urlKey"`
	// Number of active users in the organization.
	UserCount *int `json:"userCount"`
}

// GetId returns getTeamTeamOrganization.Id, and is useful for accessing the field via an interface.
func (v *getTeamTeamOrganization) GetId() *string { return v.Id }

// GetAllowedAuthServices returns getTeamTeamOrganization.AllowedAuthServices, and is useful for accessing the field via an interface.
func (v *getTeamTeamOrganization) GetAllowedAuthServices() []*string { return v.AllowedAuthServices }

// GetArchivedAt returns getTeamTeamOrganization.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamOrganization) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetCreatedAt returns getTeamTeamOrganization.CreatedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamOrganization) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetCreatedIssueCount returns getTeamTeamOrganization.CreatedIssueCount, and is useful for accessing the field via an interface.
func (v *getTeamTeamOrganization) GetCreatedIssueCount() *int { return v.CreatedIssueCount }

// GetDeletionRequestedAt returns getTeamTeamOrganization.DeletionRequestedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamOrganization) GetDeletionRequestedAt() *time.Time { return v.DeletionRequestedAt }

// GetGitBranchFormat returns getTeamTeamOrganization.GitBranchFormat, and is useful for accessing the field via an interface.
func (v *getTeamTeamOrganization) GetGitBranchFormat() *string { return v.GitBranchFormat }

// GetGitLinkbackMessagesEnabled returns getTeamTeamOrganization.GitLinkbackMessagesEnabled, and is useful for accessing the field via an interface.
func (v *getTeamTeamOrganization) GetGitLinkbackMessagesEnabled() *bool {
	return v.GitLinkbackMessagesEnabled
}

// GetGitPublicLinkbackMessagesEnabled returns getTeamTeamOrganization.GitPublicLinkbackMessagesEnabled, and is useful for accessing the field via an interface.
func (v *getTeamTeamOrganization) GetGitPublicLinkbackMessagesEnabled() *bool {
	return v.GitPublicLinkbackMessagesEnabled
}

// GetLogoUrl returns getTeamTeamOrganization.LogoUrl, and is useful for accessing the field via an interface.
func (v *getTeamTeamOrganization) GetLogoUrl() *string { return v.LogoUrl }

// GetName returns getTeamTeamOrganization.Name, and is useful for accessing the field via an interface.
func (v *getTeamTeamOrganization) GetName() *string { return v.Name }

// GetPeriodUploadVolume returns getTeamTeamOrganization.PeriodUploadVolume, and is useful for accessing the field via an interface.
func (v *getTeamTeamOrganization) GetPeriodUploadVolume() *float64 { return v.PeriodUploadVolume }

// GetPreviousUrlKeys returns getTeamTeamOrganization.PreviousUrlKeys, and is useful for accessing the field via an interface.
func (v *getTeamTeamOrganization) GetPreviousUrlKeys() []*string { return v.PreviousUrlKeys }

// GetProjectUpdateRemindersDay returns getTeamTeamOrganization.ProjectUpdateRemindersDay, and is useful for accessing the field via an interface.
func (v *getTeamTeamOrganization) GetProjectUpdateRemindersDay() *Day {
	return v.ProjectUpdateRemindersDay
}

// GetProjectUpdateRemindersHour returns getTeamTeamOrganization.ProjectUpdateRemindersHour, and is useful for accessing the field via an interface.
func (v *getTeamTeamOrganization) GetProjectUpdateRemindersHour() *float64 {
	return v.ProjectUpdateRemindersHour
}

// GetProjectUpdatesReminderFrequency returns getTeamTeamOrganization.ProjectUpdatesReminderFrequency, and is useful for accessing the field via an interface.
func (v *getTeamTeamOrganization) GetProjectUpdatesReminderFrequency() *ProjectUpdateReminderFrequency {
	return v.ProjectUpdatesReminderFrequency
}

// GetReleaseChannel returns getTeamTeamOrganization.ReleaseChannel, and is useful for accessing the field via an interface.
func (v *getTeamTeamOrganization) GetReleaseChannel() *ReleaseChannel { return v.ReleaseChannel }

// GetRoadmapEnabled returns getTeamTeamOrganization.RoadmapEnabled, and is useful for accessing the field via an interface.
func (v *getTeamTeamOrganization) GetRoadmapEnabled() *bool { return v.RoadmapEnabled }

// GetSamlEnabled returns getTeamTeamOrganization.SamlEnabled, and is useful for accessing the field via an interface.
func (v *getTeamTeamOrganization) GetSamlEnabled() *bool { return v.SamlEnabled }

// GetScimEnabled returns getTeamTeamOrganization.ScimEnabled, and is useful for accessing the field via an interface.
func (v *getTeamTeamOrganization) GetScimEnabled() *bool { return v.ScimEnabled }

// GetTrialEndsAt returns getTeamTeamOrganization.TrialEndsAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamOrganization) GetTrialEndsAt() *time.Time { return v.TrialEndsAt }

// GetUpdatedAt returns getTeamTeamOrganization.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamOrganization) GetUpdatedAt() *time.Time { return v.UpdatedAt }

// GetUrlKey returns getTeamTeamOrganization.UrlKey, and is useful for accessing the field via an interface.
func (v *getTeamTeamOrganization) GetUrlKey() *string { return v.UrlKey }

// GetUserCount returns getTeamTeamOrganization.UserCount, and is useful for accessing the field via an interface.
func (v *getTeamTeamOrganization) GetUserCount() *int { return v.UserCount }

func (v *getTeamTeamOrganization) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getTeamTeamOrganization
		ArchivedAt          json.RawMessage `json:"archivedAt"`
		CreatedAt           json.RawMessage `json:"createdAt"`
		DeletionRequestedAt json.RawMessage `json:"deletionRequestedAt"`
		TrialEndsAt         json.RawMessage `json:"trialEndsAt"`
		UpdatedAt           json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getTeamTeamOrganization = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamOrganization.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamOrganization.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.DeletionRequestedAt
		src := firstPass.DeletionRequestedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamOrganization.DeletionRequestedAt: %w", err)
			}
		}
	}

	{
		dst := &v.TrialEndsAt
		src := firstPass.TrialEndsAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamOrganization.TrialEndsAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamOrganization.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetTeamTeamOrganization struct {
	Id *string `json:"id"`

	AllowedAuthServices []*string `json:"allowedAuthServices"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CreatedIssueCount *int `json:"createdIssueCount"`

	DeletionRequestedAt json.RawMessage `json:"deletionRequestedAt"`

	GitBranchFormat *string `json:"gitBranchFormat"`

	GitLinkbackMessagesEnabled *bool `json:"gitLinkbackMessagesEnabled"`

	GitPublicLinkbackMessagesEnabled *bool `json:"gitPublicLinkbackMessagesEnabled"`

	LogoUrl *string `json:"logoUrl"`

	Name *string `json:"name"`

	PeriodUploadVolume *float64 `json:"periodUploadVolume"`

	PreviousUrlKeys []*string `json:"previousUrlKeys"`

	ProjectUpdateRemindersDay *Day `json:"projectUpdateRemindersDay"`

	ProjectUpdateRemindersHour *float64 `json:"projectUpdateRemindersHour"`

	ProjectUpdatesReminderFrequency *ProjectUpdateReminderFrequency `json:"projectUpdatesReminderFrequency"`

	ReleaseChannel *ReleaseChannel `json:"releaseChannel"`

	RoadmapEnabled *bool `json:"roadmapEnabled"`

	SamlEnabled *bool `json:"samlEnabled"`

	ScimEnabled *bool `json:"scimEnabled"`

	TrialEndsAt json.RawMessage `json:"trialEndsAt"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	UrlKey *string `json:"urlKey"`

	UserCount *int `json:"userCount"`
}

func (v *getTeamTeamOrganization) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getTeamTeamOrganization) __premarshalJSON() (*__premarshalgetTeamTeamOrganization, error) {
	var retval __premarshalgetTeamTeamOrganization

	retval.Id = v.Id
	retval.AllowedAuthServices = v.AllowedAuthServices
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamOrganization.ArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamOrganization.CreatedAt: %w", err)
			}
		}
	}
	retval.CreatedIssueCount = v.CreatedIssueCount
	{

		dst := &retval.DeletionRequestedAt
		src := v.DeletionRequestedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamOrganization.DeletionRequestedAt: %w", err)
			}
		}
	}
	retval.GitBranchFormat = v.GitBranchFormat
	retval.GitLinkbackMessagesEnabled = v.GitLinkbackMessagesEnabled
	retval.GitPublicLinkbackMessagesEnabled = v.GitPublicLinkbackMessagesEnabled
	retval.LogoUrl = v.LogoUrl
	retval.Name = v.Name
	retval.PeriodUploadVolume = v.PeriodUploadVolume
	retval.PreviousUrlKeys = v.PreviousUrlKeys
	retval.ProjectUpdateRemindersDay = v.ProjectUpdateRemindersDay
	retval.ProjectUpdateRemindersHour = v.ProjectUpdateRemindersHour
	retval.ProjectUpdatesReminderFrequency = v.ProjectUpdatesReminderFrequency
	retval.ReleaseChannel = v.ReleaseChannel
	retval.RoadmapEnabled = v.RoadmapEnabled
	retval.SamlEnabled = v.SamlEnabled
	retval.ScimEnabled = v.ScimEnabled
	{

		dst := &retval.TrialEndsAt
		src := v.TrialEndsAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamOrganization.TrialEndsAt: %w", err)
			}
		}
	}
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamOrganization.UpdatedAt: %w", err)
			}
		}
	}
	retval.UrlKey = v.UrlKey
	retval.UserCount = v.UserCount
	return &retval, nil
}

// getTeamTeamReviewWorkflowState includes the requested fields of the GraphQL type WorkflowState.
// The GraphQL type's documentation follows.
//
// A state in a team workflow.
type getTeamTeamReviewWorkflowState struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The state's UI color as a HEX string.
	Color *string `json:"color"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Description of the state.
	Description *string `json:"description"`
	// The state's name.
	Name *string `json:"name"`
	// The position of the state in the team flow.
	Position *float64 `json:"position"`
	// The type of the state.
	Type *string `json:"type"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
}

// GetId returns getTeamTeamReviewWorkflowState.Id, and is useful for accessing the field via an interface.
func (v *getTeamTeamReviewWorkflowState) GetId() *string { return v.Id }

// GetArchivedAt returns getTeamTeamReviewWorkflowState.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamReviewWorkflowState) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetColor returns getTeamTeamReviewWorkflowState.Color, and is useful for accessing the field via an interface.
func (v *getTeamTeamReviewWorkflowState) GetColor() *string { return v.Color }

// GetCreatedAt returns getTeamTeamReviewWorkflowState.CreatedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamReviewWorkflowState) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetDescription returns getTeamTeamReviewWorkflowState.Description, and is useful for accessing the field via an interface.
func (v *getTeamTeamReviewWorkflowState) GetDescription() *string { return v.Description }

// GetName returns getTeamTeamReviewWorkflowState.Name, and is useful for accessing the field via an interface.
func (v *getTeamTeamReviewWorkflowState) GetName() *string { return v.Name }

// GetPosition returns getTeamTeamReviewWorkflowState.Position, and is useful for accessing the field via an interface.
func (v *getTeamTeamReviewWorkflowState) GetPosition() *float64 { return v.Position }

// GetType returns getTeamTeamReviewWorkflowState.Type, and is useful for accessing the field via an interface.
func (v *getTeamTeamReviewWorkflowState) GetType() *string { return v.Type }

// GetUpdatedAt returns getTeamTeamReviewWorkflowState.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamReviewWorkflowState) GetUpdatedAt() *time.Time { return v.UpdatedAt }

func (v *getTeamTeamReviewWorkflowState) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getTeamTeamReviewWorkflowState
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getTeamTeamReviewWorkflowState = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamReviewWorkflowState.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamReviewWorkflowState.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamReviewWorkflowState.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetTeamTeamReviewWorkflowState struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	Color *string `json:"color"`

	CreatedAt json.RawMessage `json:"createdAt"`

	Description *string `json:"description"`

	Name *string `json:"name"`

	Position *float64 `json:"position"`

	Type *string `json:"type"`

	UpdatedAt json.RawMessage `json:"updatedAt"`
}

func (v *getTeamTeamReviewWorkflowState) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getTeamTeamReviewWorkflowState) __premarshalJSON() (*__premarshalgetTeamTeamReviewWorkflowState, error) {
	var retval __premarshalgetTeamTeamReviewWorkflowState

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamReviewWorkflowState.ArchivedAt: %w", err)
			}
		}
	}
	retval.Color = v.Color
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamReviewWorkflowState.CreatedAt: %w", err)
			}
		}
	}
	retval.Description = v.Description
	retval.Name = v.Name
	retval.Position = v.Position
	retval.Type = v.Type
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamReviewWorkflowState.UpdatedAt: %w", err)
			}
		}
	}
	return &retval, nil
}

// getTeamTeamStartWorkflowState includes the requested fields of the GraphQL type WorkflowState.
// The GraphQL type's documentation follows.
//
// A state in a team workflow.
type getTeamTeamStartWorkflowState struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The state's UI color as a HEX string.
	Color *string `json:"color"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Description of the state.
	Description *string `json:"description"`
	// The state's name.
	Name *string `json:"name"`
	// The position of the state in the team flow.
	Position *float64 `json:"position"`
	// The type of the state.
	Type *string `json:"type"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
}

// GetId returns getTeamTeamStartWorkflowState.Id, and is useful for accessing the field via an interface.
func (v *getTeamTeamStartWorkflowState) GetId() *string { return v.Id }

// GetArchivedAt returns getTeamTeamStartWorkflowState.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamStartWorkflowState) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetColor returns getTeamTeamStartWorkflowState.Color, and is useful for accessing the field via an interface.
func (v *getTeamTeamStartWorkflowState) GetColor() *string { return v.Color }

// GetCreatedAt returns getTeamTeamStartWorkflowState.CreatedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamStartWorkflowState) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetDescription returns getTeamTeamStartWorkflowState.Description, and is useful for accessing the field via an interface.
func (v *getTeamTeamStartWorkflowState) GetDescription() *string { return v.Description }

// GetName returns getTeamTeamStartWorkflowState.Name, and is useful for accessing the field via an interface.
func (v *getTeamTeamStartWorkflowState) GetName() *string { return v.Name }

// GetPosition returns getTeamTeamStartWorkflowState.Position, and is useful for accessing the field via an interface.
func (v *getTeamTeamStartWorkflowState) GetPosition() *float64 { return v.Position }

// GetType returns getTeamTeamStartWorkflowState.Type, and is useful for accessing the field via an interface.
func (v *getTeamTeamStartWorkflowState) GetType() *string { return v.Type }

// GetUpdatedAt returns getTeamTeamStartWorkflowState.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamStartWorkflowState) GetUpdatedAt() *time.Time { return v.UpdatedAt }

func (v *getTeamTeamStartWorkflowState) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getTeamTeamStartWorkflowState
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getTeamTeamStartWorkflowState = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamStartWorkflowState.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamStartWorkflowState.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamStartWorkflowState.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetTeamTeamStartWorkflowState struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	Color *string `json:"color"`

	CreatedAt json.RawMessage `json:"createdAt"`

	Description *string `json:"description"`

	Name *string `json:"name"`

	Position *float64 `json:"position"`

	Type *string `json:"type"`

	UpdatedAt json.RawMessage `json:"updatedAt"`
}

func (v *getTeamTeamStartWorkflowState) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getTeamTeamStartWorkflowState) __premarshalJSON() (*__premarshalgetTeamTeamStartWorkflowState, error) {
	var retval __premarshalgetTeamTeamStartWorkflowState

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamStartWorkflowState.ArchivedAt: %w", err)
			}
		}
	}
	retval.Color = v.Color
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamStartWorkflowState.CreatedAt: %w", err)
			}
		}
	}
	retval.Description = v.Description
	retval.Name = v.Name
	retval.Position = v.Position
	retval.Type = v.Type
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamStartWorkflowState.UpdatedAt: %w", err)
			}
		}
	}
	return &retval, nil
}

// getTeamTeamTriageIssueStateWorkflowState includes the requested fields of the GraphQL type WorkflowState.
// The GraphQL type's documentation follows.
//
// A state in a team workflow.
type getTeamTeamTriageIssueStateWorkflowState struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The state's UI color as a HEX string.
	Color *string `json:"color"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Description of the state.
	Description *string `json:"description"`
	// The state's name.
	Name *string `json:"name"`
	// The position of the state in the team flow.
	Position *float64 `json:"position"`
	// The type of the state.
	Type *string `json:"type"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
}

// GetId returns getTeamTeamTriageIssueStateWorkflowState.Id, and is useful for accessing the field via an interface.
func (v *getTeamTeamTriageIssueStateWorkflowState) GetId() *string { return v.Id }

// GetArchivedAt returns getTeamTeamTriageIssueStateWorkflowState.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamTriageIssueStateWorkflowState) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetColor returns getTeamTeamTriageIssueStateWorkflowState.Color, and is useful for accessing the field via an interface.
func (v *getTeamTeamTriageIssueStateWorkflowState) GetColor() *string { return v.Color }

// GetCreatedAt returns getTeamTeamTriageIssueStateWorkflowState.CreatedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamTriageIssueStateWorkflowState) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetDescription returns getTeamTeamTriageIssueStateWorkflowState.Description, and is useful for accessing the field via an interface.
func (v *getTeamTeamTriageIssueStateWorkflowState) GetDescription() *string { return v.Description }

// GetName returns getTeamTeamTriageIssueStateWorkflowState.Name, and is useful for accessing the field via an interface.
func (v *getTeamTeamTriageIssueStateWorkflowState) GetName() *string { return v.Name }

// GetPosition returns getTeamTeamTriageIssueStateWorkflowState.Position, and is useful for accessing the field via an interface.
func (v *getTeamTeamTriageIssueStateWorkflowState) GetPosition() *float64 { return v.Position }

// GetType returns getTeamTeamTriageIssueStateWorkflowState.Type, and is useful for accessing the field via an interface.
func (v *getTeamTeamTriageIssueStateWorkflowState) GetType() *string { return v.Type }

// GetUpdatedAt returns getTeamTeamTriageIssueStateWorkflowState.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getTeamTeamTriageIssueStateWorkflowState) GetUpdatedAt() *time.Time { return v.UpdatedAt }

func (v *getTeamTeamTriageIssueStateWorkflowState) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getTeamTeamTriageIssueStateWorkflowState
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getTeamTeamTriageIssueStateWorkflowState = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamTriageIssueStateWorkflowState.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamTriageIssueStateWorkflowState.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getTeamTeamTriageIssueStateWorkflowState.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetTeamTeamTriageIssueStateWorkflowState struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	Color *string `json:"color"`

	CreatedAt json.RawMessage `json:"createdAt"`

	Description *string `json:"description"`

	Name *string `json:"name"`

	Position *float64 `json:"position"`

	Type *string `json:"type"`

	UpdatedAt json.RawMessage `json:"updatedAt"`
}

func (v *getTeamTeamTriageIssueStateWorkflowState) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getTeamTeamTriageIssueStateWorkflowState) __premarshalJSON() (*__premarshalgetTeamTeamTriageIssueStateWorkflowState, error) {
	var retval __premarshalgetTeamTeamTriageIssueStateWorkflowState

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamTriageIssueStateWorkflowState.ArchivedAt: %w", err)
			}
		}
	}
	retval.Color = v.Color
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamTriageIssueStateWorkflowState.CreatedAt: %w", err)
			}
		}
	}
	retval.Description = v.Description
	retval.Name = v.Name
	retval.Position = v.Position
	retval.Type = v.Type
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getTeamTeamTriageIssueStateWorkflowState.UpdatedAt: %w", err)
			}
		}
	}
	return &retval, nil
}

// getUserResponse is returned by getUser on success.
type getUserResponse struct {
	// One specific user.
	User *getUserUser `json:"user"`
}

// GetUser returns getUserResponse.User, and is useful for accessing the field via an interface.
func (v *getUserResponse) GetUser() *getUserUser { return v.User }

// getUserUser includes the requested fields of the GraphQL type User.
// The GraphQL type's documentation follows.
//
// A user that has access to the the resources of an organization.
type getUserUser struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// Whether the user account is active or disabled (suspended).
	Active *bool `json:"active"`
	// Whether the user is an organization administrator.
	Admin *bool `json:"admin"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// An URL to the user's avatar image.
	AvatarUrl *string `json:"avatarUrl"`
	// [DEPRECATED] Hash for the user to be used in calendar URLs.
	CalendarHash *string `json:"calendarHash"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Number of issues created.
	CreatedIssueCount *int `json:"createdIssueCount"`
	// A short description of the user, either its title or bio.
	Description *string `json:"description"`
	// Reason why is the account disabled.
	DisableReason *string `json:"disableReason"`
	// The user's display (nick) name. Unique within each organization.
	DisplayName *string `json:"displayName"`
	// The user's email address.
	Email *string `json:"email"`
	// Whether the user is a guest in the workspace and limited to accessing a subset of teams.
	Guest *bool `json:"guest"`
	// Unique hash for the user to be used in invite URLs.
	InviteHash *string `json:"inviteHash"`
	// Whether the user is the currently authenticated user.
	IsMe *bool `json:"isMe"`
	// The last time the user was seen online. If null, the user is currently online.
	LastSeen *time.Time `json:"-"`
	// The user's full name.
	Name *string `json:"name"`
	// The emoji to represent the user current status.
	StatusEmoji *string `json:"statusEmoji"`
	// The label of the user current status.
	StatusLabel *string `json:"statusLabel"`
	// A date at which the user current status should be cleared.
	StatusUntilAt *time.Time `json:"-"`
	// The local timezone of the user.
	Timezone *string `json:"timezone"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// User's profile URL.
	Url *string `json:"url"`
	// Organization the user belongs to.
	Organization *getUserUserOrganization `json:"organization"`
}

// GetId returns getUserUser.Id, and is useful for accessing the field via an interface.
func (v *getUserUser) GetId() *string { return v.Id }

// GetActive returns getUserUser.Active, and is useful for accessing the field via an interface.
func (v *getUserUser) GetActive() *bool { return v.Active }

// GetAdmin returns getUserUser.Admin, and is useful for accessing the field via an interface.
func (v *getUserUser) GetAdmin() *bool { return v.Admin }

// GetArchivedAt returns getUserUser.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getUserUser) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetAvatarUrl returns getUserUser.AvatarUrl, and is useful for accessing the field via an interface.
func (v *getUserUser) GetAvatarUrl() *string { return v.AvatarUrl }

// GetCalendarHash returns getUserUser.CalendarHash, and is useful for accessing the field via an interface.
func (v *getUserUser) GetCalendarHash() *string { return v.CalendarHash }

// GetCreatedAt returns getUserUser.CreatedAt, and is useful for accessing the field via an interface.
func (v *getUserUser) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetCreatedIssueCount returns getUserUser.CreatedIssueCount, and is useful for accessing the field via an interface.
func (v *getUserUser) GetCreatedIssueCount() *int { return v.CreatedIssueCount }

// GetDescription returns getUserUser.Description, and is useful for accessing the field via an interface.
func (v *getUserUser) GetDescription() *string { return v.Description }

// GetDisableReason returns getUserUser.DisableReason, and is useful for accessing the field via an interface.
func (v *getUserUser) GetDisableReason() *string { return v.DisableReason }

// GetDisplayName returns getUserUser.DisplayName, and is useful for accessing the field via an interface.
func (v *getUserUser) GetDisplayName() *string { return v.DisplayName }

// GetEmail returns getUserUser.Email, and is useful for accessing the field via an interface.
func (v *getUserUser) GetEmail() *string { return v.Email }

// GetGuest returns getUserUser.Guest, and is useful for accessing the field via an interface.
func (v *getUserUser) GetGuest() *bool { return v.Guest }

// GetInviteHash returns getUserUser.InviteHash, and is useful for accessing the field via an interface.
func (v *getUserUser) GetInviteHash() *string { return v.InviteHash }

// GetIsMe returns getUserUser.IsMe, and is useful for accessing the field via an interface.
func (v *getUserUser) GetIsMe() *bool { return v.IsMe }

// GetLastSeen returns getUserUser.LastSeen, and is useful for accessing the field via an interface.
func (v *getUserUser) GetLastSeen() *time.Time { return v.LastSeen }

// GetName returns getUserUser.Name, and is useful for accessing the field via an interface.
func (v *getUserUser) GetName() *string { return v.Name }

// GetStatusEmoji returns getUserUser.StatusEmoji, and is useful for accessing the field via an interface.
func (v *getUserUser) GetStatusEmoji() *string { return v.StatusEmoji }

// GetStatusLabel returns getUserUser.StatusLabel, and is useful for accessing the field via an interface.
func (v *getUserUser) GetStatusLabel() *string { return v.StatusLabel }

// GetStatusUntilAt returns getUserUser.StatusUntilAt, and is useful for accessing the field via an interface.
func (v *getUserUser) GetStatusUntilAt() *time.Time { return v.StatusUntilAt }

// GetTimezone returns getUserUser.Timezone, and is useful for accessing the field via an interface.
func (v *getUserUser) GetTimezone() *string { return v.Timezone }

// GetUpdatedAt returns getUserUser.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getUserUser) GetUpdatedAt() *time.Time { return v.UpdatedAt }

// GetUrl returns getUserUser.Url, and is useful for accessing the field via an interface.
func (v *getUserUser) GetUrl() *string { return v.Url }

// GetOrganization returns getUserUser.Organization, and is useful for accessing the field via an interface.
func (v *getUserUser) GetOrganization() *getUserUserOrganization { return v.Organization }

func (v *getUserUser) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getUserUser
		ArchivedAt    json.RawMessage `json:"archivedAt"`
		CreatedAt     json.RawMessage `json:"createdAt"`
		LastSeen      json.RawMessage `json:"lastSeen"`
		StatusUntilAt json.RawMessage `json:"statusUntilAt"`
		UpdatedAt     json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getUserUser = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getUserUser.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getUserUser.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.LastSeen
		src := firstPass.LastSeen
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getUserUser.LastSeen: %w", err)
			}
		}
	}

	{
		dst := &v.StatusUntilAt
		src := firstPass.StatusUntilAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getUserUser.StatusUntilAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getUserUser.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetUserUser struct {
	Id *string `json:"id"`

	Active *bool `json:"active"`

	Admin *bool `json:"admin"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AvatarUrl *string `json:"avatarUrl"`

	CalendarHash *string `json:"calendarHash"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CreatedIssueCount *int `json:"createdIssueCount"`

	Description *string `json:"description"`

	DisableReason *string `json:"disableReason"`

	DisplayName *string `json:"displayName"`

	Email *string `json:"email"`

	Guest *bool `json:"guest"`

	InviteHash *string `json:"inviteHash"`

	IsMe *bool `json:"isMe"`

	LastSeen json.RawMessage `json:"lastSeen"`

	Name *string `json:"name"`

	StatusEmoji *string `json:"statusEmoji"`

	StatusLabel *string `json:"statusLabel"`

	StatusUntilAt json.RawMessage `json:"statusUntilAt"`

	Timezone *string `json:"timezone"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	Url *string `json:"url"`

	Organization *getUserUserOrganization `json:"organization"`
}

func (v *getUserUser) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getUserUser) __premarshalJSON() (*__premarshalgetUserUser, error) {
	var retval __premarshalgetUserUser

	retval.Id = v.Id
	retval.Active = v.Active
	retval.Admin = v.Admin
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getUserUser.ArchivedAt: %w", err)
			}
		}
	}
	retval.AvatarUrl = v.AvatarUrl
	retval.CalendarHash = v.CalendarHash
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getUserUser.CreatedAt: %w", err)
			}
		}
	}
	retval.CreatedIssueCount = v.CreatedIssueCount
	retval.Description = v.Description
	retval.DisableReason = v.DisableReason
	retval.DisplayName = v.DisplayName
	retval.Email = v.Email
	retval.Guest = v.Guest
	retval.InviteHash = v.InviteHash
	retval.IsMe = v.IsMe
	{

		dst := &retval.LastSeen
		src := v.LastSeen
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getUserUser.LastSeen: %w", err)
			}
		}
	}
	retval.Name = v.Name
	retval.StatusEmoji = v.StatusEmoji
	retval.StatusLabel = v.StatusLabel
	{

		dst := &retval.StatusUntilAt
		src := v.StatusUntilAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getUserUser.StatusUntilAt: %w", err)
			}
		}
	}
	retval.Timezone = v.Timezone
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getUserUser.UpdatedAt: %w", err)
			}
		}
	}
	retval.Url = v.Url
	retval.Organization = v.Organization
	return &retval, nil
}

// getUserUserOrganization includes the requested fields of the GraphQL type Organization.
// The GraphQL type's documentation follows.
//
// An organization. Organizations are root-level objects that contain user accounts and teams.
type getUserUserOrganization struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// Allowed authentication providers, empty array means all are allowed
	AllowedAuthServices []*string `json:"allowedAuthServices"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Number of issues in the organization.
	CreatedIssueCount *int `json:"createdIssueCount"`
	// The time at which deletion of the organization was requested.
	DeletionRequestedAt *time.Time `json:"-"`
	// How git branches are formatted. If null, default formatting will be used.
	GitBranchFormat *string `json:"gitBranchFormat"`
	// Whether the Git integration linkback messages should be sent to private repositories.
	GitLinkbackMessagesEnabled *bool `json:"gitLinkbackMessagesEnabled"`
	// Whether the Git integration linkback messages should be sent to public repositories.
	GitPublicLinkbackMessagesEnabled *bool `json:"gitPublicLinkbackMessagesEnabled"`
	// The organization's logo URL.
	LogoUrl *string `json:"logoUrl"`
	// The organization's name.
	Name *string `json:"name"`
	// Rolling 30-day total upload volume for the organization, in megabytes.
	PeriodUploadVolume *float64 `json:"periodUploadVolume"`
	// Previously used URL keys for the organization (last 3 are kept and redirected).
	PreviousUrlKeys []*string `json:"previousUrlKeys"`
	// The day at which to prompt for project updates.
	ProjectUpdateRemindersDay *Day `json:"projectUpdateRemindersDay"`
	// The hour at which to prompt for project updates.
	ProjectUpdateRemindersHour *float64 `json:"projectUpdateRemindersHour"`
	// The frequency at which to prompt for project updates.
	ProjectUpdatesReminderFrequency *ProjectUpdateReminderFrequency `json:"projectUpdatesReminderFrequency"`
	// The feature release channel the organization belongs to.
	ReleaseChannel *ReleaseChannel `json:"releaseChannel"`
	// Whether the organization is using a roadmap.
	RoadmapEnabled *bool `json:"roadmapEnabled"`
	// Whether SAML authentication is enabled for organization.
	SamlEnabled *bool `json:"samlEnabled"`
	// Whether SCIM provisioning is enabled for organization.
	ScimEnabled *bool `json:"scimEnabled"`
	// The time at which the trial of the plus plan will end.
	TrialEndsAt *time.Time `json:"-"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// The organization's unique URL key.
	UrlKey *string `json:"urlKey"`
	// Number of active users in the organization.
	UserCount *int `json:"userCount"`
}

// GetId returns getUserUserOrganization.Id, and is useful for accessing the field via an interface.
func (v *getUserUserOrganization) GetId() *string { return v.Id }

// GetAllowedAuthServices returns getUserUserOrganization.AllowedAuthServices, and is useful for accessing the field via an interface.
func (v *getUserUserOrganization) GetAllowedAuthServices() []*string { return v.AllowedAuthServices }

// GetArchivedAt returns getUserUserOrganization.ArchivedAt, and is useful for accessing the field via an interface.
func (v *getUserUserOrganization) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetCreatedAt returns getUserUserOrganization.CreatedAt, and is useful for accessing the field via an interface.
func (v *getUserUserOrganization) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetCreatedIssueCount returns getUserUserOrganization.CreatedIssueCount, and is useful for accessing the field via an interface.
func (v *getUserUserOrganization) GetCreatedIssueCount() *int { return v.CreatedIssueCount }

// GetDeletionRequestedAt returns getUserUserOrganization.DeletionRequestedAt, and is useful for accessing the field via an interface.
func (v *getUserUserOrganization) GetDeletionRequestedAt() *time.Time { return v.DeletionRequestedAt }

// GetGitBranchFormat returns getUserUserOrganization.GitBranchFormat, and is useful for accessing the field via an interface.
func (v *getUserUserOrganization) GetGitBranchFormat() *string { return v.GitBranchFormat }

// GetGitLinkbackMessagesEnabled returns getUserUserOrganization.GitLinkbackMessagesEnabled, and is useful for accessing the field via an interface.
func (v *getUserUserOrganization) GetGitLinkbackMessagesEnabled() *bool {
	return v.GitLinkbackMessagesEnabled
}

// GetGitPublicLinkbackMessagesEnabled returns getUserUserOrganization.GitPublicLinkbackMessagesEnabled, and is useful for accessing the field via an interface.
func (v *getUserUserOrganization) GetGitPublicLinkbackMessagesEnabled() *bool {
	return v.GitPublicLinkbackMessagesEnabled
}

// GetLogoUrl returns getUserUserOrganization.LogoUrl, and is useful for accessing the field via an interface.
func (v *getUserUserOrganization) GetLogoUrl() *string { return v.LogoUrl }

// GetName returns getUserUserOrganization.Name, and is useful for accessing the field via an interface.
func (v *getUserUserOrganization) GetName() *string { return v.Name }

// GetPeriodUploadVolume returns getUserUserOrganization.PeriodUploadVolume, and is useful for accessing the field via an interface.
func (v *getUserUserOrganization) GetPeriodUploadVolume() *float64 { return v.PeriodUploadVolume }

// GetPreviousUrlKeys returns getUserUserOrganization.PreviousUrlKeys, and is useful for accessing the field via an interface.
func (v *getUserUserOrganization) GetPreviousUrlKeys() []*string { return v.PreviousUrlKeys }

// GetProjectUpdateRemindersDay returns getUserUserOrganization.ProjectUpdateRemindersDay, and is useful for accessing the field via an interface.
func (v *getUserUserOrganization) GetProjectUpdateRemindersDay() *Day {
	return v.ProjectUpdateRemindersDay
}

// GetProjectUpdateRemindersHour returns getUserUserOrganization.ProjectUpdateRemindersHour, and is useful for accessing the field via an interface.
func (v *getUserUserOrganization) GetProjectUpdateRemindersHour() *float64 {
	return v.ProjectUpdateRemindersHour
}

// GetProjectUpdatesReminderFrequency returns getUserUserOrganization.ProjectUpdatesReminderFrequency, and is useful for accessing the field via an interface.
func (v *getUserUserOrganization) GetProjectUpdatesReminderFrequency() *ProjectUpdateReminderFrequency {
	return v.ProjectUpdatesReminderFrequency
}

// GetReleaseChannel returns getUserUserOrganization.ReleaseChannel, and is useful for accessing the field via an interface.
func (v *getUserUserOrganization) GetReleaseChannel() *ReleaseChannel { return v.ReleaseChannel }

// GetRoadmapEnabled returns getUserUserOrganization.RoadmapEnabled, and is useful for accessing the field via an interface.
func (v *getUserUserOrganization) GetRoadmapEnabled() *bool { return v.RoadmapEnabled }

// GetSamlEnabled returns getUserUserOrganization.SamlEnabled, and is useful for accessing the field via an interface.
func (v *getUserUserOrganization) GetSamlEnabled() *bool { return v.SamlEnabled }

// GetScimEnabled returns getUserUserOrganization.ScimEnabled, and is useful for accessing the field via an interface.
func (v *getUserUserOrganization) GetScimEnabled() *bool { return v.ScimEnabled }

// GetTrialEndsAt returns getUserUserOrganization.TrialEndsAt, and is useful for accessing the field via an interface.
func (v *getUserUserOrganization) GetTrialEndsAt() *time.Time { return v.TrialEndsAt }

// GetUpdatedAt returns getUserUserOrganization.UpdatedAt, and is useful for accessing the field via an interface.
func (v *getUserUserOrganization) GetUpdatedAt() *time.Time { return v.UpdatedAt }

// GetUrlKey returns getUserUserOrganization.UrlKey, and is useful for accessing the field via an interface.
func (v *getUserUserOrganization) GetUrlKey() *string { return v.UrlKey }

// GetUserCount returns getUserUserOrganization.UserCount, and is useful for accessing the field via an interface.
func (v *getUserUserOrganization) GetUserCount() *int { return v.UserCount }

func (v *getUserUserOrganization) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*getUserUserOrganization
		ArchivedAt          json.RawMessage `json:"archivedAt"`
		CreatedAt           json.RawMessage `json:"createdAt"`
		DeletionRequestedAt json.RawMessage `json:"deletionRequestedAt"`
		TrialEndsAt         json.RawMessage `json:"trialEndsAt"`
		UpdatedAt           json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.getUserUserOrganization = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getUserUserOrganization.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getUserUserOrganization.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.DeletionRequestedAt
		src := firstPass.DeletionRequestedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getUserUserOrganization.DeletionRequestedAt: %w", err)
			}
		}
	}

	{
		dst := &v.TrialEndsAt
		src := firstPass.TrialEndsAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getUserUserOrganization.TrialEndsAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal getUserUserOrganization.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshalgetUserUserOrganization struct {
	Id *string `json:"id"`

	AllowedAuthServices []*string `json:"allowedAuthServices"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CreatedIssueCount *int `json:"createdIssueCount"`

	DeletionRequestedAt json.RawMessage `json:"deletionRequestedAt"`

	GitBranchFormat *string `json:"gitBranchFormat"`

	GitLinkbackMessagesEnabled *bool `json:"gitLinkbackMessagesEnabled"`

	GitPublicLinkbackMessagesEnabled *bool `json:"gitPublicLinkbackMessagesEnabled"`

	LogoUrl *string `json:"logoUrl"`

	Name *string `json:"name"`

	PeriodUploadVolume *float64 `json:"periodUploadVolume"`

	PreviousUrlKeys []*string `json:"previousUrlKeys"`

	ProjectUpdateRemindersDay *Day `json:"projectUpdateRemindersDay"`

	ProjectUpdateRemindersHour *float64 `json:"projectUpdateRemindersHour"`

	ProjectUpdatesReminderFrequency *ProjectUpdateReminderFrequency `json:"projectUpdatesReminderFrequency"`

	ReleaseChannel *ReleaseChannel `json:"releaseChannel"`

	RoadmapEnabled *bool `json:"roadmapEnabled"`

	SamlEnabled *bool `json:"samlEnabled"`

	ScimEnabled *bool `json:"scimEnabled"`

	TrialEndsAt json.RawMessage `json:"trialEndsAt"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	UrlKey *string `json:"urlKey"`

	UserCount *int `json:"userCount"`
}

func (v *getUserUserOrganization) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *getUserUserOrganization) __premarshalJSON() (*__premarshalgetUserUserOrganization, error) {
	var retval __premarshalgetUserUserOrganization

	retval.Id = v.Id
	retval.AllowedAuthServices = v.AllowedAuthServices
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getUserUserOrganization.ArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getUserUserOrganization.CreatedAt: %w", err)
			}
		}
	}
	retval.CreatedIssueCount = v.CreatedIssueCount
	{

		dst := &retval.DeletionRequestedAt
		src := v.DeletionRequestedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getUserUserOrganization.DeletionRequestedAt: %w", err)
			}
		}
	}
	retval.GitBranchFormat = v.GitBranchFormat
	retval.GitLinkbackMessagesEnabled = v.GitLinkbackMessagesEnabled
	retval.GitPublicLinkbackMessagesEnabled = v.GitPublicLinkbackMessagesEnabled
	retval.LogoUrl = v.LogoUrl
	retval.Name = v.Name
	retval.PeriodUploadVolume = v.PeriodUploadVolume
	retval.PreviousUrlKeys = v.PreviousUrlKeys
	retval.ProjectUpdateRemindersDay = v.ProjectUpdateRemindersDay
	retval.ProjectUpdateRemindersHour = v.ProjectUpdateRemindersHour
	retval.ProjectUpdatesReminderFrequency = v.ProjectUpdatesReminderFrequency
	retval.ReleaseChannel = v.ReleaseChannel
	retval.RoadmapEnabled = v.RoadmapEnabled
	retval.SamlEnabled = v.SamlEnabled
	retval.ScimEnabled = v.ScimEnabled
	{

		dst := &retval.TrialEndsAt
		src := v.TrialEndsAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getUserUserOrganization.TrialEndsAt: %w", err)
			}
		}
	}
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal getUserUserOrganization.UpdatedAt: %w", err)
			}
		}
	}
	retval.UrlKey = v.UrlKey
	retval.UserCount = v.UserCount
	return &retval, nil
}

// listAttachmentsAttachmentsAttachmentConnection includes the requested fields of the GraphQL type AttachmentConnection.
type listAttachmentsAttachmentsAttachmentConnection struct {
	PageInfo *listAttachmentsAttachmentsAttachmentConnectionPageInfo          `json:"pageInfo"`
	Nodes    []*listAttachmentsAttachmentsAttachmentConnectionNodesAttachment `json:"nodes"`
}

// GetPageInfo returns listAttachmentsAttachmentsAttachmentConnection.PageInfo, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnection) GetPageInfo() *listAttachmentsAttachmentsAttachmentConnectionPageInfo {
	return v.PageInfo
}

// GetNodes returns listAttachmentsAttachmentsAttachmentConnection.Nodes, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnection) GetNodes() []*listAttachmentsAttachmentsAttachmentConnectionNodesAttachment {
	return v.Nodes
}

// listAttachmentsAttachmentsAttachmentConnectionNodesAttachment includes the requested fields of the GraphQL type Attachment.
// The GraphQL type's documentation follows.
//
// Issue attachment (e.g. support ticket, pull request).
type listAttachmentsAttachmentsAttachmentConnectionNodesAttachment struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Indicates if attachments for the same source application should be grouped in the Linear UI.
	GroupBySource *bool `json:"groupBySource"`
	// Custom metadata related to the attachment.
	Metadata *json.RawMessage `json:"metadata"`
	// Information about the source which created the attachment.
	Source *json.RawMessage `json:"source"`
	// An accessor helper to source.type, defines the source type of the attachment.
	SourceType *string `json:"sourceType"`
	// Content for the subtitle line in the Linear attachment widget.
	Subtitle *string `json:"subtitle"`
	// Content for the title line in the Linear attachment widget.
	Title *string `json:"title"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// Location of the attachment which is also used as an identifier.
	Url *string `json:"url"`
	// The creator of the attachment.
	Creator *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser `json:"creator"`
	// The issue this attachment belongs to.
	Issue *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue `json:"issue"`
}

// GetId returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachment.Id, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachment) GetId() *string { return v.Id }

// GetArchivedAt returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachment.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachment) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetCreatedAt returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachment.CreatedAt, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachment) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetGroupBySource returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachment.GroupBySource, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachment) GetGroupBySource() *bool {
	return v.GroupBySource
}

// GetMetadata returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachment.Metadata, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachment) GetMetadata() *json.RawMessage {
	return v.Metadata
}

// GetSource returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachment.Source, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachment) GetSource() *json.RawMessage {
	return v.Source
}

// GetSourceType returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachment.SourceType, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachment) GetSourceType() *string {
	return v.SourceType
}

// GetSubtitle returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachment.Subtitle, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachment) GetSubtitle() *string {
	return v.Subtitle
}

// GetTitle returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachment.Title, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachment) GetTitle() *string {
	return v.Title
}

// GetUpdatedAt returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachment.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachment) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

// GetUrl returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachment.Url, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachment) GetUrl() *string {
	return v.Url
}

// GetCreator returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachment.Creator, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachment) GetCreator() *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser {
	return v.Creator
}

// GetIssue returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachment.Issue, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachment) GetIssue() *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue {
	return v.Issue
}

func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachment) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listAttachmentsAttachmentsAttachmentConnectionNodesAttachment
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listAttachmentsAttachmentsAttachmentConnectionNodesAttachment = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listAttachmentsAttachmentsAttachmentConnectionNodesAttachment.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listAttachmentsAttachmentsAttachmentConnectionNodesAttachment.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listAttachmentsAttachmentsAttachmentConnectionNodesAttachment.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistAttachmentsAttachmentsAttachmentConnectionNodesAttachment struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	CreatedAt json.RawMessage `json:"createdAt"`

	GroupBySource *bool `json:"groupBySource"`

	Metadata *json.RawMessage `json:"metadata"`

	Source *json.RawMessage `json:"source"`

	SourceType *string `json:"sourceType"`

	Subtitle *string `json:"subtitle"`

	Title *string `json:"title"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	Url *string `json:"url"`

	Creator *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser `json:"creator"`

	Issue *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue `json:"issue"`
}

func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachment) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachment) __premarshalJSON() (*__premarshallistAttachmentsAttachmentsAttachmentConnectionNodesAttachment, error) {
	var retval __premarshallistAttachmentsAttachmentsAttachmentConnectionNodesAttachment

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listAttachmentsAttachmentsAttachmentConnectionNodesAttachment.ArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listAttachmentsAttachmentsAttachmentConnectionNodesAttachment.CreatedAt: %w", err)
			}
		}
	}
	retval.GroupBySource = v.GroupBySource
	retval.Metadata = v.Metadata
	retval.Source = v.Source
	retval.SourceType = v.SourceType
	retval.Subtitle = v.Subtitle
	retval.Title = v.Title
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listAttachmentsAttachmentsAttachmentConnectionNodesAttachment.UpdatedAt: %w", err)
			}
		}
	}
	retval.Url = v.Url
	retval.Creator = v.Creator
	retval.Issue = v.Issue
	return &retval, nil
}

// listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser includes the requested fields of the GraphQL type User.
// The GraphQL type's documentation follows.
//
// A user that has access to the the resources of an organization.
type listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// Whether the user account is active or disabled (suspended).
	Active *bool `json:"active"`
	// Whether the user is an organization administrator.
	Admin *bool `json:"admin"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// An URL to the user's avatar image.
	AvatarUrl *string `json:"avatarUrl"`
	// [DEPRECATED] Hash for the user to be used in calendar URLs.
	CalendarHash *string `json:"calendarHash"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Number of issues created.
	CreatedIssueCount *int `json:"createdIssueCount"`
	// A short description of the user, either its title or bio.
	Description *string `json:"description"`
	// Reason why is the account disabled.
	DisableReason *string `json:"disableReason"`
	// The user's display (nick) name. Unique within each organization.
	DisplayName *string `json:"displayName"`
	// The user's email address.
	Email *string `json:"email"`
	// Whether the user is a guest in the workspace and limited to accessing a subset of teams.
	Guest *bool `json:"guest"`
	// Unique hash for the user to be used in invite URLs.
	InviteHash *string `json:"inviteHash"`
	// Whether the user is the currently authenticated user.
	IsMe *bool `json:"isMe"`
	// The last time the user was seen online. If null, the user is currently online.
	LastSeen *time.Time `json:"-"`
	// The user's full name.
	Name *string `json:"name"`
	// The emoji to represent the user current status.
	StatusEmoji *string `json:"statusEmoji"`
	// The label of the user current status.
	StatusLabel *string `json:"statusLabel"`
	// A date at which the user current status should be cleared.
	StatusUntilAt *time.Time `json:"-"`
	// The local timezone of the user.
	Timezone *string `json:"timezone"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// User's profile URL.
	Url *string `json:"url"`
}

// GetId returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser.Id, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser) GetId() *string {
	return v.Id
}

// GetActive returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser.Active, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser) GetActive() *bool {
	return v.Active
}

// GetAdmin returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser.Admin, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser) GetAdmin() *bool {
	return v.Admin
}

// GetArchivedAt returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetAvatarUrl returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser.AvatarUrl, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser) GetAvatarUrl() *string {
	return v.AvatarUrl
}

// GetCalendarHash returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser.CalendarHash, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser) GetCalendarHash() *string {
	return v.CalendarHash
}

// GetCreatedAt returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser.CreatedAt, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetCreatedIssueCount returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser.CreatedIssueCount, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser) GetCreatedIssueCount() *int {
	return v.CreatedIssueCount
}

// GetDescription returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser.Description, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser) GetDescription() *string {
	return v.Description
}

// GetDisableReason returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser.DisableReason, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser) GetDisableReason() *string {
	return v.DisableReason
}

// GetDisplayName returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser.DisplayName, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser) GetDisplayName() *string {
	return v.DisplayName
}

// GetEmail returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser.Email, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser) GetEmail() *string {
	return v.Email
}

// GetGuest returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser.Guest, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser) GetGuest() *bool {
	return v.Guest
}

// GetInviteHash returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser.InviteHash, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser) GetInviteHash() *string {
	return v.InviteHash
}

// GetIsMe returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser.IsMe, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser) GetIsMe() *bool {
	return v.IsMe
}

// GetLastSeen returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser.LastSeen, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser) GetLastSeen() *time.Time {
	return v.LastSeen
}

// GetName returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser.Name, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser) GetName() *string {
	return v.Name
}

// GetStatusEmoji returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser.StatusEmoji, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser) GetStatusEmoji() *string {
	return v.StatusEmoji
}

// GetStatusLabel returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser.StatusLabel, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser) GetStatusLabel() *string {
	return v.StatusLabel
}

// GetStatusUntilAt returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser.StatusUntilAt, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser) GetStatusUntilAt() *time.Time {
	return v.StatusUntilAt
}

// GetTimezone returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser.Timezone, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser) GetTimezone() *string {
	return v.Timezone
}

// GetUpdatedAt returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

// GetUrl returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser.Url, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser) GetUrl() *string {
	return v.Url
}

func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser
		ArchivedAt    json.RawMessage `json:"archivedAt"`
		CreatedAt     json.RawMessage `json:"createdAt"`
		LastSeen      json.RawMessage `json:"lastSeen"`
		StatusUntilAt json.RawMessage `json:"statusUntilAt"`
		UpdatedAt     json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.LastSeen
		src := firstPass.LastSeen
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser.LastSeen: %w", err)
			}
		}
	}

	{
		dst := &v.StatusUntilAt
		src := firstPass.StatusUntilAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser.StatusUntilAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser struct {
	Id *string `json:"id"`

	Active *bool `json:"active"`

	Admin *bool `json:"admin"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AvatarUrl *string `json:"avatarUrl"`

	CalendarHash *string `json:"calendarHash"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CreatedIssueCount *int `json:"createdIssueCount"`

	Description *string `json:"description"`

	DisableReason *string `json:"disableReason"`

	DisplayName *string `json:"displayName"`

	Email *string `json:"email"`

	Guest *bool `json:"guest"`

	InviteHash *string `json:"inviteHash"`

	IsMe *bool `json:"isMe"`

	LastSeen json.RawMessage `json:"lastSeen"`

	Name *string `json:"name"`

	StatusEmoji *string `json:"statusEmoji"`

	StatusLabel *string `json:"statusLabel"`

	StatusUntilAt json.RawMessage `json:"statusUntilAt"`

	Timezone *string `json:"timezone"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	Url *string `json:"url"`
}

func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser) __premarshalJSON() (*__premarshallistAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser, error) {
	var retval __premarshallistAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser

	retval.Id = v.Id
	retval.Active = v.Active
	retval.Admin = v.Admin
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser.ArchivedAt: %w", err)
			}
		}
	}
	retval.AvatarUrl = v.AvatarUrl
	retval.CalendarHash = v.CalendarHash
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser.CreatedAt: %w", err)
			}
		}
	}
	retval.CreatedIssueCount = v.CreatedIssueCount
	retval.Description = v.Description
	retval.DisableReason = v.DisableReason
	retval.DisplayName = v.DisplayName
	retval.Email = v.Email
	retval.Guest = v.Guest
	retval.InviteHash = v.InviteHash
	retval.IsMe = v.IsMe
	{

		dst := &retval.LastSeen
		src := v.LastSeen
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser.LastSeen: %w", err)
			}
		}
	}
	retval.Name = v.Name
	retval.StatusEmoji = v.StatusEmoji
	retval.StatusLabel = v.StatusLabel
	{

		dst := &retval.StatusUntilAt
		src := v.StatusUntilAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser.StatusUntilAt: %w", err)
			}
		}
	}
	retval.Timezone = v.Timezone
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentCreatorUser.UpdatedAt: %w", err)
			}
		}
	}
	retval.Url = v.Url
	return &retval, nil
}

// listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue includes the requested fields of the GraphQL type Issue.
// The GraphQL type's documentation follows.
//
// An issue.
type listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The issue's unique number.
	Number *float64 `json:"number"`
	// The issue's title.
	Title *string `json:"title"`
	// The issue's description in markdown format.
	Description *string `json:"description"`
	// The priority of the issue. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low.
	Priority *float64 `json:"priority"`
	// The estimate of the complexity of the issue..
	Estimate *float64 `json:"estimate"`
	// The order of the item in relation to other items in the organization.
	SortOrder *float64 `json:"sortOrder"`
	// The time at which the issue was moved into started state.
	StartedAt *time.Time `json:"-"`
	// The time at which the issue was moved into completed state.
	CompletedAt *time.Time `json:"-"`
	// The time at which the issue was moved into canceled state.
	CanceledAt *time.Time `json:"-"`
	// The time at which the issue was automatically closed by the auto pruning process.
	AutoClosedAt *time.Time `json:"-"`
	// The time at which the issue was automatically archived by the auto pruning process.
	AutoArchivedAt *time.Time `json:"-"`
	// The date at which the issue is due.
	DueDate *time.Time `json:"-"`
	// A flag that indicates whether the issue is in the trash bin.
	Trashed *bool `json:"trashed"`
	// The time until an issue will be snoozed in Triage view.
	SnoozedUntilAt *time.Time `json:"-"`
	// Previous identifiers of the issue if it has been moved between teams.
	PreviousIdentifiers []*string `json:"previousIdentifiers"`
	// The order of the item in the sub-issue list. Only set if the issue has a parent.
	SubIssueSortOrder *float64 `json:"subIssueSortOrder"`
	// Label for the priority.
	PriorityLabel *string `json:"priorityLabel"`
	// Issue's human readable identifier (e.g. ENG-123).
	Identifier *string `json:"identifier"`
	// Issue URL.
	Url *string `json:"url"`
	// Suggested branch name for the issue.
	BranchName *string `json:"branchName"`
	// Returns the number of Attachment resources which are created by customer support ticketing systems (e.g. Zendesk).
	CustomerTicketCount *int `json:"customerTicketCount"`
}

// GetId returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.Id, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue) GetId() *string {
	return v.Id
}

// GetCreatedAt returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.CreatedAt, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetUpdatedAt returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

// GetArchivedAt returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetNumber returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.Number, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue) GetNumber() *float64 {
	return v.Number
}

// GetTitle returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.Title, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue) GetTitle() *string {
	return v.Title
}

// GetDescription returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.Description, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue) GetDescription() *string {
	return v.Description
}

// GetPriority returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.Priority, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue) GetPriority() *float64 {
	return v.Priority
}

// GetEstimate returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.Estimate, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue) GetEstimate() *float64 {
	return v.Estimate
}

// GetSortOrder returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.SortOrder, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue) GetSortOrder() *float64 {
	return v.SortOrder
}

// GetStartedAt returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.StartedAt, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue) GetStartedAt() *time.Time {
	return v.StartedAt
}

// GetCompletedAt returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.CompletedAt, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue) GetCompletedAt() *time.Time {
	return v.CompletedAt
}

// GetCanceledAt returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.CanceledAt, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue) GetCanceledAt() *time.Time {
	return v.CanceledAt
}

// GetAutoClosedAt returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.AutoClosedAt, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue) GetAutoClosedAt() *time.Time {
	return v.AutoClosedAt
}

// GetAutoArchivedAt returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.AutoArchivedAt, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue) GetAutoArchivedAt() *time.Time {
	return v.AutoArchivedAt
}

// GetDueDate returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.DueDate, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue) GetDueDate() *time.Time {
	return v.DueDate
}

// GetTrashed returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.Trashed, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue) GetTrashed() *bool {
	return v.Trashed
}

// GetSnoozedUntilAt returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.SnoozedUntilAt, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue) GetSnoozedUntilAt() *time.Time {
	return v.SnoozedUntilAt
}

// GetPreviousIdentifiers returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.PreviousIdentifiers, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue) GetPreviousIdentifiers() []*string {
	return v.PreviousIdentifiers
}

// GetSubIssueSortOrder returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.SubIssueSortOrder, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue) GetSubIssueSortOrder() *float64 {
	return v.SubIssueSortOrder
}

// GetPriorityLabel returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.PriorityLabel, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue) GetPriorityLabel() *string {
	return v.PriorityLabel
}

// GetIdentifier returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.Identifier, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue) GetIdentifier() *string {
	return v.Identifier
}

// GetUrl returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.Url, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue) GetUrl() *string {
	return v.Url
}

// GetBranchName returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.BranchName, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue) GetBranchName() *string {
	return v.BranchName
}

// GetCustomerTicketCount returns listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.CustomerTicketCount, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue) GetCustomerTicketCount() *int {
	return v.CustomerTicketCount
}

func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue
		CreatedAt      json.RawMessage `json:"createdAt"`
		UpdatedAt      json.RawMessage `json:"updatedAt"`
		ArchivedAt     json.RawMessage `json:"archivedAt"`
		StartedAt      json.RawMessage `json:"startedAt"`
		CompletedAt    json.RawMessage `json:"completedAt"`
		CanceledAt     json.RawMessage `json:"canceledAt"`
		AutoClosedAt   json.RawMessage `json:"autoClosedAt"`
		AutoArchivedAt json.RawMessage `json:"autoArchivedAt"`
		DueDate        json.RawMessage `json:"dueDate"`
		SnoozedUntilAt json.RawMessage `json:"snoozedUntilAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.UpdatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.StartedAt
		src := firstPass.StartedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.StartedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CompletedAt
		src := firstPass.CompletedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.CompletedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CanceledAt
		src := firstPass.CanceledAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.CanceledAt: %w", err)
			}
		}
	}

	{
		dst := &v.AutoClosedAt
		src := firstPass.AutoClosedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.AutoClosedAt: %w", err)
			}
		}
	}

	{
		dst := &v.AutoArchivedAt
		src := firstPass.AutoArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.AutoArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.DueDate
		src := firstPass.DueDate
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.DueDate: %w", err)
			}
		}
	}

	{
		dst := &v.SnoozedUntilAt
		src := firstPass.SnoozedUntilAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.SnoozedUntilAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue struct {
	Id *string `json:"id"`

	CreatedAt json.RawMessage `json:"createdAt"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	Number *float64 `json:"number"`

	Title *string `json:"title"`

	Description *string `json:"description"`

	Priority *float64 `json:"priority"`

	Estimate *float64 `json:"estimate"`

	SortOrder *float64 `json:"sortOrder"`

	StartedAt json.RawMessage `json:"startedAt"`

	CompletedAt json.RawMessage `json:"completedAt"`

	CanceledAt json.RawMessage `json:"canceledAt"`

	AutoClosedAt json.RawMessage `json:"autoClosedAt"`

	AutoArchivedAt json.RawMessage `json:"autoArchivedAt"`

	DueDate json.RawMessage `json:"dueDate"`

	Trashed *bool `json:"trashed"`

	SnoozedUntilAt json.RawMessage `json:"snoozedUntilAt"`

	PreviousIdentifiers []*string `json:"previousIdentifiers"`

	SubIssueSortOrder *float64 `json:"subIssueSortOrder"`

	PriorityLabel *string `json:"priorityLabel"`

	Identifier *string `json:"identifier"`

	Url *string `json:"url"`

	BranchName *string `json:"branchName"`

	CustomerTicketCount *int `json:"customerTicketCount"`
}

func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue) __premarshalJSON() (*__premarshallistAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue, error) {
	var retval __premarshallistAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue

	retval.Id = v.Id
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.CreatedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.UpdatedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.ArchivedAt: %w", err)
			}
		}
	}
	retval.Number = v.Number
	retval.Title = v.Title
	retval.Description = v.Description
	retval.Priority = v.Priority
	retval.Estimate = v.Estimate
	retval.SortOrder = v.SortOrder
	{

		dst := &retval.StartedAt
		src := v.StartedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.StartedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CompletedAt
		src := v.CompletedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.CompletedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CanceledAt
		src := v.CanceledAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.CanceledAt: %w", err)
			}
		}
	}
	{

		dst := &retval.AutoClosedAt
		src := v.AutoClosedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.AutoClosedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.AutoArchivedAt
		src := v.AutoArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.AutoArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.DueDate
		src := v.DueDate
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.DueDate: %w", err)
			}
		}
	}
	retval.Trashed = v.Trashed
	{

		dst := &retval.SnoozedUntilAt
		src := v.SnoozedUntilAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listAttachmentsAttachmentsAttachmentConnectionNodesAttachmentIssue.SnoozedUntilAt: %w", err)
			}
		}
	}
	retval.PreviousIdentifiers = v.PreviousIdentifiers
	retval.SubIssueSortOrder = v.SubIssueSortOrder
	retval.PriorityLabel = v.PriorityLabel
	retval.Identifier = v.Identifier
	retval.Url = v.Url
	retval.BranchName = v.BranchName
	retval.CustomerTicketCount = v.CustomerTicketCount
	return &retval, nil
}

// listAttachmentsAttachmentsAttachmentConnectionPageInfo includes the requested fields of the GraphQL type PageInfo.
type listAttachmentsAttachmentsAttachmentConnectionPageInfo struct {
	// Indicates if there are more results when paginating forward.
	HasNextPage *bool `json:"hasNextPage"`
	// Cursor representing the last result in the paginated results.
	EndCursor *string `json:"endCursor"`
}

// GetHasNextPage returns listAttachmentsAttachmentsAttachmentConnectionPageInfo.HasNextPage, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionPageInfo) GetHasNextPage() *bool {
	return v.HasNextPage
}

// GetEndCursor returns listAttachmentsAttachmentsAttachmentConnectionPageInfo.EndCursor, and is useful for accessing the field via an interface.
func (v *listAttachmentsAttachmentsAttachmentConnectionPageInfo) GetEndCursor() *string {
	return v.EndCursor
}

// listAttachmentsResponse is returned by listAttachments on success.
type listAttachmentsResponse struct {
	// All issue attachments.
	//
	// To get attachments for a given URL, use `attachmentsForURL` query.
	Attachments *listAttachmentsAttachmentsAttachmentConnection `json:"attachments"`
}

// GetAttachments returns listAttachmentsResponse.Attachments, and is useful for accessing the field via an interface.
func (v *listAttachmentsResponse) GetAttachments() *listAttachmentsAttachmentsAttachmentConnection {
	return v.Attachments
}

// listCommentsCommentsCommentConnection includes the requested fields of the GraphQL type CommentConnection.
type listCommentsCommentsCommentConnection struct {
	PageInfo *listCommentsCommentsCommentConnectionPageInfo       `json:"pageInfo"`
	Nodes    []*listCommentsCommentsCommentConnectionNodesComment `json:"nodes"`
}

// GetPageInfo returns listCommentsCommentsCommentConnection.PageInfo, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnection) GetPageInfo() *listCommentsCommentsCommentConnectionPageInfo {
	return v.PageInfo
}

// GetNodes returns listCommentsCommentsCommentConnection.Nodes, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnection) GetNodes() []*listCommentsCommentsCommentConnectionNodesComment {
	return v.Nodes
}

// listCommentsCommentsCommentConnectionNodesComment includes the requested fields of the GraphQL type Comment.
// The GraphQL type's documentation follows.
//
// A comment associated with an issue.
type listCommentsCommentsCommentConnectionNodesComment struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The comment content in markdown format.
	Body *string `json:"body"`
	// The comment content as a Prosemirror document.
	BodyData *string `json:"bodyData"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// The time user edited the comment.
	EditedAt *time.Time `json:"-"`
	// Emoji reaction summary, grouped by emoji type
	ReactionData *json.RawMessage `json:"reactionData"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// Comment's URL.
	Url *string `json:"url"`
	// The user who wrote the comment.
	User *listCommentsCommentsCommentConnectionNodesCommentUser `json:"user"`
	// The parent comment under which the current comment is nested.
	Parent *listCommentsCommentsCommentConnectionNodesCommentParentComment `json:"parent"`
	// The issue that the comment is associated with.
	Issue *listCommentsCommentsCommentConnectionNodesCommentIssue `json:"issue"`
}

// GetId returns listCommentsCommentsCommentConnectionNodesComment.Id, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesComment) GetId() *string { return v.Id }

// GetArchivedAt returns listCommentsCommentsCommentConnectionNodesComment.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesComment) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetBody returns listCommentsCommentsCommentConnectionNodesComment.Body, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesComment) GetBody() *string { return v.Body }

// GetBodyData returns listCommentsCommentsCommentConnectionNodesComment.BodyData, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesComment) GetBodyData() *string { return v.BodyData }

// GetCreatedAt returns listCommentsCommentsCommentConnectionNodesComment.CreatedAt, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesComment) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetEditedAt returns listCommentsCommentsCommentConnectionNodesComment.EditedAt, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesComment) GetEditedAt() *time.Time {
	return v.EditedAt
}

// GetReactionData returns listCommentsCommentsCommentConnectionNodesComment.ReactionData, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesComment) GetReactionData() *json.RawMessage {
	return v.ReactionData
}

// GetUpdatedAt returns listCommentsCommentsCommentConnectionNodesComment.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesComment) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

// GetUrl returns listCommentsCommentsCommentConnectionNodesComment.Url, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesComment) GetUrl() *string { return v.Url }

// GetUser returns listCommentsCommentsCommentConnectionNodesComment.User, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesComment) GetUser() *listCommentsCommentsCommentConnectionNodesCommentUser {
	return v.User
}

// GetParent returns listCommentsCommentsCommentConnectionNodesComment.Parent, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesComment) GetParent() *listCommentsCommentsCommentConnectionNodesCommentParentComment {
	return v.Parent
}

// GetIssue returns listCommentsCommentsCommentConnectionNodesComment.Issue, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesComment) GetIssue() *listCommentsCommentsCommentConnectionNodesCommentIssue {
	return v.Issue
}

func (v *listCommentsCommentsCommentConnectionNodesComment) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listCommentsCommentsCommentConnectionNodesComment
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		EditedAt   json.RawMessage `json:"editedAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listCommentsCommentsCommentConnectionNodesComment = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listCommentsCommentsCommentConnectionNodesComment.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listCommentsCommentsCommentConnectionNodesComment.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.EditedAt
		src := firstPass.EditedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listCommentsCommentsCommentConnectionNodesComment.EditedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listCommentsCommentsCommentConnectionNodesComment.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistCommentsCommentsCommentConnectionNodesComment struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	Body *string `json:"body"`

	BodyData *string `json:"bodyData"`

	CreatedAt json.RawMessage `json:"createdAt"`

	EditedAt json.RawMessage `json:"editedAt"`

	ReactionData *json.RawMessage `json:"reactionData"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	Url *string `json:"url"`

	User *listCommentsCommentsCommentConnectionNodesCommentUser `json:"user"`

	Parent *listCommentsCommentsCommentConnectionNodesCommentParentComment `json:"parent"`

	Issue *listCommentsCommentsCommentConnectionNodesCommentIssue `json:"issue"`
}

func (v *listCommentsCommentsCommentConnectionNodesComment) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listCommentsCommentsCommentConnectionNodesComment) __premarshalJSON() (*__premarshallistCommentsCommentsCommentConnectionNodesComment, error) {
	var retval __premarshallistCommentsCommentsCommentConnectionNodesComment

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listCommentsCommentsCommentConnectionNodesComment.ArchivedAt: %w", err)
			}
		}
	}
	retval.Body = v.Body
	retval.BodyData = v.BodyData
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listCommentsCommentsCommentConnectionNodesComment.CreatedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.EditedAt
		src := v.EditedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listCommentsCommentsCommentConnectionNodesComment.EditedAt: %w", err)
			}
		}
	}
	retval.ReactionData = v.ReactionData
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listCommentsCommentsCommentConnectionNodesComment.UpdatedAt: %w", err)
			}
		}
	}
	retval.Url = v.Url
	retval.User = v.User
	retval.Parent = v.Parent
	retval.Issue = v.Issue
	return &retval, nil
}

// listCommentsCommentsCommentConnectionNodesCommentIssue includes the requested fields of the GraphQL type Issue.
// The GraphQL type's documentation follows.
//
// An issue.
type listCommentsCommentsCommentConnectionNodesCommentIssue struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The issue's unique number.
	Number *float64 `json:"number"`
	// The issue's title.
	Title *string `json:"title"`
	// The issue's description in markdown format.
	Description *string `json:"description"`
	// The priority of the issue. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low.
	Priority *float64 `json:"priority"`
	// The estimate of the complexity of the issue..
	Estimate *float64 `json:"estimate"`
	// The order of the item in relation to other items in the organization.
	SortOrder *float64 `json:"sortOrder"`
	// The time at which the issue was moved into started state.
	StartedAt *time.Time `json:"-"`
	// The time at which the issue was moved into completed state.
	CompletedAt *time.Time `json:"-"`
	// The time at which the issue was moved into canceled state.
	CanceledAt *time.Time `json:"-"`
	// The time at which the issue was automatically closed by the auto pruning process.
	AutoClosedAt *time.Time `json:"-"`
	// The time at which the issue was automatically archived by the auto pruning process.
	AutoArchivedAt *time.Time `json:"-"`
	// The date at which the issue is due.
	DueDate *time.Time `json:"-"`
	// A flag that indicates whether the issue is in the trash bin.
	Trashed *bool `json:"trashed"`
	// The time until an issue will be snoozed in Triage view.
	SnoozedUntilAt *time.Time `json:"-"`
	// Previous identifiers of the issue if it has been moved between teams.
	PreviousIdentifiers []*string `json:"previousIdentifiers"`
	// The order of the item in the sub-issue list. Only set if the issue has a parent.
	SubIssueSortOrder *float64 `json:"subIssueSortOrder"`
	// Label for the priority.
	PriorityLabel *string `json:"priorityLabel"`
	// Issue's human readable identifier (e.g. ENG-123).
	Identifier *string `json:"identifier"`
	// Issue URL.
	Url *string `json:"url"`
	// Suggested branch name for the issue.
	BranchName *string `json:"branchName"`
	// Returns the number of Attachment resources which are created by customer support ticketing systems (e.g. Zendesk).
	CustomerTicketCount *int `json:"customerTicketCount"`
}

// GetId returns listCommentsCommentsCommentConnectionNodesCommentIssue.Id, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentIssue) GetId() *string { return v.Id }

// GetCreatedAt returns listCommentsCommentsCommentConnectionNodesCommentIssue.CreatedAt, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentIssue) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetUpdatedAt returns listCommentsCommentsCommentConnectionNodesCommentIssue.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentIssue) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

// GetArchivedAt returns listCommentsCommentsCommentConnectionNodesCommentIssue.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentIssue) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetNumber returns listCommentsCommentsCommentConnectionNodesCommentIssue.Number, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentIssue) GetNumber() *float64 {
	return v.Number
}

// GetTitle returns listCommentsCommentsCommentConnectionNodesCommentIssue.Title, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentIssue) GetTitle() *string { return v.Title }

// GetDescription returns listCommentsCommentsCommentConnectionNodesCommentIssue.Description, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentIssue) GetDescription() *string {
	return v.Description
}

// GetPriority returns listCommentsCommentsCommentConnectionNodesCommentIssue.Priority, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentIssue) GetPriority() *float64 {
	return v.Priority
}

// GetEstimate returns listCommentsCommentsCommentConnectionNodesCommentIssue.Estimate, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentIssue) GetEstimate() *float64 {
	return v.Estimate
}

// GetSortOrder returns listCommentsCommentsCommentConnectionNodesCommentIssue.SortOrder, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentIssue) GetSortOrder() *float64 {
	return v.SortOrder
}

// GetStartedAt returns listCommentsCommentsCommentConnectionNodesCommentIssue.StartedAt, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentIssue) GetStartedAt() *time.Time {
	return v.StartedAt
}

// GetCompletedAt returns listCommentsCommentsCommentConnectionNodesCommentIssue.CompletedAt, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentIssue) GetCompletedAt() *time.Time {
	return v.CompletedAt
}

// GetCanceledAt returns listCommentsCommentsCommentConnectionNodesCommentIssue.CanceledAt, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentIssue) GetCanceledAt() *time.Time {
	return v.CanceledAt
}

// GetAutoClosedAt returns listCommentsCommentsCommentConnectionNodesCommentIssue.AutoClosedAt, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentIssue) GetAutoClosedAt() *time.Time {
	return v.AutoClosedAt
}

// GetAutoArchivedAt returns listCommentsCommentsCommentConnectionNodesCommentIssue.AutoArchivedAt, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentIssue) GetAutoArchivedAt() *time.Time {
	return v.AutoArchivedAt
}

// GetDueDate returns listCommentsCommentsCommentConnectionNodesCommentIssue.DueDate, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentIssue) GetDueDate() *time.Time {
	return v.DueDate
}

// GetTrashed returns listCommentsCommentsCommentConnectionNodesCommentIssue.Trashed, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentIssue) GetTrashed() *bool { return v.Trashed }

// GetSnoozedUntilAt returns listCommentsCommentsCommentConnectionNodesCommentIssue.SnoozedUntilAt, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentIssue) GetSnoozedUntilAt() *time.Time {
	return v.SnoozedUntilAt
}

// GetPreviousIdentifiers returns listCommentsCommentsCommentConnectionNodesCommentIssue.PreviousIdentifiers, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentIssue) GetPreviousIdentifiers() []*string {
	return v.PreviousIdentifiers
}

// GetSubIssueSortOrder returns listCommentsCommentsCommentConnectionNodesCommentIssue.SubIssueSortOrder, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentIssue) GetSubIssueSortOrder() *float64 {
	return v.SubIssueSortOrder
}

// GetPriorityLabel returns listCommentsCommentsCommentConnectionNodesCommentIssue.PriorityLabel, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentIssue) GetPriorityLabel() *string {
	return v.PriorityLabel
}

// GetIdentifier returns listCommentsCommentsCommentConnectionNodesCommentIssue.Identifier, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentIssue) GetIdentifier() *string {
	return v.Identifier
}

// GetUrl returns listCommentsCommentsCommentConnectionNodesCommentIssue.Url, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentIssue) GetUrl() *string { return v.Url }

// GetBranchName returns listCommentsCommentsCommentConnectionNodesCommentIssue.BranchName, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentIssue) GetBranchName() *string {
	return v.BranchName
}

// GetCustomerTicketCount returns listCommentsCommentsCommentConnectionNodesCommentIssue.CustomerTicketCount, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentIssue) GetCustomerTicketCount() *int {
	return v.CustomerTicketCount
}

func (v *listCommentsCommentsCommentConnectionNodesCommentIssue) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listCommentsCommentsCommentConnectionNodesCommentIssue
		CreatedAt      json.RawMessage `json:"createdAt"`
		UpdatedAt      json.RawMessage `json:"updatedAt"`
		ArchivedAt     json.RawMessage `json:"archivedAt"`
		StartedAt      json.RawMessage `json:"startedAt"`
		CompletedAt    json.RawMessage `json:"completedAt"`
		CanceledAt     json.RawMessage `json:"canceledAt"`
		AutoClosedAt   json.RawMessage `json:"autoClosedAt"`
		AutoArchivedAt json.RawMessage `json:"autoArchivedAt"`
		DueDate        json.RawMessage `json:"dueDate"`
		SnoozedUntilAt json.RawMessage `json:"snoozedUntilAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listCommentsCommentsCommentConnectionNodesCommentIssue = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listCommentsCommentsCommentConnectionNodesCommentIssue.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listCommentsCommentsCommentConnectionNodesCommentIssue.UpdatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listCommentsCommentsCommentConnectionNodesCommentIssue.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.StartedAt
		src := firstPass.StartedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listCommentsCommentsCommentConnectionNodesCommentIssue.StartedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CompletedAt
		src := firstPass.CompletedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listCommentsCommentsCommentConnectionNodesCommentIssue.CompletedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CanceledAt
		src := firstPass.CanceledAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listCommentsCommentsCommentConnectionNodesCommentIssue.CanceledAt: %w", err)
			}
		}
	}

	{
		dst := &v.AutoClosedAt
		src := firstPass.AutoClosedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listCommentsCommentsCommentConnectionNodesCommentIssue.AutoClosedAt: %w", err)
			}
		}
	}

	{
		dst := &v.AutoArchivedAt
		src := firstPass.AutoArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listCommentsCommentsCommentConnectionNodesCommentIssue.AutoArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.DueDate
		src := firstPass.DueDate
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listCommentsCommentsCommentConnectionNodesCommentIssue.DueDate: %w", err)
			}
		}
	}

	{
		dst := &v.SnoozedUntilAt
		src := firstPass.SnoozedUntilAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listCommentsCommentsCommentConnectionNodesCommentIssue.SnoozedUntilAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistCommentsCommentsCommentConnectionNodesCommentIssue struct {
	Id *string `json:"id"`

	CreatedAt json.RawMessage `json:"createdAt"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	Number *float64 `json:"number"`

	Title *string `json:"title"`

	Description *string `json:"description"`

	Priority *float64 `json:"priority"`

	Estimate *float64 `json:"estimate"`

	SortOrder *float64 `json:"sortOrder"`

	StartedAt json.RawMessage `json:"startedAt"`

	CompletedAt json.RawMessage `json:"completedAt"`

	CanceledAt json.RawMessage `json:"canceledAt"`

	AutoClosedAt json.RawMessage `json:"autoClosedAt"`

	AutoArchivedAt json.RawMessage `json:"autoArchivedAt"`

	DueDate json.RawMessage `json:"dueDate"`

	Trashed *bool `json:"trashed"`

	SnoozedUntilAt json.RawMessage `json:"snoozedUntilAt"`

	PreviousIdentifiers []*string `json:"previousIdentifiers"`

	SubIssueSortOrder *float64 `json:"subIssueSortOrder"`

	PriorityLabel *string `json:"priorityLabel"`

	Identifier *string `json:"identifier"`

	Url *string `json:"url"`

	BranchName *string `json:"branchName"`

	CustomerTicketCount *int `json:"customerTicketCount"`
}

func (v *listCommentsCommentsCommentConnectionNodesCommentIssue) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listCommentsCommentsCommentConnectionNodesCommentIssue) __premarshalJSON() (*__premarshallistCommentsCommentsCommentConnectionNodesCommentIssue, error) {
	var retval __premarshallistCommentsCommentsCommentConnectionNodesCommentIssue

	retval.Id = v.Id
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listCommentsCommentsCommentConnectionNodesCommentIssue.CreatedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listCommentsCommentsCommentConnectionNodesCommentIssue.UpdatedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listCommentsCommentsCommentConnectionNodesCommentIssue.ArchivedAt: %w", err)
			}
		}
	}
	retval.Number = v.Number
	retval.Title = v.Title
	retval.Description = v.Description
	retval.Priority = v.Priority
	retval.Estimate = v.Estimate
	retval.SortOrder = v.SortOrder
	{

		dst := &retval.StartedAt
		src := v.StartedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listCommentsCommentsCommentConnectionNodesCommentIssue.StartedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CompletedAt
		src := v.CompletedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listCommentsCommentsCommentConnectionNodesCommentIssue.CompletedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CanceledAt
		src := v.CanceledAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listCommentsCommentsCommentConnectionNodesCommentIssue.CanceledAt: %w", err)
			}
		}
	}
	{

		dst := &retval.AutoClosedAt
		src := v.AutoClosedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listCommentsCommentsCommentConnectionNodesCommentIssue.AutoClosedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.AutoArchivedAt
		src := v.AutoArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listCommentsCommentsCommentConnectionNodesCommentIssue.AutoArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.DueDate
		src := v.DueDate
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listCommentsCommentsCommentConnectionNodesCommentIssue.DueDate: %w", err)
			}
		}
	}
	retval.Trashed = v.Trashed
	{

		dst := &retval.SnoozedUntilAt
		src := v.SnoozedUntilAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listCommentsCommentsCommentConnectionNodesCommentIssue.SnoozedUntilAt: %w", err)
			}
		}
	}
	retval.PreviousIdentifiers = v.PreviousIdentifiers
	retval.SubIssueSortOrder = v.SubIssueSortOrder
	retval.PriorityLabel = v.PriorityLabel
	retval.Identifier = v.Identifier
	retval.Url = v.Url
	retval.BranchName = v.BranchName
	retval.CustomerTicketCount = v.CustomerTicketCount
	return &retval, nil
}

// listCommentsCommentsCommentConnectionNodesCommentParentComment includes the requested fields of the GraphQL type Comment.
// The GraphQL type's documentation follows.
//
// A comment associated with an issue.
type listCommentsCommentsCommentConnectionNodesCommentParentComment struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The comment content in markdown format.
	Body *string `json:"body"`
	// The comment content as a Prosemirror document.
	BodyData *string `json:"bodyData"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// The time user edited the comment.
	EditedAt *time.Time `json:"-"`
	// Emoji reaction summary, grouped by emoji type
	ReactionData *json.RawMessage `json:"reactionData"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// Comment's URL.
	Url *string `json:"url"`
}

// GetId returns listCommentsCommentsCommentConnectionNodesCommentParentComment.Id, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentParentComment) GetId() *string { return v.Id }

// GetArchivedAt returns listCommentsCommentsCommentConnectionNodesCommentParentComment.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentParentComment) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetBody returns listCommentsCommentsCommentConnectionNodesCommentParentComment.Body, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentParentComment) GetBody() *string {
	return v.Body
}

// GetBodyData returns listCommentsCommentsCommentConnectionNodesCommentParentComment.BodyData, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentParentComment) GetBodyData() *string {
	return v.BodyData
}

// GetCreatedAt returns listCommentsCommentsCommentConnectionNodesCommentParentComment.CreatedAt, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentParentComment) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetEditedAt returns listCommentsCommentsCommentConnectionNodesCommentParentComment.EditedAt, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentParentComment) GetEditedAt() *time.Time {
	return v.EditedAt
}

// GetReactionData returns listCommentsCommentsCommentConnectionNodesCommentParentComment.ReactionData, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentParentComment) GetReactionData() *json.RawMessage {
	return v.ReactionData
}

// GetUpdatedAt returns listCommentsCommentsCommentConnectionNodesCommentParentComment.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentParentComment) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

// GetUrl returns listCommentsCommentsCommentConnectionNodesCommentParentComment.Url, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentParentComment) GetUrl() *string {
	return v.Url
}

func (v *listCommentsCommentsCommentConnectionNodesCommentParentComment) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listCommentsCommentsCommentConnectionNodesCommentParentComment
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		EditedAt   json.RawMessage `json:"editedAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listCommentsCommentsCommentConnectionNodesCommentParentComment = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listCommentsCommentsCommentConnectionNodesCommentParentComment.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listCommentsCommentsCommentConnectionNodesCommentParentComment.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.EditedAt
		src := firstPass.EditedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listCommentsCommentsCommentConnectionNodesCommentParentComment.EditedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listCommentsCommentsCommentConnectionNodesCommentParentComment.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistCommentsCommentsCommentConnectionNodesCommentParentComment struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	Body *string `json:"body"`

	BodyData *string `json:"bodyData"`

	CreatedAt json.RawMessage `json:"createdAt"`

	EditedAt json.RawMessage `json:"editedAt"`

	ReactionData *json.RawMessage `json:"reactionData"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	Url *string `json:"url"`
}

func (v *listCommentsCommentsCommentConnectionNodesCommentParentComment) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listCommentsCommentsCommentConnectionNodesCommentParentComment) __premarshalJSON() (*__premarshallistCommentsCommentsCommentConnectionNodesCommentParentComment, error) {
	var retval __premarshallistCommentsCommentsCommentConnectionNodesCommentParentComment

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listCommentsCommentsCommentConnectionNodesCommentParentComment.ArchivedAt: %w", err)
			}
		}
	}
	retval.Body = v.Body
	retval.BodyData = v.BodyData
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listCommentsCommentsCommentConnectionNodesCommentParentComment.CreatedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.EditedAt
		src := v.EditedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listCommentsCommentsCommentConnectionNodesCommentParentComment.EditedAt: %w", err)
			}
		}
	}
	retval.ReactionData = v.ReactionData
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listCommentsCommentsCommentConnectionNodesCommentParentComment.UpdatedAt: %w", err)
			}
		}
	}
	retval.Url = v.Url
	return &retval, nil
}

// listCommentsCommentsCommentConnectionNodesCommentUser includes the requested fields of the GraphQL type User.
// The GraphQL type's documentation follows.
//
// A user that has access to the the resources of an organization.
type listCommentsCommentsCommentConnectionNodesCommentUser struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// Whether the user account is active or disabled (suspended).
	Active *bool `json:"active"`
	// Whether the user is an organization administrator.
	Admin *bool `json:"admin"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// An URL to the user's avatar image.
	AvatarUrl *string `json:"avatarUrl"`
	// [DEPRECATED] Hash for the user to be used in calendar URLs.
	CalendarHash *string `json:"calendarHash"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Number of issues created.
	CreatedIssueCount *int `json:"createdIssueCount"`
	// A short description of the user, either its title or bio.
	Description *string `json:"description"`
	// Reason why is the account disabled.
	DisableReason *string `json:"disableReason"`
	// The user's display (nick) name. Unique within each organization.
	DisplayName *string `json:"displayName"`
	// The user's email address.
	Email *string `json:"email"`
	// Whether the user is a guest in the workspace and limited to accessing a subset of teams.
	Guest *bool `json:"guest"`
	// Unique hash for the user to be used in invite URLs.
	InviteHash *string `json:"inviteHash"`
	// Whether the user is the currently authenticated user.
	IsMe *bool `json:"isMe"`
	// The last time the user was seen online. If null, the user is currently online.
	LastSeen *time.Time `json:"-"`
	// The user's full name.
	Name *string `json:"name"`
	// The emoji to represent the user current status.
	StatusEmoji *string `json:"statusEmoji"`
	// The label of the user current status.
	StatusLabel *string `json:"statusLabel"`
	// A date at which the user current status should be cleared.
	StatusUntilAt *time.Time `json:"-"`
	// The local timezone of the user.
	Timezone *string `json:"timezone"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// User's profile URL.
	Url *string `json:"url"`
}

// GetId returns listCommentsCommentsCommentConnectionNodesCommentUser.Id, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentUser) GetId() *string { return v.Id }

// GetActive returns listCommentsCommentsCommentConnectionNodesCommentUser.Active, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentUser) GetActive() *bool { return v.Active }

// GetAdmin returns listCommentsCommentsCommentConnectionNodesCommentUser.Admin, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentUser) GetAdmin() *bool { return v.Admin }

// GetArchivedAt returns listCommentsCommentsCommentConnectionNodesCommentUser.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentUser) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetAvatarUrl returns listCommentsCommentsCommentConnectionNodesCommentUser.AvatarUrl, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentUser) GetAvatarUrl() *string {
	return v.AvatarUrl
}

// GetCalendarHash returns listCommentsCommentsCommentConnectionNodesCommentUser.CalendarHash, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentUser) GetCalendarHash() *string {
	return v.CalendarHash
}

// GetCreatedAt returns listCommentsCommentsCommentConnectionNodesCommentUser.CreatedAt, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentUser) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetCreatedIssueCount returns listCommentsCommentsCommentConnectionNodesCommentUser.CreatedIssueCount, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentUser) GetCreatedIssueCount() *int {
	return v.CreatedIssueCount
}

// GetDescription returns listCommentsCommentsCommentConnectionNodesCommentUser.Description, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentUser) GetDescription() *string {
	return v.Description
}

// GetDisableReason returns listCommentsCommentsCommentConnectionNodesCommentUser.DisableReason, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentUser) GetDisableReason() *string {
	return v.DisableReason
}

// GetDisplayName returns listCommentsCommentsCommentConnectionNodesCommentUser.DisplayName, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentUser) GetDisplayName() *string {
	return v.DisplayName
}

// GetEmail returns listCommentsCommentsCommentConnectionNodesCommentUser.Email, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentUser) GetEmail() *string { return v.Email }

// GetGuest returns listCommentsCommentsCommentConnectionNodesCommentUser.Guest, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentUser) GetGuest() *bool { return v.Guest }

// GetInviteHash returns listCommentsCommentsCommentConnectionNodesCommentUser.InviteHash, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentUser) GetInviteHash() *string {
	return v.InviteHash
}

// GetIsMe returns listCommentsCommentsCommentConnectionNodesCommentUser.IsMe, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentUser) GetIsMe() *bool { return v.IsMe }

// GetLastSeen returns listCommentsCommentsCommentConnectionNodesCommentUser.LastSeen, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentUser) GetLastSeen() *time.Time {
	return v.LastSeen
}

// GetName returns listCommentsCommentsCommentConnectionNodesCommentUser.Name, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentUser) GetName() *string { return v.Name }

// GetStatusEmoji returns listCommentsCommentsCommentConnectionNodesCommentUser.StatusEmoji, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentUser) GetStatusEmoji() *string {
	return v.StatusEmoji
}

// GetStatusLabel returns listCommentsCommentsCommentConnectionNodesCommentUser.StatusLabel, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentUser) GetStatusLabel() *string {
	return v.StatusLabel
}

// GetStatusUntilAt returns listCommentsCommentsCommentConnectionNodesCommentUser.StatusUntilAt, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentUser) GetStatusUntilAt() *time.Time {
	return v.StatusUntilAt
}

// GetTimezone returns listCommentsCommentsCommentConnectionNodesCommentUser.Timezone, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentUser) GetTimezone() *string {
	return v.Timezone
}

// GetUpdatedAt returns listCommentsCommentsCommentConnectionNodesCommentUser.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentUser) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

// GetUrl returns listCommentsCommentsCommentConnectionNodesCommentUser.Url, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionNodesCommentUser) GetUrl() *string { return v.Url }

func (v *listCommentsCommentsCommentConnectionNodesCommentUser) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listCommentsCommentsCommentConnectionNodesCommentUser
		ArchivedAt    json.RawMessage `json:"archivedAt"`
		CreatedAt     json.RawMessage `json:"createdAt"`
		LastSeen      json.RawMessage `json:"lastSeen"`
		StatusUntilAt json.RawMessage `json:"statusUntilAt"`
		UpdatedAt     json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listCommentsCommentsCommentConnectionNodesCommentUser = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listCommentsCommentsCommentConnectionNodesCommentUser.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listCommentsCommentsCommentConnectionNodesCommentUser.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.LastSeen
		src := firstPass.LastSeen
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listCommentsCommentsCommentConnectionNodesCommentUser.LastSeen: %w", err)
			}
		}
	}

	{
		dst := &v.StatusUntilAt
		src := firstPass.StatusUntilAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listCommentsCommentsCommentConnectionNodesCommentUser.StatusUntilAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listCommentsCommentsCommentConnectionNodesCommentUser.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistCommentsCommentsCommentConnectionNodesCommentUser struct {
	Id *string `json:"id"`

	Active *bool `json:"active"`

	Admin *bool `json:"admin"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AvatarUrl *string `json:"avatarUrl"`

	CalendarHash *string `json:"calendarHash"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CreatedIssueCount *int `json:"createdIssueCount"`

	Description *string `json:"description"`

	DisableReason *string `json:"disableReason"`

	DisplayName *string `json:"displayName"`

	Email *string `json:"email"`

	Guest *bool `json:"guest"`

	InviteHash *string `json:"inviteHash"`

	IsMe *bool `json:"isMe"`

	LastSeen json.RawMessage `json:"lastSeen"`

	Name *string `json:"name"`

	StatusEmoji *string `json:"statusEmoji"`

	StatusLabel *string `json:"statusLabel"`

	StatusUntilAt json.RawMessage `json:"statusUntilAt"`

	Timezone *string `json:"timezone"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	Url *string `json:"url"`
}

func (v *listCommentsCommentsCommentConnectionNodesCommentUser) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listCommentsCommentsCommentConnectionNodesCommentUser) __premarshalJSON() (*__premarshallistCommentsCommentsCommentConnectionNodesCommentUser, error) {
	var retval __premarshallistCommentsCommentsCommentConnectionNodesCommentUser

	retval.Id = v.Id
	retval.Active = v.Active
	retval.Admin = v.Admin
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listCommentsCommentsCommentConnectionNodesCommentUser.ArchivedAt: %w", err)
			}
		}
	}
	retval.AvatarUrl = v.AvatarUrl
	retval.CalendarHash = v.CalendarHash
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listCommentsCommentsCommentConnectionNodesCommentUser.CreatedAt: %w", err)
			}
		}
	}
	retval.CreatedIssueCount = v.CreatedIssueCount
	retval.Description = v.Description
	retval.DisableReason = v.DisableReason
	retval.DisplayName = v.DisplayName
	retval.Email = v.Email
	retval.Guest = v.Guest
	retval.InviteHash = v.InviteHash
	retval.IsMe = v.IsMe
	{

		dst := &retval.LastSeen
		src := v.LastSeen
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listCommentsCommentsCommentConnectionNodesCommentUser.LastSeen: %w", err)
			}
		}
	}
	retval.Name = v.Name
	retval.StatusEmoji = v.StatusEmoji
	retval.StatusLabel = v.StatusLabel
	{

		dst := &retval.StatusUntilAt
		src := v.StatusUntilAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listCommentsCommentsCommentConnectionNodesCommentUser.StatusUntilAt: %w", err)
			}
		}
	}
	retval.Timezone = v.Timezone
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listCommentsCommentsCommentConnectionNodesCommentUser.UpdatedAt: %w", err)
			}
		}
	}
	retval.Url = v.Url
	return &retval, nil
}

// listCommentsCommentsCommentConnectionPageInfo includes the requested fields of the GraphQL type PageInfo.
type listCommentsCommentsCommentConnectionPageInfo struct {
	// Indicates if there are more results when paginating forward.
	HasNextPage *bool `json:"hasNextPage"`
	// Cursor representing the last result in the paginated results.
	EndCursor *string `json:"endCursor"`
}

// GetHasNextPage returns listCommentsCommentsCommentConnectionPageInfo.HasNextPage, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionPageInfo) GetHasNextPage() *bool { return v.HasNextPage }

// GetEndCursor returns listCommentsCommentsCommentConnectionPageInfo.EndCursor, and is useful for accessing the field via an interface.
func (v *listCommentsCommentsCommentConnectionPageInfo) GetEndCursor() *string { return v.EndCursor }

// listCommentsResponse is returned by listComments on success.
type listCommentsResponse struct {
	// All comments.
	Comments *listCommentsCommentsCommentConnection `json:"comments"`
}

// GetComments returns listCommentsResponse.Comments, and is useful for accessing the field via an interface.
func (v *listCommentsResponse) GetComments() *listCommentsCommentsCommentConnection {
	return v.Comments
}

// listIntegrationsIntegrationsIntegrationConnection includes the requested fields of the GraphQL type IntegrationConnection.
type listIntegrationsIntegrationsIntegrationConnection struct {
	PageInfo *listIntegrationsIntegrationsIntegrationConnectionPageInfo           `json:"pageInfo"`
	Nodes    []*listIntegrationsIntegrationsIntegrationConnectionNodesIntegration `json:"nodes"`
}

// GetPageInfo returns listIntegrationsIntegrationsIntegrationConnection.PageInfo, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnection) GetPageInfo() *listIntegrationsIntegrationsIntegrationConnectionPageInfo {
	return v.PageInfo
}

// GetNodes returns listIntegrationsIntegrationsIntegrationConnection.Nodes, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnection) GetNodes() []*listIntegrationsIntegrationsIntegrationConnectionNodesIntegration {
	return v.Nodes
}

// listIntegrationsIntegrationsIntegrationConnectionNodesIntegration includes the requested fields of the GraphQL type Integration.
// The GraphQL type's documentation follows.
//
// An integration with an external service.
type listIntegrationsIntegrationsIntegrationConnectionNodesIntegration struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// The integration's type.
	Service *string `json:"service"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// The team that the integration is associated with.
	Team *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam `json:"team"`
	// The user that added the integration.
	Creator *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser `json:"creator"`
	// The organization that the integration is associated with.
	Organization *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization `json:"organization"`
}

// GetId returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegration.Id, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegration) GetId() *string {
	return v.Id
}

// GetArchivedAt returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegration.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegration) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetCreatedAt returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegration.CreatedAt, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegration) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetService returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegration.Service, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegration) GetService() *string {
	return v.Service
}

// GetUpdatedAt returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegration.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegration) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

// GetTeam returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegration.Team, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegration) GetTeam() *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam {
	return v.Team
}

// GetCreator returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegration.Creator, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegration) GetCreator() *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser {
	return v.Creator
}

// GetOrganization returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegration.Organization, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegration) GetOrganization() *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization {
	return v.Organization
}

func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegration) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listIntegrationsIntegrationsIntegrationConnectionNodesIntegration
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listIntegrationsIntegrationsIntegrationConnectionNodesIntegration = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIntegrationsIntegrationsIntegrationConnectionNodesIntegration.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIntegrationsIntegrationsIntegrationConnectionNodesIntegration.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIntegrationsIntegrationsIntegrationConnectionNodesIntegration.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistIntegrationsIntegrationsIntegrationConnectionNodesIntegration struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	CreatedAt json.RawMessage `json:"createdAt"`

	Service *string `json:"service"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	Team *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam `json:"team"`

	Creator *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser `json:"creator"`

	Organization *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization `json:"organization"`
}

func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegration) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegration) __premarshalJSON() (*__premarshallistIntegrationsIntegrationsIntegrationConnectionNodesIntegration, error) {
	var retval __premarshallistIntegrationsIntegrationsIntegrationConnectionNodesIntegration

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIntegrationsIntegrationsIntegrationConnectionNodesIntegration.ArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIntegrationsIntegrationsIntegrationConnectionNodesIntegration.CreatedAt: %w", err)
			}
		}
	}
	retval.Service = v.Service
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIntegrationsIntegrationsIntegrationConnectionNodesIntegration.UpdatedAt: %w", err)
			}
		}
	}
	retval.Team = v.Team
	retval.Creator = v.Creator
	retval.Organization = v.Organization
	return &retval, nil
}

// listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser includes the requested fields of the GraphQL type User.
// The GraphQL type's documentation follows.
//
// A user that has access to the the resources of an organization.
type listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// Whether the user account is active or disabled (suspended).
	Active *bool `json:"active"`
	// Whether the user is an organization administrator.
	Admin *bool `json:"admin"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// An URL to the user's avatar image.
	AvatarUrl *string `json:"avatarUrl"`
	// [DEPRECATED] Hash for the user to be used in calendar URLs.
	CalendarHash *string `json:"calendarHash"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Number of issues created.
	CreatedIssueCount *int `json:"createdIssueCount"`
	// A short description of the user, either its title or bio.
	Description *string `json:"description"`
	// Reason why is the account disabled.
	DisableReason *string `json:"disableReason"`
	// The user's display (nick) name. Unique within each organization.
	DisplayName *string `json:"displayName"`
	// The user's email address.
	Email *string `json:"email"`
	// Whether the user is a guest in the workspace and limited to accessing a subset of teams.
	Guest *bool `json:"guest"`
	// Unique hash for the user to be used in invite URLs.
	InviteHash *string `json:"inviteHash"`
	// Whether the user is the currently authenticated user.
	IsMe *bool `json:"isMe"`
	// The last time the user was seen online. If null, the user is currently online.
	LastSeen *time.Time `json:"-"`
	// The user's full name.
	Name *string `json:"name"`
	// The emoji to represent the user current status.
	StatusEmoji *string `json:"statusEmoji"`
	// The label of the user current status.
	StatusLabel *string `json:"statusLabel"`
	// A date at which the user current status should be cleared.
	StatusUntilAt *time.Time `json:"-"`
	// The local timezone of the user.
	Timezone *string `json:"timezone"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// User's profile URL.
	Url *string `json:"url"`
}

// GetId returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser.Id, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser) GetId() *string {
	return v.Id
}

// GetActive returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser.Active, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser) GetActive() *bool {
	return v.Active
}

// GetAdmin returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser.Admin, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser) GetAdmin() *bool {
	return v.Admin
}

// GetArchivedAt returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetAvatarUrl returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser.AvatarUrl, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser) GetAvatarUrl() *string {
	return v.AvatarUrl
}

// GetCalendarHash returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser.CalendarHash, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser) GetCalendarHash() *string {
	return v.CalendarHash
}

// GetCreatedAt returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser.CreatedAt, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetCreatedIssueCount returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser.CreatedIssueCount, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser) GetCreatedIssueCount() *int {
	return v.CreatedIssueCount
}

// GetDescription returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser.Description, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser) GetDescription() *string {
	return v.Description
}

// GetDisableReason returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser.DisableReason, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser) GetDisableReason() *string {
	return v.DisableReason
}

// GetDisplayName returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser.DisplayName, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser) GetDisplayName() *string {
	return v.DisplayName
}

// GetEmail returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser.Email, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser) GetEmail() *string {
	return v.Email
}

// GetGuest returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser.Guest, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser) GetGuest() *bool {
	return v.Guest
}

// GetInviteHash returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser.InviteHash, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser) GetInviteHash() *string {
	return v.InviteHash
}

// GetIsMe returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser.IsMe, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser) GetIsMe() *bool {
	return v.IsMe
}

// GetLastSeen returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser.LastSeen, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser) GetLastSeen() *time.Time {
	return v.LastSeen
}

// GetName returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser.Name, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser) GetName() *string {
	return v.Name
}

// GetStatusEmoji returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser.StatusEmoji, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser) GetStatusEmoji() *string {
	return v.StatusEmoji
}

// GetStatusLabel returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser.StatusLabel, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser) GetStatusLabel() *string {
	return v.StatusLabel
}

// GetStatusUntilAt returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser.StatusUntilAt, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser) GetStatusUntilAt() *time.Time {
	return v.StatusUntilAt
}

// GetTimezone returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser.Timezone, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser) GetTimezone() *string {
	return v.Timezone
}

// GetUpdatedAt returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

// GetUrl returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser.Url, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser) GetUrl() *string {
	return v.Url
}

func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser
		ArchivedAt    json.RawMessage `json:"archivedAt"`
		CreatedAt     json.RawMessage `json:"createdAt"`
		LastSeen      json.RawMessage `json:"lastSeen"`
		StatusUntilAt json.RawMessage `json:"statusUntilAt"`
		UpdatedAt     json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.LastSeen
		src := firstPass.LastSeen
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser.LastSeen: %w", err)
			}
		}
	}

	{
		dst := &v.StatusUntilAt
		src := firstPass.StatusUntilAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser.StatusUntilAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser struct {
	Id *string `json:"id"`

	Active *bool `json:"active"`

	Admin *bool `json:"admin"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AvatarUrl *string `json:"avatarUrl"`

	CalendarHash *string `json:"calendarHash"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CreatedIssueCount *int `json:"createdIssueCount"`

	Description *string `json:"description"`

	DisableReason *string `json:"disableReason"`

	DisplayName *string `json:"displayName"`

	Email *string `json:"email"`

	Guest *bool `json:"guest"`

	InviteHash *string `json:"inviteHash"`

	IsMe *bool `json:"isMe"`

	LastSeen json.RawMessage `json:"lastSeen"`

	Name *string `json:"name"`

	StatusEmoji *string `json:"statusEmoji"`

	StatusLabel *string `json:"statusLabel"`

	StatusUntilAt json.RawMessage `json:"statusUntilAt"`

	Timezone *string `json:"timezone"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	Url *string `json:"url"`
}

func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser) __premarshalJSON() (*__premarshallistIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser, error) {
	var retval __premarshallistIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser

	retval.Id = v.Id
	retval.Active = v.Active
	retval.Admin = v.Admin
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser.ArchivedAt: %w", err)
			}
		}
	}
	retval.AvatarUrl = v.AvatarUrl
	retval.CalendarHash = v.CalendarHash
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser.CreatedAt: %w", err)
			}
		}
	}
	retval.CreatedIssueCount = v.CreatedIssueCount
	retval.Description = v.Description
	retval.DisableReason = v.DisableReason
	retval.DisplayName = v.DisplayName
	retval.Email = v.Email
	retval.Guest = v.Guest
	retval.InviteHash = v.InviteHash
	retval.IsMe = v.IsMe
	{

		dst := &retval.LastSeen
		src := v.LastSeen
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser.LastSeen: %w", err)
			}
		}
	}
	retval.Name = v.Name
	retval.StatusEmoji = v.StatusEmoji
	retval.StatusLabel = v.StatusLabel
	{

		dst := &retval.StatusUntilAt
		src := v.StatusUntilAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser.StatusUntilAt: %w", err)
			}
		}
	}
	retval.Timezone = v.Timezone
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationCreatorUser.UpdatedAt: %w", err)
			}
		}
	}
	retval.Url = v.Url
	return &retval, nil
}

// listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization includes the requested fields of the GraphQL type Organization.
// The GraphQL type's documentation follows.
//
// An organization. Organizations are root-level objects that contain user accounts and teams.
type listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// Allowed authentication providers, empty array means all are allowed
	AllowedAuthServices []*string `json:"allowedAuthServices"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Number of issues in the organization.
	CreatedIssueCount *int `json:"createdIssueCount"`
	// The time at which deletion of the organization was requested.
	DeletionRequestedAt *time.Time `json:"-"`
	// How git branches are formatted. If null, default formatting will be used.
	GitBranchFormat *string `json:"gitBranchFormat"`
	// Whether the Git integration linkback messages should be sent to private repositories.
	GitLinkbackMessagesEnabled *bool `json:"gitLinkbackMessagesEnabled"`
	// Whether the Git integration linkback messages should be sent to public repositories.
	GitPublicLinkbackMessagesEnabled *bool `json:"gitPublicLinkbackMessagesEnabled"`
	// The organization's logo URL.
	LogoUrl *string `json:"logoUrl"`
	// The organization's name.
	Name *string `json:"name"`
	// Rolling 30-day total upload volume for the organization, in megabytes.
	PeriodUploadVolume *float64 `json:"periodUploadVolume"`
	// Previously used URL keys for the organization (last 3 are kept and redirected).
	PreviousUrlKeys []*string `json:"previousUrlKeys"`
	// The day at which to prompt for project updates.
	ProjectUpdateRemindersDay *Day `json:"projectUpdateRemindersDay"`
	// The hour at which to prompt for project updates.
	ProjectUpdateRemindersHour *float64 `json:"projectUpdateRemindersHour"`
	// The frequency at which to prompt for project updates.
	ProjectUpdatesReminderFrequency *ProjectUpdateReminderFrequency `json:"projectUpdatesReminderFrequency"`
	// The feature release channel the organization belongs to.
	ReleaseChannel *ReleaseChannel `json:"releaseChannel"`
	// Whether the organization is using a roadmap.
	RoadmapEnabled *bool `json:"roadmapEnabled"`
	// Whether SAML authentication is enabled for organization.
	SamlEnabled *bool `json:"samlEnabled"`
	// Whether SCIM provisioning is enabled for organization.
	ScimEnabled *bool `json:"scimEnabled"`
	// The time at which the trial of the plus plan will end.
	TrialEndsAt *time.Time `json:"-"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// The organization's unique URL key.
	UrlKey *string `json:"urlKey"`
	// Number of active users in the organization.
	UserCount *int `json:"userCount"`
}

// GetId returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization.Id, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization) GetId() *string {
	return v.Id
}

// GetAllowedAuthServices returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization.AllowedAuthServices, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization) GetAllowedAuthServices() []*string {
	return v.AllowedAuthServices
}

// GetArchivedAt returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetCreatedAt returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization.CreatedAt, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetCreatedIssueCount returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization.CreatedIssueCount, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization) GetCreatedIssueCount() *int {
	return v.CreatedIssueCount
}

// GetDeletionRequestedAt returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization.DeletionRequestedAt, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization) GetDeletionRequestedAt() *time.Time {
	return v.DeletionRequestedAt
}

// GetGitBranchFormat returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization.GitBranchFormat, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization) GetGitBranchFormat() *string {
	return v.GitBranchFormat
}

// GetGitLinkbackMessagesEnabled returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization.GitLinkbackMessagesEnabled, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization) GetGitLinkbackMessagesEnabled() *bool {
	return v.GitLinkbackMessagesEnabled
}

// GetGitPublicLinkbackMessagesEnabled returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization.GitPublicLinkbackMessagesEnabled, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization) GetGitPublicLinkbackMessagesEnabled() *bool {
	return v.GitPublicLinkbackMessagesEnabled
}

// GetLogoUrl returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization.LogoUrl, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization) GetLogoUrl() *string {
	return v.LogoUrl
}

// GetName returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization.Name, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization) GetName() *string {
	return v.Name
}

// GetPeriodUploadVolume returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization.PeriodUploadVolume, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization) GetPeriodUploadVolume() *float64 {
	return v.PeriodUploadVolume
}

// GetPreviousUrlKeys returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization.PreviousUrlKeys, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization) GetPreviousUrlKeys() []*string {
	return v.PreviousUrlKeys
}

// GetProjectUpdateRemindersDay returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization.ProjectUpdateRemindersDay, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization) GetProjectUpdateRemindersDay() *Day {
	return v.ProjectUpdateRemindersDay
}

// GetProjectUpdateRemindersHour returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization.ProjectUpdateRemindersHour, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization) GetProjectUpdateRemindersHour() *float64 {
	return v.ProjectUpdateRemindersHour
}

// GetProjectUpdatesReminderFrequency returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization.ProjectUpdatesReminderFrequency, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization) GetProjectUpdatesReminderFrequency() *ProjectUpdateReminderFrequency {
	return v.ProjectUpdatesReminderFrequency
}

// GetReleaseChannel returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization.ReleaseChannel, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization) GetReleaseChannel() *ReleaseChannel {
	return v.ReleaseChannel
}

// GetRoadmapEnabled returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization.RoadmapEnabled, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization) GetRoadmapEnabled() *bool {
	return v.RoadmapEnabled
}

// GetSamlEnabled returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization.SamlEnabled, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization) GetSamlEnabled() *bool {
	return v.SamlEnabled
}

// GetScimEnabled returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization.ScimEnabled, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization) GetScimEnabled() *bool {
	return v.ScimEnabled
}

// GetTrialEndsAt returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization.TrialEndsAt, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization) GetTrialEndsAt() *time.Time {
	return v.TrialEndsAt
}

// GetUpdatedAt returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

// GetUrlKey returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization.UrlKey, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization) GetUrlKey() *string {
	return v.UrlKey
}

// GetUserCount returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization.UserCount, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization) GetUserCount() *int {
	return v.UserCount
}

func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization
		ArchivedAt          json.RawMessage `json:"archivedAt"`
		CreatedAt           json.RawMessage `json:"createdAt"`
		DeletionRequestedAt json.RawMessage `json:"deletionRequestedAt"`
		TrialEndsAt         json.RawMessage `json:"trialEndsAt"`
		UpdatedAt           json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.DeletionRequestedAt
		src := firstPass.DeletionRequestedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization.DeletionRequestedAt: %w", err)
			}
		}
	}

	{
		dst := &v.TrialEndsAt
		src := firstPass.TrialEndsAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization.TrialEndsAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization struct {
	Id *string `json:"id"`

	AllowedAuthServices []*string `json:"allowedAuthServices"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CreatedIssueCount *int `json:"createdIssueCount"`

	DeletionRequestedAt json.RawMessage `json:"deletionRequestedAt"`

	GitBranchFormat *string `json:"gitBranchFormat"`

	GitLinkbackMessagesEnabled *bool `json:"gitLinkbackMessagesEnabled"`

	GitPublicLinkbackMessagesEnabled *bool `json:"gitPublicLinkbackMessagesEnabled"`

	LogoUrl *string `json:"logoUrl"`

	Name *string `json:"name"`

	PeriodUploadVolume *float64 `json:"periodUploadVolume"`

	PreviousUrlKeys []*string `json:"previousUrlKeys"`

	ProjectUpdateRemindersDay *Day `json:"projectUpdateRemindersDay"`

	ProjectUpdateRemindersHour *float64 `json:"projectUpdateRemindersHour"`

	ProjectUpdatesReminderFrequency *ProjectUpdateReminderFrequency `json:"projectUpdatesReminderFrequency"`

	ReleaseChannel *ReleaseChannel `json:"releaseChannel"`

	RoadmapEnabled *bool `json:"roadmapEnabled"`

	SamlEnabled *bool `json:"samlEnabled"`

	ScimEnabled *bool `json:"scimEnabled"`

	TrialEndsAt json.RawMessage `json:"trialEndsAt"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	UrlKey *string `json:"urlKey"`

	UserCount *int `json:"userCount"`
}

func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization) __premarshalJSON() (*__premarshallistIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization, error) {
	var retval __premarshallistIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization

	retval.Id = v.Id
	retval.AllowedAuthServices = v.AllowedAuthServices
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization.ArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization.CreatedAt: %w", err)
			}
		}
	}
	retval.CreatedIssueCount = v.CreatedIssueCount
	{

		dst := &retval.DeletionRequestedAt
		src := v.DeletionRequestedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization.DeletionRequestedAt: %w", err)
			}
		}
	}
	retval.GitBranchFormat = v.GitBranchFormat
	retval.GitLinkbackMessagesEnabled = v.GitLinkbackMessagesEnabled
	retval.GitPublicLinkbackMessagesEnabled = v.GitPublicLinkbackMessagesEnabled
	retval.LogoUrl = v.LogoUrl
	retval.Name = v.Name
	retval.PeriodUploadVolume = v.PeriodUploadVolume
	retval.PreviousUrlKeys = v.PreviousUrlKeys
	retval.ProjectUpdateRemindersDay = v.ProjectUpdateRemindersDay
	retval.ProjectUpdateRemindersHour = v.ProjectUpdateRemindersHour
	retval.ProjectUpdatesReminderFrequency = v.ProjectUpdatesReminderFrequency
	retval.ReleaseChannel = v.ReleaseChannel
	retval.RoadmapEnabled = v.RoadmapEnabled
	retval.SamlEnabled = v.SamlEnabled
	retval.ScimEnabled = v.ScimEnabled
	{

		dst := &retval.TrialEndsAt
		src := v.TrialEndsAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization.TrialEndsAt: %w", err)
			}
		}
	}
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationOrganization.UpdatedAt: %w", err)
			}
		}
	}
	retval.UrlKey = v.UrlKey
	retval.UserCount = v.UserCount
	return &retval, nil
}

// listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam includes the requested fields of the GraphQL type Team.
// The GraphQL type's documentation follows.
//
// An organizational unit that contains issues.
type listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// Period after which automatically closed and completed issues are automatically archived in months.
	AutoArchivePeriod *float64 `json:"autoArchivePeriod"`
	// Period after which issues are automatically closed in months. Null/undefined means disabled.
	AutoClosePeriod *float64 `json:"autoClosePeriod"`
	// The canceled workflow state which auto closed issues will be set to. Defaults to the first canceled state.
	AutoCloseStateId *string `json:"autoCloseStateId"`
	// The team's color.
	Color *string `json:"color"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Calendar feed URL (iCal) for cycles.
	CycleCalenderUrl *string `json:"cycleCalenderUrl"`
	// The cooldown time after each cycle in weeks.
	CycleCooldownTime *float64 `json:"cycleCooldownTime"`
	// The duration of a cycle in weeks.
	CycleDuration *float64 `json:"cycleDuration"`
	// Auto assign completed issues to current cycle.
	CycleIssueAutoAssignCompleted *bool `json:"cycleIssueAutoAssignCompleted"`
	// Auto assign started issues to current cycle.
	CycleIssueAutoAssignStarted *bool `json:"cycleIssueAutoAssignStarted"`
	// Only allow issues issues with cycles in Active Issues.
	CycleLockToActive *bool `json:"cycleLockToActive"`
	// The day of the week that a new cycle starts.
	CycleStartDay *float64 `json:"cycleStartDay"`
	// Whether the team uses cycles.
	CyclesEnabled *bool `json:"cyclesEnabled"`
	// What to use as an default estimate for unestimated issues.
	DefaultIssueEstimate *float64 `json:"defaultIssueEstimate"`
	// The id of the default template to use for new issues created by members of the team.
	DefaultTemplateForMembersId *string `json:"defaultTemplateForMembersId"`
	// The id of the default template to use for new issues created by non-members of the team.
	DefaultTemplateForNonMembersId *string `json:"defaultTemplateForNonMembersId"`
	// The team's description.
	Description *string `json:"description"`
	// Whether to group recent issue history entries.
	GroupIssueHistory *bool `json:"groupIssueHistory"`
	// The icon of the team.
	Icon *string `json:"icon"`
	// Unique hash for the team to be used in invite URLs.
	InviteHash *string `json:"inviteHash"`
	// Whether to allow zeros in issues estimates.
	IssueEstimationAllowZero *bool `json:"issueEstimationAllowZero"`
	// Whether to add additional points to the estimate scale.
	IssueEstimationExtended *bool `json:"issueEstimationExtended"`
	// The issue estimation type to use.
	IssueEstimationType *string `json:"issueEstimationType"`
	// Whether issues without priority should be sorted first.
	IssueOrderingNoPriorityFirst *bool `json:"issueOrderingNoPriorityFirst"`
	// Whether to move issues to bottom of the column when changing state.
	IssueSortOrderDefaultToBottom *bool `json:"issueSortOrderDefaultToBottom"`
	// The team's unique key. The key is used in URLs.
	Key *string `json:"key"`
	// The team's name.
	Name *string `json:"name"`
	// Whether the team is private or not.
	Private *bool `json:"private"`
	// Whether an issue needs to have a priority set before leaving triage
	RequirePriorityToLeaveTriage *bool `json:"requirePriorityToLeaveTriage"`
	// Whether to send new issue comment notifications to Slack.
	SlackIssueComments *bool `json:"slackIssueComments"`
	// Whether to send new issue status updates to Slack.
	SlackIssueStatuses *bool `json:"slackIssueStatuses"`
	// Whether to send new issue notifications to Slack.
	SlackNewIssue *bool `json:"slackNewIssue"`
	// The timezone of the team. Defaults to "America/Los_Angeles"
	Timezone *string `json:"timezone"`
	// Whether triage mode is enabled for the team or not.
	TriageEnabled *bool `json:"triageEnabled"`
	// How many upcoming cycles to create.
	UpcomingCycleCount *float64 `json:"upcomingCycleCount"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
}

// GetId returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.Id, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) GetId() *string {
	return v.Id
}

// GetArchivedAt returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetAutoArchivePeriod returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.AutoArchivePeriod, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) GetAutoArchivePeriod() *float64 {
	return v.AutoArchivePeriod
}

// GetAutoClosePeriod returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.AutoClosePeriod, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) GetAutoClosePeriod() *float64 {
	return v.AutoClosePeriod
}

// GetAutoCloseStateId returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.AutoCloseStateId, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) GetAutoCloseStateId() *string {
	return v.AutoCloseStateId
}

// GetColor returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.Color, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) GetColor() *string {
	return v.Color
}

// GetCreatedAt returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.CreatedAt, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetCycleCalenderUrl returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.CycleCalenderUrl, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) GetCycleCalenderUrl() *string {
	return v.CycleCalenderUrl
}

// GetCycleCooldownTime returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.CycleCooldownTime, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) GetCycleCooldownTime() *float64 {
	return v.CycleCooldownTime
}

// GetCycleDuration returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.CycleDuration, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) GetCycleDuration() *float64 {
	return v.CycleDuration
}

// GetCycleIssueAutoAssignCompleted returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.CycleIssueAutoAssignCompleted, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) GetCycleIssueAutoAssignCompleted() *bool {
	return v.CycleIssueAutoAssignCompleted
}

// GetCycleIssueAutoAssignStarted returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.CycleIssueAutoAssignStarted, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) GetCycleIssueAutoAssignStarted() *bool {
	return v.CycleIssueAutoAssignStarted
}

// GetCycleLockToActive returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.CycleLockToActive, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) GetCycleLockToActive() *bool {
	return v.CycleLockToActive
}

// GetCycleStartDay returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.CycleStartDay, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) GetCycleStartDay() *float64 {
	return v.CycleStartDay
}

// GetCyclesEnabled returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.CyclesEnabled, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) GetCyclesEnabled() *bool {
	return v.CyclesEnabled
}

// GetDefaultIssueEstimate returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.DefaultIssueEstimate, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) GetDefaultIssueEstimate() *float64 {
	return v.DefaultIssueEstimate
}

// GetDefaultTemplateForMembersId returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.DefaultTemplateForMembersId, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) GetDefaultTemplateForMembersId() *string {
	return v.DefaultTemplateForMembersId
}

// GetDefaultTemplateForNonMembersId returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.DefaultTemplateForNonMembersId, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) GetDefaultTemplateForNonMembersId() *string {
	return v.DefaultTemplateForNonMembersId
}

// GetDescription returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.Description, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) GetDescription() *string {
	return v.Description
}

// GetGroupIssueHistory returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.GroupIssueHistory, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) GetGroupIssueHistory() *bool {
	return v.GroupIssueHistory
}

// GetIcon returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.Icon, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) GetIcon() *string {
	return v.Icon
}

// GetInviteHash returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.InviteHash, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) GetInviteHash() *string {
	return v.InviteHash
}

// GetIssueEstimationAllowZero returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.IssueEstimationAllowZero, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) GetIssueEstimationAllowZero() *bool {
	return v.IssueEstimationAllowZero
}

// GetIssueEstimationExtended returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.IssueEstimationExtended, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) GetIssueEstimationExtended() *bool {
	return v.IssueEstimationExtended
}

// GetIssueEstimationType returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.IssueEstimationType, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) GetIssueEstimationType() *string {
	return v.IssueEstimationType
}

// GetIssueOrderingNoPriorityFirst returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.IssueOrderingNoPriorityFirst, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) GetIssueOrderingNoPriorityFirst() *bool {
	return v.IssueOrderingNoPriorityFirst
}

// GetIssueSortOrderDefaultToBottom returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.IssueSortOrderDefaultToBottom, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) GetIssueSortOrderDefaultToBottom() *bool {
	return v.IssueSortOrderDefaultToBottom
}

// GetKey returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.Key, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) GetKey() *string {
	return v.Key
}

// GetName returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.Name, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) GetName() *string {
	return v.Name
}

// GetPrivate returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.Private, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) GetPrivate() *bool {
	return v.Private
}

// GetRequirePriorityToLeaveTriage returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.RequirePriorityToLeaveTriage, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) GetRequirePriorityToLeaveTriage() *bool {
	return v.RequirePriorityToLeaveTriage
}

// GetSlackIssueComments returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.SlackIssueComments, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) GetSlackIssueComments() *bool {
	return v.SlackIssueComments
}

// GetSlackIssueStatuses returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.SlackIssueStatuses, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) GetSlackIssueStatuses() *bool {
	return v.SlackIssueStatuses
}

// GetSlackNewIssue returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.SlackNewIssue, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) GetSlackNewIssue() *bool {
	return v.SlackNewIssue
}

// GetTimezone returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.Timezone, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) GetTimezone() *string {
	return v.Timezone
}

// GetTriageEnabled returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.TriageEnabled, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) GetTriageEnabled() *bool {
	return v.TriageEnabled
}

// GetUpcomingCycleCount returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.UpcomingCycleCount, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) GetUpcomingCycleCount() *float64 {
	return v.UpcomingCycleCount
}

// GetUpdatedAt returns listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AutoArchivePeriod *float64 `json:"autoArchivePeriod"`

	AutoClosePeriod *float64 `json:"autoClosePeriod"`

	AutoCloseStateId *string `json:"autoCloseStateId"`

	Color *string `json:"color"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CycleCalenderUrl *string `json:"cycleCalenderUrl"`

	CycleCooldownTime *float64 `json:"cycleCooldownTime"`

	CycleDuration *float64 `json:"cycleDuration"`

	CycleIssueAutoAssignCompleted *bool `json:"cycleIssueAutoAssignCompleted"`

	CycleIssueAutoAssignStarted *bool `json:"cycleIssueAutoAssignStarted"`

	CycleLockToActive *bool `json:"cycleLockToActive"`

	CycleStartDay *float64 `json:"cycleStartDay"`

	CyclesEnabled *bool `json:"cyclesEnabled"`

	DefaultIssueEstimate *float64 `json:"defaultIssueEstimate"`

	DefaultTemplateForMembersId *string `json:"defaultTemplateForMembersId"`

	DefaultTemplateForNonMembersId *string `json:"defaultTemplateForNonMembersId"`

	Description *string `json:"description"`

	GroupIssueHistory *bool `json:"groupIssueHistory"`

	Icon *string `json:"icon"`

	InviteHash *string `json:"inviteHash"`

	IssueEstimationAllowZero *bool `json:"issueEstimationAllowZero"`

	IssueEstimationExtended *bool `json:"issueEstimationExtended"`

	IssueEstimationType *string `json:"issueEstimationType"`

	IssueOrderingNoPriorityFirst *bool `json:"issueOrderingNoPriorityFirst"`

	IssueSortOrderDefaultToBottom *bool `json:"issueSortOrderDefaultToBottom"`

	Key *string `json:"key"`

	Name *string `json:"name"`

	Private *bool `json:"private"`

	RequirePriorityToLeaveTriage *bool `json:"requirePriorityToLeaveTriage"`

	SlackIssueComments *bool `json:"slackIssueComments"`

	SlackIssueStatuses *bool `json:"slackIssueStatuses"`

	SlackNewIssue *bool `json:"slackNewIssue"`

	Timezone *string `json:"timezone"`

	TriageEnabled *bool `json:"triageEnabled"`

	UpcomingCycleCount *float64 `json:"upcomingCycleCount"`

	UpdatedAt json.RawMessage `json:"updatedAt"`
}

func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam) __premarshalJSON() (*__premarshallistIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam, error) {
	var retval __premarshallistIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.ArchivedAt: %w", err)
			}
		}
	}
	retval.AutoArchivePeriod = v.AutoArchivePeriod
	retval.AutoClosePeriod = v.AutoClosePeriod
	retval.AutoCloseStateId = v.AutoCloseStateId
	retval.Color = v.Color
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.CreatedAt: %w", err)
			}
		}
	}
	retval.CycleCalenderUrl = v.CycleCalenderUrl
	retval.CycleCooldownTime = v.CycleCooldownTime
	retval.CycleDuration = v.CycleDuration
	retval.CycleIssueAutoAssignCompleted = v.CycleIssueAutoAssignCompleted
	retval.CycleIssueAutoAssignStarted = v.CycleIssueAutoAssignStarted
	retval.CycleLockToActive = v.CycleLockToActive
	retval.CycleStartDay = v.CycleStartDay
	retval.CyclesEnabled = v.CyclesEnabled
	retval.DefaultIssueEstimate = v.DefaultIssueEstimate
	retval.DefaultTemplateForMembersId = v.DefaultTemplateForMembersId
	retval.DefaultTemplateForNonMembersId = v.DefaultTemplateForNonMembersId
	retval.Description = v.Description
	retval.GroupIssueHistory = v.GroupIssueHistory
	retval.Icon = v.Icon
	retval.InviteHash = v.InviteHash
	retval.IssueEstimationAllowZero = v.IssueEstimationAllowZero
	retval.IssueEstimationExtended = v.IssueEstimationExtended
	retval.IssueEstimationType = v.IssueEstimationType
	retval.IssueOrderingNoPriorityFirst = v.IssueOrderingNoPriorityFirst
	retval.IssueSortOrderDefaultToBottom = v.IssueSortOrderDefaultToBottom
	retval.Key = v.Key
	retval.Name = v.Name
	retval.Private = v.Private
	retval.RequirePriorityToLeaveTriage = v.RequirePriorityToLeaveTriage
	retval.SlackIssueComments = v.SlackIssueComments
	retval.SlackIssueStatuses = v.SlackIssueStatuses
	retval.SlackNewIssue = v.SlackNewIssue
	retval.Timezone = v.Timezone
	retval.TriageEnabled = v.TriageEnabled
	retval.UpcomingCycleCount = v.UpcomingCycleCount
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIntegrationsIntegrationsIntegrationConnectionNodesIntegrationTeam.UpdatedAt: %w", err)
			}
		}
	}
	return &retval, nil
}

// listIntegrationsIntegrationsIntegrationConnectionPageInfo includes the requested fields of the GraphQL type PageInfo.
type listIntegrationsIntegrationsIntegrationConnectionPageInfo struct {
	// Indicates if there are more results when paginating forward.
	HasNextPage *bool `json:"hasNextPage"`
	// Cursor representing the last result in the paginated results.
	EndCursor *string `json:"endCursor"`
}

// GetHasNextPage returns listIntegrationsIntegrationsIntegrationConnectionPageInfo.HasNextPage, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionPageInfo) GetHasNextPage() *bool {
	return v.HasNextPage
}

// GetEndCursor returns listIntegrationsIntegrationsIntegrationConnectionPageInfo.EndCursor, and is useful for accessing the field via an interface.
func (v *listIntegrationsIntegrationsIntegrationConnectionPageInfo) GetEndCursor() *string {
	return v.EndCursor
}

// listIntegrationsResponse is returned by listIntegrations on success.
type listIntegrationsResponse struct {
	// All integrations.
	Integrations *listIntegrationsIntegrationsIntegrationConnection `json:"integrations"`
}

// GetIntegrations returns listIntegrationsResponse.Integrations, and is useful for accessing the field via an interface.
func (v *listIntegrationsResponse) GetIntegrations() *listIntegrationsIntegrationsIntegrationConnection {
	return v.Integrations
}

// listIssueLabelsIssueLabelsIssueLabelConnection includes the requested fields of the GraphQL type IssueLabelConnection.
type listIssueLabelsIssueLabelsIssueLabelConnection struct {
	PageInfo *listIssueLabelsIssueLabelsIssueLabelConnectionPageInfo          `json:"pageInfo"`
	Nodes    []*listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel `json:"nodes"`
}

// GetPageInfo returns listIssueLabelsIssueLabelsIssueLabelConnection.PageInfo, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnection) GetPageInfo() *listIssueLabelsIssueLabelsIssueLabelConnectionPageInfo {
	return v.PageInfo
}

// GetNodes returns listIssueLabelsIssueLabelsIssueLabelConnection.Nodes, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnection) GetNodes() []*listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel {
	return v.Nodes
}

// listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel includes the requested fields of the GraphQL type IssueLabel.
// The GraphQL type's documentation follows.
//
// Labels that can be associated with issues.
type listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The label's color as a HEX string.
	Color *string `json:"color"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// The label's description.
	Description *string `json:"description"`
	// The label's name.
	Name *string `json:"name"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// Issues associated with the label.
	Issues *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelIssuesIssueConnection `json:"issues"`
	// The team that the label is associated with. If null, the label is associated with the global workspace.
	Team *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam `json:"team"`
	// The user who created the label.
	Creator      *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser  `json:"creator"`
	Organization *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization `json:"organization"`
	// The parent label.
	Parent *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelParentIssueLabel `json:"parent"`
}

// GetId returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel.Id, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel) GetId() *string { return v.Id }

// GetArchivedAt returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetColor returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel.Color, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel) GetColor() *string {
	return v.Color
}

// GetCreatedAt returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel.CreatedAt, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetDescription returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel.Description, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel) GetDescription() *string {
	return v.Description
}

// GetName returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel.Name, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel) GetName() *string {
	return v.Name
}

// GetUpdatedAt returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

// GetIssues returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel.Issues, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel) GetIssues() *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelIssuesIssueConnection {
	return v.Issues
}

// GetTeam returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel.Team, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel) GetTeam() *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam {
	return v.Team
}

// GetCreator returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel.Creator, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel) GetCreator() *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser {
	return v.Creator
}

// GetOrganization returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel.Organization, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel) GetOrganization() *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization {
	return v.Organization
}

// GetParent returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel.Parent, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel) GetParent() *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelParentIssueLabel {
	return v.Parent
}

func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	Color *string `json:"color"`

	CreatedAt json.RawMessage `json:"createdAt"`

	Description *string `json:"description"`

	Name *string `json:"name"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	Issues *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelIssuesIssueConnection `json:"issues"`

	Team *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam `json:"team"`

	Creator *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser `json:"creator"`

	Organization *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization `json:"organization"`

	Parent *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelParentIssueLabel `json:"parent"`
}

func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel) __premarshalJSON() (*__premarshallistIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel, error) {
	var retval __premarshallistIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel.ArchivedAt: %w", err)
			}
		}
	}
	retval.Color = v.Color
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel.CreatedAt: %w", err)
			}
		}
	}
	retval.Description = v.Description
	retval.Name = v.Name
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabel.UpdatedAt: %w", err)
			}
		}
	}
	retval.Issues = v.Issues
	retval.Team = v.Team
	retval.Creator = v.Creator
	retval.Organization = v.Organization
	retval.Parent = v.Parent
	return &retval, nil
}

// listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser includes the requested fields of the GraphQL type User.
// The GraphQL type's documentation follows.
//
// A user that has access to the the resources of an organization.
type listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// Whether the user account is active or disabled (suspended).
	Active *bool `json:"active"`
	// Whether the user is an organization administrator.
	Admin *bool `json:"admin"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// An URL to the user's avatar image.
	AvatarUrl *string `json:"avatarUrl"`
	// [DEPRECATED] Hash for the user to be used in calendar URLs.
	CalendarHash *string `json:"calendarHash"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Number of issues created.
	CreatedIssueCount *int `json:"createdIssueCount"`
	// A short description of the user, either its title or bio.
	Description *string `json:"description"`
	// Reason why is the account disabled.
	DisableReason *string `json:"disableReason"`
	// The user's display (nick) name. Unique within each organization.
	DisplayName *string `json:"displayName"`
	// The user's email address.
	Email *string `json:"email"`
	// Whether the user is a guest in the workspace and limited to accessing a subset of teams.
	Guest *bool `json:"guest"`
	// Unique hash for the user to be used in invite URLs.
	InviteHash *string `json:"inviteHash"`
	// Whether the user is the currently authenticated user.
	IsMe *bool `json:"isMe"`
	// The last time the user was seen online. If null, the user is currently online.
	LastSeen *time.Time `json:"-"`
	// The user's full name.
	Name *string `json:"name"`
	// The emoji to represent the user current status.
	StatusEmoji *string `json:"statusEmoji"`
	// The label of the user current status.
	StatusLabel *string `json:"statusLabel"`
	// A date at which the user current status should be cleared.
	StatusUntilAt *time.Time `json:"-"`
	// The local timezone of the user.
	Timezone *string `json:"timezone"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// User's profile URL.
	Url *string `json:"url"`
}

// GetId returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser.Id, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser) GetId() *string {
	return v.Id
}

// GetActive returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser.Active, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser) GetActive() *bool {
	return v.Active
}

// GetAdmin returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser.Admin, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser) GetAdmin() *bool {
	return v.Admin
}

// GetArchivedAt returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetAvatarUrl returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser.AvatarUrl, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser) GetAvatarUrl() *string {
	return v.AvatarUrl
}

// GetCalendarHash returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser.CalendarHash, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser) GetCalendarHash() *string {
	return v.CalendarHash
}

// GetCreatedAt returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser.CreatedAt, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetCreatedIssueCount returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser.CreatedIssueCount, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser) GetCreatedIssueCount() *int {
	return v.CreatedIssueCount
}

// GetDescription returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser.Description, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser) GetDescription() *string {
	return v.Description
}

// GetDisableReason returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser.DisableReason, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser) GetDisableReason() *string {
	return v.DisableReason
}

// GetDisplayName returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser.DisplayName, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser) GetDisplayName() *string {
	return v.DisplayName
}

// GetEmail returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser.Email, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser) GetEmail() *string {
	return v.Email
}

// GetGuest returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser.Guest, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser) GetGuest() *bool {
	return v.Guest
}

// GetInviteHash returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser.InviteHash, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser) GetInviteHash() *string {
	return v.InviteHash
}

// GetIsMe returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser.IsMe, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser) GetIsMe() *bool {
	return v.IsMe
}

// GetLastSeen returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser.LastSeen, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser) GetLastSeen() *time.Time {
	return v.LastSeen
}

// GetName returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser.Name, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser) GetName() *string {
	return v.Name
}

// GetStatusEmoji returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser.StatusEmoji, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser) GetStatusEmoji() *string {
	return v.StatusEmoji
}

// GetStatusLabel returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser.StatusLabel, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser) GetStatusLabel() *string {
	return v.StatusLabel
}

// GetStatusUntilAt returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser.StatusUntilAt, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser) GetStatusUntilAt() *time.Time {
	return v.StatusUntilAt
}

// GetTimezone returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser.Timezone, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser) GetTimezone() *string {
	return v.Timezone
}

// GetUpdatedAt returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

// GetUrl returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser.Url, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser) GetUrl() *string {
	return v.Url
}

func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser
		ArchivedAt    json.RawMessage `json:"archivedAt"`
		CreatedAt     json.RawMessage `json:"createdAt"`
		LastSeen      json.RawMessage `json:"lastSeen"`
		StatusUntilAt json.RawMessage `json:"statusUntilAt"`
		UpdatedAt     json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.LastSeen
		src := firstPass.LastSeen
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser.LastSeen: %w", err)
			}
		}
	}

	{
		dst := &v.StatusUntilAt
		src := firstPass.StatusUntilAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser.StatusUntilAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser struct {
	Id *string `json:"id"`

	Active *bool `json:"active"`

	Admin *bool `json:"admin"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AvatarUrl *string `json:"avatarUrl"`

	CalendarHash *string `json:"calendarHash"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CreatedIssueCount *int `json:"createdIssueCount"`

	Description *string `json:"description"`

	DisableReason *string `json:"disableReason"`

	DisplayName *string `json:"displayName"`

	Email *string `json:"email"`

	Guest *bool `json:"guest"`

	InviteHash *string `json:"inviteHash"`

	IsMe *bool `json:"isMe"`

	LastSeen json.RawMessage `json:"lastSeen"`

	Name *string `json:"name"`

	StatusEmoji *string `json:"statusEmoji"`

	StatusLabel *string `json:"statusLabel"`

	StatusUntilAt json.RawMessage `json:"statusUntilAt"`

	Timezone *string `json:"timezone"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	Url *string `json:"url"`
}

func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser) __premarshalJSON() (*__premarshallistIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser, error) {
	var retval __premarshallistIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser

	retval.Id = v.Id
	retval.Active = v.Active
	retval.Admin = v.Admin
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser.ArchivedAt: %w", err)
			}
		}
	}
	retval.AvatarUrl = v.AvatarUrl
	retval.CalendarHash = v.CalendarHash
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser.CreatedAt: %w", err)
			}
		}
	}
	retval.CreatedIssueCount = v.CreatedIssueCount
	retval.Description = v.Description
	retval.DisableReason = v.DisableReason
	retval.DisplayName = v.DisplayName
	retval.Email = v.Email
	retval.Guest = v.Guest
	retval.InviteHash = v.InviteHash
	retval.IsMe = v.IsMe
	{

		dst := &retval.LastSeen
		src := v.LastSeen
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser.LastSeen: %w", err)
			}
		}
	}
	retval.Name = v.Name
	retval.StatusEmoji = v.StatusEmoji
	retval.StatusLabel = v.StatusLabel
	{

		dst := &retval.StatusUntilAt
		src := v.StatusUntilAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser.StatusUntilAt: %w", err)
			}
		}
	}
	retval.Timezone = v.Timezone
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelCreatorUser.UpdatedAt: %w", err)
			}
		}
	}
	retval.Url = v.Url
	return &retval, nil
}

// listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelIssuesIssueConnection includes the requested fields of the GraphQL type IssueConnection.
type listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelIssuesIssueConnection struct {
	PageInfo *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelIssuesIssueConnectionPageInfo     `json:"pageInfo"`
	Nodes    []*listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelIssuesIssueConnectionNodesIssue `json:"nodes"`
}

// GetPageInfo returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelIssuesIssueConnection.PageInfo, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelIssuesIssueConnection) GetPageInfo() *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelIssuesIssueConnectionPageInfo {
	return v.PageInfo
}

// GetNodes returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelIssuesIssueConnection.Nodes, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelIssuesIssueConnection) GetNodes() []*listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelIssuesIssueConnectionNodesIssue {
	return v.Nodes
}

// listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelIssuesIssueConnectionNodesIssue includes the requested fields of the GraphQL type Issue.
// The GraphQL type's documentation follows.
//
// An issue.
type listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelIssuesIssueConnectionNodesIssue struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
}

// GetId returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelIssuesIssueConnectionNodesIssue.Id, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelIssuesIssueConnectionNodesIssue) GetId() *string {
	return v.Id
}

// listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelIssuesIssueConnectionPageInfo includes the requested fields of the GraphQL type PageInfo.
type listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelIssuesIssueConnectionPageInfo struct {
	// Indicates if there are more results when paginating forward.
	HasNextPage *bool `json:"hasNextPage"`
	// Cursor representing the last result in the paginated results.
	EndCursor *string `json:"endCursor"`
}

// GetHasNextPage returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelIssuesIssueConnectionPageInfo.HasNextPage, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelIssuesIssueConnectionPageInfo) GetHasNextPage() *bool {
	return v.HasNextPage
}

// GetEndCursor returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelIssuesIssueConnectionPageInfo.EndCursor, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelIssuesIssueConnectionPageInfo) GetEndCursor() *string {
	return v.EndCursor
}

// listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization includes the requested fields of the GraphQL type Organization.
// The GraphQL type's documentation follows.
//
// An organization. Organizations are root-level objects that contain user accounts and teams.
type listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// Allowed authentication providers, empty array means all are allowed
	AllowedAuthServices []*string `json:"allowedAuthServices"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Number of issues in the organization.
	CreatedIssueCount *int `json:"createdIssueCount"`
	// The time at which deletion of the organization was requested.
	DeletionRequestedAt *time.Time `json:"-"`
	// How git branches are formatted. If null, default formatting will be used.
	GitBranchFormat *string `json:"gitBranchFormat"`
	// Whether the Git integration linkback messages should be sent to private repositories.
	GitLinkbackMessagesEnabled *bool `json:"gitLinkbackMessagesEnabled"`
	// Whether the Git integration linkback messages should be sent to public repositories.
	GitPublicLinkbackMessagesEnabled *bool `json:"gitPublicLinkbackMessagesEnabled"`
	// The organization's logo URL.
	LogoUrl *string `json:"logoUrl"`
	// The organization's name.
	Name *string `json:"name"`
	// Rolling 30-day total upload volume for the organization, in megabytes.
	PeriodUploadVolume *float64 `json:"periodUploadVolume"`
	// Previously used URL keys for the organization (last 3 are kept and redirected).
	PreviousUrlKeys []*string `json:"previousUrlKeys"`
	// The day at which to prompt for project updates.
	ProjectUpdateRemindersDay *Day `json:"projectUpdateRemindersDay"`
	// The hour at which to prompt for project updates.
	ProjectUpdateRemindersHour *float64 `json:"projectUpdateRemindersHour"`
	// The frequency at which to prompt for project updates.
	ProjectUpdatesReminderFrequency *ProjectUpdateReminderFrequency `json:"projectUpdatesReminderFrequency"`
	// The feature release channel the organization belongs to.
	ReleaseChannel *ReleaseChannel `json:"releaseChannel"`
	// Whether the organization is using a roadmap.
	RoadmapEnabled *bool `json:"roadmapEnabled"`
	// Whether SAML authentication is enabled for organization.
	SamlEnabled *bool `json:"samlEnabled"`
	// Whether SCIM provisioning is enabled for organization.
	ScimEnabled *bool `json:"scimEnabled"`
	// The time at which the trial of the plus plan will end.
	TrialEndsAt *time.Time `json:"-"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// The organization's unique URL key.
	UrlKey *string `json:"urlKey"`
	// Number of active users in the organization.
	UserCount *int `json:"userCount"`
}

// GetId returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization.Id, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization) GetId() *string {
	return v.Id
}

// GetAllowedAuthServices returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization.AllowedAuthServices, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization) GetAllowedAuthServices() []*string {
	return v.AllowedAuthServices
}

// GetArchivedAt returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetCreatedAt returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization.CreatedAt, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetCreatedIssueCount returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization.CreatedIssueCount, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization) GetCreatedIssueCount() *int {
	return v.CreatedIssueCount
}

// GetDeletionRequestedAt returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization.DeletionRequestedAt, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization) GetDeletionRequestedAt() *time.Time {
	return v.DeletionRequestedAt
}

// GetGitBranchFormat returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization.GitBranchFormat, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization) GetGitBranchFormat() *string {
	return v.GitBranchFormat
}

// GetGitLinkbackMessagesEnabled returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization.GitLinkbackMessagesEnabled, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization) GetGitLinkbackMessagesEnabled() *bool {
	return v.GitLinkbackMessagesEnabled
}

// GetGitPublicLinkbackMessagesEnabled returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization.GitPublicLinkbackMessagesEnabled, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization) GetGitPublicLinkbackMessagesEnabled() *bool {
	return v.GitPublicLinkbackMessagesEnabled
}

// GetLogoUrl returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization.LogoUrl, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization) GetLogoUrl() *string {
	return v.LogoUrl
}

// GetName returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization.Name, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization) GetName() *string {
	return v.Name
}

// GetPeriodUploadVolume returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization.PeriodUploadVolume, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization) GetPeriodUploadVolume() *float64 {
	return v.PeriodUploadVolume
}

// GetPreviousUrlKeys returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization.PreviousUrlKeys, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization) GetPreviousUrlKeys() []*string {
	return v.PreviousUrlKeys
}

// GetProjectUpdateRemindersDay returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization.ProjectUpdateRemindersDay, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization) GetProjectUpdateRemindersDay() *Day {
	return v.ProjectUpdateRemindersDay
}

// GetProjectUpdateRemindersHour returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization.ProjectUpdateRemindersHour, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization) GetProjectUpdateRemindersHour() *float64 {
	return v.ProjectUpdateRemindersHour
}

// GetProjectUpdatesReminderFrequency returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization.ProjectUpdatesReminderFrequency, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization) GetProjectUpdatesReminderFrequency() *ProjectUpdateReminderFrequency {
	return v.ProjectUpdatesReminderFrequency
}

// GetReleaseChannel returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization.ReleaseChannel, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization) GetReleaseChannel() *ReleaseChannel {
	return v.ReleaseChannel
}

// GetRoadmapEnabled returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization.RoadmapEnabled, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization) GetRoadmapEnabled() *bool {
	return v.RoadmapEnabled
}

// GetSamlEnabled returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization.SamlEnabled, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization) GetSamlEnabled() *bool {
	return v.SamlEnabled
}

// GetScimEnabled returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization.ScimEnabled, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization) GetScimEnabled() *bool {
	return v.ScimEnabled
}

// GetTrialEndsAt returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization.TrialEndsAt, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization) GetTrialEndsAt() *time.Time {
	return v.TrialEndsAt
}

// GetUpdatedAt returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

// GetUrlKey returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization.UrlKey, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization) GetUrlKey() *string {
	return v.UrlKey
}

// GetUserCount returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization.UserCount, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization) GetUserCount() *int {
	return v.UserCount
}

func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization
		ArchivedAt          json.RawMessage `json:"archivedAt"`
		CreatedAt           json.RawMessage `json:"createdAt"`
		DeletionRequestedAt json.RawMessage `json:"deletionRequestedAt"`
		TrialEndsAt         json.RawMessage `json:"trialEndsAt"`
		UpdatedAt           json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.DeletionRequestedAt
		src := firstPass.DeletionRequestedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization.DeletionRequestedAt: %w", err)
			}
		}
	}

	{
		dst := &v.TrialEndsAt
		src := firstPass.TrialEndsAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization.TrialEndsAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization struct {
	Id *string `json:"id"`

	AllowedAuthServices []*string `json:"allowedAuthServices"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CreatedIssueCount *int `json:"createdIssueCount"`

	DeletionRequestedAt json.RawMessage `json:"deletionRequestedAt"`

	GitBranchFormat *string `json:"gitBranchFormat"`

	GitLinkbackMessagesEnabled *bool `json:"gitLinkbackMessagesEnabled"`

	GitPublicLinkbackMessagesEnabled *bool `json:"gitPublicLinkbackMessagesEnabled"`

	LogoUrl *string `json:"logoUrl"`

	Name *string `json:"name"`

	PeriodUploadVolume *float64 `json:"periodUploadVolume"`

	PreviousUrlKeys []*string `json:"previousUrlKeys"`

	ProjectUpdateRemindersDay *Day `json:"projectUpdateRemindersDay"`

	ProjectUpdateRemindersHour *float64 `json:"projectUpdateRemindersHour"`

	ProjectUpdatesReminderFrequency *ProjectUpdateReminderFrequency `json:"projectUpdatesReminderFrequency"`

	ReleaseChannel *ReleaseChannel `json:"releaseChannel"`

	RoadmapEnabled *bool `json:"roadmapEnabled"`

	SamlEnabled *bool `json:"samlEnabled"`

	ScimEnabled *bool `json:"scimEnabled"`

	TrialEndsAt json.RawMessage `json:"trialEndsAt"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	UrlKey *string `json:"urlKey"`

	UserCount *int `json:"userCount"`
}

func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization) __premarshalJSON() (*__premarshallistIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization, error) {
	var retval __premarshallistIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization

	retval.Id = v.Id
	retval.AllowedAuthServices = v.AllowedAuthServices
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization.ArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization.CreatedAt: %w", err)
			}
		}
	}
	retval.CreatedIssueCount = v.CreatedIssueCount
	{

		dst := &retval.DeletionRequestedAt
		src := v.DeletionRequestedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization.DeletionRequestedAt: %w", err)
			}
		}
	}
	retval.GitBranchFormat = v.GitBranchFormat
	retval.GitLinkbackMessagesEnabled = v.GitLinkbackMessagesEnabled
	retval.GitPublicLinkbackMessagesEnabled = v.GitPublicLinkbackMessagesEnabled
	retval.LogoUrl = v.LogoUrl
	retval.Name = v.Name
	retval.PeriodUploadVolume = v.PeriodUploadVolume
	retval.PreviousUrlKeys = v.PreviousUrlKeys
	retval.ProjectUpdateRemindersDay = v.ProjectUpdateRemindersDay
	retval.ProjectUpdateRemindersHour = v.ProjectUpdateRemindersHour
	retval.ProjectUpdatesReminderFrequency = v.ProjectUpdatesReminderFrequency
	retval.ReleaseChannel = v.ReleaseChannel
	retval.RoadmapEnabled = v.RoadmapEnabled
	retval.SamlEnabled = v.SamlEnabled
	retval.ScimEnabled = v.ScimEnabled
	{

		dst := &retval.TrialEndsAt
		src := v.TrialEndsAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization.TrialEndsAt: %w", err)
			}
		}
	}
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelOrganization.UpdatedAt: %w", err)
			}
		}
	}
	retval.UrlKey = v.UrlKey
	retval.UserCount = v.UserCount
	return &retval, nil
}

// listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelParentIssueLabel includes the requested fields of the GraphQL type IssueLabel.
// The GraphQL type's documentation follows.
//
// Labels that can be associated with issues.
type listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelParentIssueLabel struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The label's color as a HEX string.
	Color *string `json:"color"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// The label's description.
	Description *string `json:"description"`
	// The label's name.
	Name *string `json:"name"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
}

// GetId returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelParentIssueLabel.Id, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelParentIssueLabel) GetId() *string {
	return v.Id
}

// GetArchivedAt returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelParentIssueLabel.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelParentIssueLabel) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetColor returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelParentIssueLabel.Color, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelParentIssueLabel) GetColor() *string {
	return v.Color
}

// GetCreatedAt returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelParentIssueLabel.CreatedAt, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelParentIssueLabel) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetDescription returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelParentIssueLabel.Description, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelParentIssueLabel) GetDescription() *string {
	return v.Description
}

// GetName returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelParentIssueLabel.Name, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelParentIssueLabel) GetName() *string {
	return v.Name
}

// GetUpdatedAt returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelParentIssueLabel.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelParentIssueLabel) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelParentIssueLabel) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelParentIssueLabel
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelParentIssueLabel = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelParentIssueLabel.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelParentIssueLabel.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelParentIssueLabel.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelParentIssueLabel struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	Color *string `json:"color"`

	CreatedAt json.RawMessage `json:"createdAt"`

	Description *string `json:"description"`

	Name *string `json:"name"`

	UpdatedAt json.RawMessage `json:"updatedAt"`
}

func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelParentIssueLabel) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelParentIssueLabel) __premarshalJSON() (*__premarshallistIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelParentIssueLabel, error) {
	var retval __premarshallistIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelParentIssueLabel

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelParentIssueLabel.ArchivedAt: %w", err)
			}
		}
	}
	retval.Color = v.Color
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelParentIssueLabel.CreatedAt: %w", err)
			}
		}
	}
	retval.Description = v.Description
	retval.Name = v.Name
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelParentIssueLabel.UpdatedAt: %w", err)
			}
		}
	}
	return &retval, nil
}

// listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam includes the requested fields of the GraphQL type Team.
// The GraphQL type's documentation follows.
//
// An organizational unit that contains issues.
type listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// Period after which automatically closed and completed issues are automatically archived in months.
	AutoArchivePeriod *float64 `json:"autoArchivePeriod"`
	// Period after which issues are automatically closed in months. Null/undefined means disabled.
	AutoClosePeriod *float64 `json:"autoClosePeriod"`
	// The canceled workflow state which auto closed issues will be set to. Defaults to the first canceled state.
	AutoCloseStateId *string `json:"autoCloseStateId"`
	// The team's color.
	Color *string `json:"color"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Calendar feed URL (iCal) for cycles.
	CycleCalenderUrl *string `json:"cycleCalenderUrl"`
	// The cooldown time after each cycle in weeks.
	CycleCooldownTime *float64 `json:"cycleCooldownTime"`
	// The duration of a cycle in weeks.
	CycleDuration *float64 `json:"cycleDuration"`
	// Auto assign completed issues to current cycle.
	CycleIssueAutoAssignCompleted *bool `json:"cycleIssueAutoAssignCompleted"`
	// Auto assign started issues to current cycle.
	CycleIssueAutoAssignStarted *bool `json:"cycleIssueAutoAssignStarted"`
	// Only allow issues issues with cycles in Active Issues.
	CycleLockToActive *bool `json:"cycleLockToActive"`
	// The day of the week that a new cycle starts.
	CycleStartDay *float64 `json:"cycleStartDay"`
	// Whether the team uses cycles.
	CyclesEnabled *bool `json:"cyclesEnabled"`
	// What to use as an default estimate for unestimated issues.
	DefaultIssueEstimate *float64 `json:"defaultIssueEstimate"`
	// The id of the default template to use for new issues created by members of the team.
	DefaultTemplateForMembersId *string `json:"defaultTemplateForMembersId"`
	// The id of the default template to use for new issues created by non-members of the team.
	DefaultTemplateForNonMembersId *string `json:"defaultTemplateForNonMembersId"`
	// The team's description.
	Description *string `json:"description"`
	// Whether to group recent issue history entries.
	GroupIssueHistory *bool `json:"groupIssueHistory"`
	// The icon of the team.
	Icon *string `json:"icon"`
	// Unique hash for the team to be used in invite URLs.
	InviteHash *string `json:"inviteHash"`
	// Whether to allow zeros in issues estimates.
	IssueEstimationAllowZero *bool `json:"issueEstimationAllowZero"`
	// Whether to add additional points to the estimate scale.
	IssueEstimationExtended *bool `json:"issueEstimationExtended"`
	// The issue estimation type to use.
	IssueEstimationType *string `json:"issueEstimationType"`
	// Whether issues without priority should be sorted first.
	IssueOrderingNoPriorityFirst *bool `json:"issueOrderingNoPriorityFirst"`
	// Whether to move issues to bottom of the column when changing state.
	IssueSortOrderDefaultToBottom *bool `json:"issueSortOrderDefaultToBottom"`
	// The team's unique key. The key is used in URLs.
	Key *string `json:"key"`
	// The team's name.
	Name *string `json:"name"`
	// Whether the team is private or not.
	Private *bool `json:"private"`
	// Whether an issue needs to have a priority set before leaving triage
	RequirePriorityToLeaveTriage *bool `json:"requirePriorityToLeaveTriage"`
	// Whether to send new issue comment notifications to Slack.
	SlackIssueComments *bool `json:"slackIssueComments"`
	// Whether to send new issue status updates to Slack.
	SlackIssueStatuses *bool `json:"slackIssueStatuses"`
	// Whether to send new issue notifications to Slack.
	SlackNewIssue *bool `json:"slackNewIssue"`
	// The timezone of the team. Defaults to "America/Los_Angeles"
	Timezone *string `json:"timezone"`
	// Whether triage mode is enabled for the team or not.
	TriageEnabled *bool `json:"triageEnabled"`
	// How many upcoming cycles to create.
	UpcomingCycleCount *float64 `json:"upcomingCycleCount"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
}

// GetId returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.Id, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) GetId() *string {
	return v.Id
}

// GetArchivedAt returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetAutoArchivePeriod returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.AutoArchivePeriod, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) GetAutoArchivePeriod() *float64 {
	return v.AutoArchivePeriod
}

// GetAutoClosePeriod returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.AutoClosePeriod, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) GetAutoClosePeriod() *float64 {
	return v.AutoClosePeriod
}

// GetAutoCloseStateId returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.AutoCloseStateId, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) GetAutoCloseStateId() *string {
	return v.AutoCloseStateId
}

// GetColor returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.Color, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) GetColor() *string {
	return v.Color
}

// GetCreatedAt returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.CreatedAt, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetCycleCalenderUrl returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.CycleCalenderUrl, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) GetCycleCalenderUrl() *string {
	return v.CycleCalenderUrl
}

// GetCycleCooldownTime returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.CycleCooldownTime, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) GetCycleCooldownTime() *float64 {
	return v.CycleCooldownTime
}

// GetCycleDuration returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.CycleDuration, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) GetCycleDuration() *float64 {
	return v.CycleDuration
}

// GetCycleIssueAutoAssignCompleted returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.CycleIssueAutoAssignCompleted, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) GetCycleIssueAutoAssignCompleted() *bool {
	return v.CycleIssueAutoAssignCompleted
}

// GetCycleIssueAutoAssignStarted returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.CycleIssueAutoAssignStarted, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) GetCycleIssueAutoAssignStarted() *bool {
	return v.CycleIssueAutoAssignStarted
}

// GetCycleLockToActive returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.CycleLockToActive, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) GetCycleLockToActive() *bool {
	return v.CycleLockToActive
}

// GetCycleStartDay returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.CycleStartDay, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) GetCycleStartDay() *float64 {
	return v.CycleStartDay
}

// GetCyclesEnabled returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.CyclesEnabled, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) GetCyclesEnabled() *bool {
	return v.CyclesEnabled
}

// GetDefaultIssueEstimate returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.DefaultIssueEstimate, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) GetDefaultIssueEstimate() *float64 {
	return v.DefaultIssueEstimate
}

// GetDefaultTemplateForMembersId returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.DefaultTemplateForMembersId, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) GetDefaultTemplateForMembersId() *string {
	return v.DefaultTemplateForMembersId
}

// GetDefaultTemplateForNonMembersId returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.DefaultTemplateForNonMembersId, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) GetDefaultTemplateForNonMembersId() *string {
	return v.DefaultTemplateForNonMembersId
}

// GetDescription returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.Description, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) GetDescription() *string {
	return v.Description
}

// GetGroupIssueHistory returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.GroupIssueHistory, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) GetGroupIssueHistory() *bool {
	return v.GroupIssueHistory
}

// GetIcon returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.Icon, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) GetIcon() *string {
	return v.Icon
}

// GetInviteHash returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.InviteHash, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) GetInviteHash() *string {
	return v.InviteHash
}

// GetIssueEstimationAllowZero returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.IssueEstimationAllowZero, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) GetIssueEstimationAllowZero() *bool {
	return v.IssueEstimationAllowZero
}

// GetIssueEstimationExtended returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.IssueEstimationExtended, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) GetIssueEstimationExtended() *bool {
	return v.IssueEstimationExtended
}

// GetIssueEstimationType returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.IssueEstimationType, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) GetIssueEstimationType() *string {
	return v.IssueEstimationType
}

// GetIssueOrderingNoPriorityFirst returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.IssueOrderingNoPriorityFirst, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) GetIssueOrderingNoPriorityFirst() *bool {
	return v.IssueOrderingNoPriorityFirst
}

// GetIssueSortOrderDefaultToBottom returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.IssueSortOrderDefaultToBottom, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) GetIssueSortOrderDefaultToBottom() *bool {
	return v.IssueSortOrderDefaultToBottom
}

// GetKey returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.Key, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) GetKey() *string {
	return v.Key
}

// GetName returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.Name, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) GetName() *string {
	return v.Name
}

// GetPrivate returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.Private, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) GetPrivate() *bool {
	return v.Private
}

// GetRequirePriorityToLeaveTriage returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.RequirePriorityToLeaveTriage, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) GetRequirePriorityToLeaveTriage() *bool {
	return v.RequirePriorityToLeaveTriage
}

// GetSlackIssueComments returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.SlackIssueComments, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) GetSlackIssueComments() *bool {
	return v.SlackIssueComments
}

// GetSlackIssueStatuses returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.SlackIssueStatuses, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) GetSlackIssueStatuses() *bool {
	return v.SlackIssueStatuses
}

// GetSlackNewIssue returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.SlackNewIssue, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) GetSlackNewIssue() *bool {
	return v.SlackNewIssue
}

// GetTimezone returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.Timezone, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) GetTimezone() *string {
	return v.Timezone
}

// GetTriageEnabled returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.TriageEnabled, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) GetTriageEnabled() *bool {
	return v.TriageEnabled
}

// GetUpcomingCycleCount returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.UpcomingCycleCount, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) GetUpcomingCycleCount() *float64 {
	return v.UpcomingCycleCount
}

// GetUpdatedAt returns listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AutoArchivePeriod *float64 `json:"autoArchivePeriod"`

	AutoClosePeriod *float64 `json:"autoClosePeriod"`

	AutoCloseStateId *string `json:"autoCloseStateId"`

	Color *string `json:"color"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CycleCalenderUrl *string `json:"cycleCalenderUrl"`

	CycleCooldownTime *float64 `json:"cycleCooldownTime"`

	CycleDuration *float64 `json:"cycleDuration"`

	CycleIssueAutoAssignCompleted *bool `json:"cycleIssueAutoAssignCompleted"`

	CycleIssueAutoAssignStarted *bool `json:"cycleIssueAutoAssignStarted"`

	CycleLockToActive *bool `json:"cycleLockToActive"`

	CycleStartDay *float64 `json:"cycleStartDay"`

	CyclesEnabled *bool `json:"cyclesEnabled"`

	DefaultIssueEstimate *float64 `json:"defaultIssueEstimate"`

	DefaultTemplateForMembersId *string `json:"defaultTemplateForMembersId"`

	DefaultTemplateForNonMembersId *string `json:"defaultTemplateForNonMembersId"`

	Description *string `json:"description"`

	GroupIssueHistory *bool `json:"groupIssueHistory"`

	Icon *string `json:"icon"`

	InviteHash *string `json:"inviteHash"`

	IssueEstimationAllowZero *bool `json:"issueEstimationAllowZero"`

	IssueEstimationExtended *bool `json:"issueEstimationExtended"`

	IssueEstimationType *string `json:"issueEstimationType"`

	IssueOrderingNoPriorityFirst *bool `json:"issueOrderingNoPriorityFirst"`

	IssueSortOrderDefaultToBottom *bool `json:"issueSortOrderDefaultToBottom"`

	Key *string `json:"key"`

	Name *string `json:"name"`

	Private *bool `json:"private"`

	RequirePriorityToLeaveTriage *bool `json:"requirePriorityToLeaveTriage"`

	SlackIssueComments *bool `json:"slackIssueComments"`

	SlackIssueStatuses *bool `json:"slackIssueStatuses"`

	SlackNewIssue *bool `json:"slackNewIssue"`

	Timezone *string `json:"timezone"`

	TriageEnabled *bool `json:"triageEnabled"`

	UpcomingCycleCount *float64 `json:"upcomingCycleCount"`

	UpdatedAt json.RawMessage `json:"updatedAt"`
}

func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam) __premarshalJSON() (*__premarshallistIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam, error) {
	var retval __premarshallistIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.ArchivedAt: %w", err)
			}
		}
	}
	retval.AutoArchivePeriod = v.AutoArchivePeriod
	retval.AutoClosePeriod = v.AutoClosePeriod
	retval.AutoCloseStateId = v.AutoCloseStateId
	retval.Color = v.Color
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.CreatedAt: %w", err)
			}
		}
	}
	retval.CycleCalenderUrl = v.CycleCalenderUrl
	retval.CycleCooldownTime = v.CycleCooldownTime
	retval.CycleDuration = v.CycleDuration
	retval.CycleIssueAutoAssignCompleted = v.CycleIssueAutoAssignCompleted
	retval.CycleIssueAutoAssignStarted = v.CycleIssueAutoAssignStarted
	retval.CycleLockToActive = v.CycleLockToActive
	retval.CycleStartDay = v.CycleStartDay
	retval.CyclesEnabled = v.CyclesEnabled
	retval.DefaultIssueEstimate = v.DefaultIssueEstimate
	retval.DefaultTemplateForMembersId = v.DefaultTemplateForMembersId
	retval.DefaultTemplateForNonMembersId = v.DefaultTemplateForNonMembersId
	retval.Description = v.Description
	retval.GroupIssueHistory = v.GroupIssueHistory
	retval.Icon = v.Icon
	retval.InviteHash = v.InviteHash
	retval.IssueEstimationAllowZero = v.IssueEstimationAllowZero
	retval.IssueEstimationExtended = v.IssueEstimationExtended
	retval.IssueEstimationType = v.IssueEstimationType
	retval.IssueOrderingNoPriorityFirst = v.IssueOrderingNoPriorityFirst
	retval.IssueSortOrderDefaultToBottom = v.IssueSortOrderDefaultToBottom
	retval.Key = v.Key
	retval.Name = v.Name
	retval.Private = v.Private
	retval.RequirePriorityToLeaveTriage = v.RequirePriorityToLeaveTriage
	retval.SlackIssueComments = v.SlackIssueComments
	retval.SlackIssueStatuses = v.SlackIssueStatuses
	retval.SlackNewIssue = v.SlackNewIssue
	retval.Timezone = v.Timezone
	retval.TriageEnabled = v.TriageEnabled
	retval.UpcomingCycleCount = v.UpcomingCycleCount
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssueLabelsIssueLabelsIssueLabelConnectionNodesIssueLabelTeam.UpdatedAt: %w", err)
			}
		}
	}
	return &retval, nil
}

// listIssueLabelsIssueLabelsIssueLabelConnectionPageInfo includes the requested fields of the GraphQL type PageInfo.
type listIssueLabelsIssueLabelsIssueLabelConnectionPageInfo struct {
	// Indicates if there are more results when paginating forward.
	HasNextPage *bool `json:"hasNextPage"`
	// Cursor representing the last result in the paginated results.
	EndCursor *string `json:"endCursor"`
}

// GetHasNextPage returns listIssueLabelsIssueLabelsIssueLabelConnectionPageInfo.HasNextPage, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionPageInfo) GetHasNextPage() *bool {
	return v.HasNextPage
}

// GetEndCursor returns listIssueLabelsIssueLabelsIssueLabelConnectionPageInfo.EndCursor, and is useful for accessing the field via an interface.
func (v *listIssueLabelsIssueLabelsIssueLabelConnectionPageInfo) GetEndCursor() *string {
	return v.EndCursor
}

// listIssueLabelsResponse is returned by listIssueLabels on success.
type listIssueLabelsResponse struct {
	// All issue labels.
	IssueLabels *listIssueLabelsIssueLabelsIssueLabelConnection `json:"issueLabels"`
}

// GetIssueLabels returns listIssueLabelsResponse.IssueLabels, and is useful for accessing the field via an interface.
func (v *listIssueLabelsResponse) GetIssueLabels() *listIssueLabelsIssueLabelsIssueLabelConnection {
	return v.IssueLabels
}

// listIssuesIssuesIssueConnection includes the requested fields of the GraphQL type IssueConnection.
type listIssuesIssuesIssueConnection struct {
	PageInfo *listIssuesIssuesIssueConnectionPageInfo     `json:"pageInfo"`
	Nodes    []*listIssuesIssuesIssueConnectionNodesIssue `json:"nodes"`
}

// GetPageInfo returns listIssuesIssuesIssueConnection.PageInfo, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnection) GetPageInfo() *listIssuesIssuesIssueConnectionPageInfo {
	return v.PageInfo
}

// GetNodes returns listIssuesIssuesIssueConnection.Nodes, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnection) GetNodes() []*listIssuesIssuesIssueConnectionNodesIssue {
	return v.Nodes
}

// listIssuesIssuesIssueConnectionNodesIssue includes the requested fields of the GraphQL type Issue.
// The GraphQL type's documentation follows.
//
// An issue.
type listIssuesIssuesIssueConnectionNodesIssue struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The issue's unique number.
	Number *float64 `json:"number"`
	// The issue's title.
	Title *string `json:"title"`
	// The issue's description in markdown format.
	Description *string `json:"description"`
	// The priority of the issue. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low.
	Priority *float64 `json:"priority"`
	// The estimate of the complexity of the issue..
	Estimate *float64 `json:"estimate"`
	// The order of the item in relation to other items in the organization.
	SortOrder *float64 `json:"sortOrder"`
	// The time at which the issue was moved into started state.
	StartedAt *time.Time `json:"-"`
	// The time at which the issue was moved into completed state.
	CompletedAt *time.Time `json:"-"`
	// The time at which the issue was moved into canceled state.
	CanceledAt *time.Time `json:"-"`
	// The time at which the issue was automatically closed by the auto pruning process.
	AutoClosedAt *time.Time `json:"-"`
	// The time at which the issue was automatically archived by the auto pruning process.
	AutoArchivedAt *time.Time `json:"-"`
	// The date at which the issue is due.
	DueDate *time.Time `json:"-"`
	// A flag that indicates whether the issue is in the trash bin.
	Trashed *bool `json:"trashed"`
	// The time until an issue will be snoozed in Triage view.
	SnoozedUntilAt *time.Time `json:"-"`
	// Previous identifiers of the issue if it has been moved between teams.
	PreviousIdentifiers []*string `json:"previousIdentifiers"`
	// The order of the item in the sub-issue list. Only set if the issue has a parent.
	SubIssueSortOrder *float64 `json:"subIssueSortOrder"`
	// Label for the priority.
	PriorityLabel *string `json:"priorityLabel"`
	// Issue's human readable identifier (e.g. ENG-123).
	Identifier *string `json:"identifier"`
	// Issue URL.
	Url *string `json:"url"`
	// Suggested branch name for the issue.
	BranchName *string `json:"branchName"`
	// Returns the number of Attachment resources which are created by customer support ticketing systems (e.g. Zendesk).
	CustomerTicketCount *int `json:"customerTicketCount"`
	// The team that the issue is associated with.
	Team *listIssuesIssuesIssueConnectionNodesIssueTeam `json:"team"`
	// The cycle that the issue is associated with.
	Cycle *listIssuesIssuesIssueConnectionNodesIssueCycle `json:"cycle"`
	// The project that the issue is associated with.
	Project *listIssuesIssuesIssueConnectionNodesIssueProject `json:"project"`
	// The user who created the issue.
	Creator *listIssuesIssuesIssueConnectionNodesIssueCreatorUser `json:"creator"`
	// The user to whom the issue is assigned to.
	Assignee *listIssuesIssuesIssueConnectionNodesIssueAssigneeUser `json:"assignee"`
	// The user who snoozed the issue.
	SnoozedBy *listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser `json:"snoozedBy"`
	// The workflow state that the issue is associated with.
	State *listIssuesIssuesIssueConnectionNodesIssueStateWorkflowState `json:"state"`
	// The parent of the issue.
	Parent *listIssuesIssuesIssueConnectionNodesIssueParentIssue `json:"parent"`
	// The projectMilestone that the issue is associated with.
	ProjectMilestone *listIssuesIssuesIssueConnectionNodesIssueProjectMilestone `json:"projectMilestone"`
}

// GetId returns listIssuesIssuesIssueConnectionNodesIssue.Id, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssue) GetId() *string { return v.Id }

// GetCreatedAt returns listIssuesIssuesIssueConnectionNodesIssue.CreatedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssue) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetUpdatedAt returns listIssuesIssuesIssueConnectionNodesIssue.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssue) GetUpdatedAt() *time.Time { return v.UpdatedAt }

// GetArchivedAt returns listIssuesIssuesIssueConnectionNodesIssue.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssue) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetNumber returns listIssuesIssuesIssueConnectionNodesIssue.Number, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssue) GetNumber() *float64 { return v.Number }

// GetTitle returns listIssuesIssuesIssueConnectionNodesIssue.Title, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssue) GetTitle() *string { return v.Title }

// GetDescription returns listIssuesIssuesIssueConnectionNodesIssue.Description, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssue) GetDescription() *string { return v.Description }

// GetPriority returns listIssuesIssuesIssueConnectionNodesIssue.Priority, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssue) GetPriority() *float64 { return v.Priority }

// GetEstimate returns listIssuesIssuesIssueConnectionNodesIssue.Estimate, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssue) GetEstimate() *float64 { return v.Estimate }

// GetSortOrder returns listIssuesIssuesIssueConnectionNodesIssue.SortOrder, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssue) GetSortOrder() *float64 { return v.SortOrder }

// GetStartedAt returns listIssuesIssuesIssueConnectionNodesIssue.StartedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssue) GetStartedAt() *time.Time { return v.StartedAt }

// GetCompletedAt returns listIssuesIssuesIssueConnectionNodesIssue.CompletedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssue) GetCompletedAt() *time.Time { return v.CompletedAt }

// GetCanceledAt returns listIssuesIssuesIssueConnectionNodesIssue.CanceledAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssue) GetCanceledAt() *time.Time { return v.CanceledAt }

// GetAutoClosedAt returns listIssuesIssuesIssueConnectionNodesIssue.AutoClosedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssue) GetAutoClosedAt() *time.Time {
	return v.AutoClosedAt
}

// GetAutoArchivedAt returns listIssuesIssuesIssueConnectionNodesIssue.AutoArchivedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssue) GetAutoArchivedAt() *time.Time {
	return v.AutoArchivedAt
}

// GetDueDate returns listIssuesIssuesIssueConnectionNodesIssue.DueDate, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssue) GetDueDate() *time.Time { return v.DueDate }

// GetTrashed returns listIssuesIssuesIssueConnectionNodesIssue.Trashed, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssue) GetTrashed() *bool { return v.Trashed }

// GetSnoozedUntilAt returns listIssuesIssuesIssueConnectionNodesIssue.SnoozedUntilAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssue) GetSnoozedUntilAt() *time.Time {
	return v.SnoozedUntilAt
}

// GetPreviousIdentifiers returns listIssuesIssuesIssueConnectionNodesIssue.PreviousIdentifiers, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssue) GetPreviousIdentifiers() []*string {
	return v.PreviousIdentifiers
}

// GetSubIssueSortOrder returns listIssuesIssuesIssueConnectionNodesIssue.SubIssueSortOrder, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssue) GetSubIssueSortOrder() *float64 {
	return v.SubIssueSortOrder
}

// GetPriorityLabel returns listIssuesIssuesIssueConnectionNodesIssue.PriorityLabel, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssue) GetPriorityLabel() *string {
	return v.PriorityLabel
}

// GetIdentifier returns listIssuesIssuesIssueConnectionNodesIssue.Identifier, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssue) GetIdentifier() *string { return v.Identifier }

// GetUrl returns listIssuesIssuesIssueConnectionNodesIssue.Url, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssue) GetUrl() *string { return v.Url }

// GetBranchName returns listIssuesIssuesIssueConnectionNodesIssue.BranchName, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssue) GetBranchName() *string { return v.BranchName }

// GetCustomerTicketCount returns listIssuesIssuesIssueConnectionNodesIssue.CustomerTicketCount, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssue) GetCustomerTicketCount() *int {
	return v.CustomerTicketCount
}

// GetTeam returns listIssuesIssuesIssueConnectionNodesIssue.Team, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssue) GetTeam() *listIssuesIssuesIssueConnectionNodesIssueTeam {
	return v.Team
}

// GetCycle returns listIssuesIssuesIssueConnectionNodesIssue.Cycle, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssue) GetCycle() *listIssuesIssuesIssueConnectionNodesIssueCycle {
	return v.Cycle
}

// GetProject returns listIssuesIssuesIssueConnectionNodesIssue.Project, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssue) GetProject() *listIssuesIssuesIssueConnectionNodesIssueProject {
	return v.Project
}

// GetCreator returns listIssuesIssuesIssueConnectionNodesIssue.Creator, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssue) GetCreator() *listIssuesIssuesIssueConnectionNodesIssueCreatorUser {
	return v.Creator
}

// GetAssignee returns listIssuesIssuesIssueConnectionNodesIssue.Assignee, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssue) GetAssignee() *listIssuesIssuesIssueConnectionNodesIssueAssigneeUser {
	return v.Assignee
}

// GetSnoozedBy returns listIssuesIssuesIssueConnectionNodesIssue.SnoozedBy, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssue) GetSnoozedBy() *listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser {
	return v.SnoozedBy
}

// GetState returns listIssuesIssuesIssueConnectionNodesIssue.State, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssue) GetState() *listIssuesIssuesIssueConnectionNodesIssueStateWorkflowState {
	return v.State
}

// GetParent returns listIssuesIssuesIssueConnectionNodesIssue.Parent, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssue) GetParent() *listIssuesIssuesIssueConnectionNodesIssueParentIssue {
	return v.Parent
}

// GetProjectMilestone returns listIssuesIssuesIssueConnectionNodesIssue.ProjectMilestone, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssue) GetProjectMilestone() *listIssuesIssuesIssueConnectionNodesIssueProjectMilestone {
	return v.ProjectMilestone
}

func (v *listIssuesIssuesIssueConnectionNodesIssue) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listIssuesIssuesIssueConnectionNodesIssue
		CreatedAt      json.RawMessage `json:"createdAt"`
		UpdatedAt      json.RawMessage `json:"updatedAt"`
		ArchivedAt     json.RawMessage `json:"archivedAt"`
		StartedAt      json.RawMessage `json:"startedAt"`
		CompletedAt    json.RawMessage `json:"completedAt"`
		CanceledAt     json.RawMessage `json:"canceledAt"`
		AutoClosedAt   json.RawMessage `json:"autoClosedAt"`
		AutoArchivedAt json.RawMessage `json:"autoArchivedAt"`
		DueDate        json.RawMessage `json:"dueDate"`
		SnoozedUntilAt json.RawMessage `json:"snoozedUntilAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listIssuesIssuesIssueConnectionNodesIssue = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssue.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssue.UpdatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssue.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.StartedAt
		src := firstPass.StartedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssue.StartedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CompletedAt
		src := firstPass.CompletedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssue.CompletedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CanceledAt
		src := firstPass.CanceledAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssue.CanceledAt: %w", err)
			}
		}
	}

	{
		dst := &v.AutoClosedAt
		src := firstPass.AutoClosedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssue.AutoClosedAt: %w", err)
			}
		}
	}

	{
		dst := &v.AutoArchivedAt
		src := firstPass.AutoArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssue.AutoArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.DueDate
		src := firstPass.DueDate
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssue.DueDate: %w", err)
			}
		}
	}

	{
		dst := &v.SnoozedUntilAt
		src := firstPass.SnoozedUntilAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssue.SnoozedUntilAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistIssuesIssuesIssueConnectionNodesIssue struct {
	Id *string `json:"id"`

	CreatedAt json.RawMessage `json:"createdAt"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	Number *float64 `json:"number"`

	Title *string `json:"title"`

	Description *string `json:"description"`

	Priority *float64 `json:"priority"`

	Estimate *float64 `json:"estimate"`

	SortOrder *float64 `json:"sortOrder"`

	StartedAt json.RawMessage `json:"startedAt"`

	CompletedAt json.RawMessage `json:"completedAt"`

	CanceledAt json.RawMessage `json:"canceledAt"`

	AutoClosedAt json.RawMessage `json:"autoClosedAt"`

	AutoArchivedAt json.RawMessage `json:"autoArchivedAt"`

	DueDate json.RawMessage `json:"dueDate"`

	Trashed *bool `json:"trashed"`

	SnoozedUntilAt json.RawMessage `json:"snoozedUntilAt"`

	PreviousIdentifiers []*string `json:"previousIdentifiers"`

	SubIssueSortOrder *float64 `json:"subIssueSortOrder"`

	PriorityLabel *string `json:"priorityLabel"`

	Identifier *string `json:"identifier"`

	Url *string `json:"url"`

	BranchName *string `json:"branchName"`

	CustomerTicketCount *int `json:"customerTicketCount"`

	Team *listIssuesIssuesIssueConnectionNodesIssueTeam `json:"team"`

	Cycle *listIssuesIssuesIssueConnectionNodesIssueCycle `json:"cycle"`

	Project *listIssuesIssuesIssueConnectionNodesIssueProject `json:"project"`

	Creator *listIssuesIssuesIssueConnectionNodesIssueCreatorUser `json:"creator"`

	Assignee *listIssuesIssuesIssueConnectionNodesIssueAssigneeUser `json:"assignee"`

	SnoozedBy *listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser `json:"snoozedBy"`

	State *listIssuesIssuesIssueConnectionNodesIssueStateWorkflowState `json:"state"`

	Parent *listIssuesIssuesIssueConnectionNodesIssueParentIssue `json:"parent"`

	ProjectMilestone *listIssuesIssuesIssueConnectionNodesIssueProjectMilestone `json:"projectMilestone"`
}

func (v *listIssuesIssuesIssueConnectionNodesIssue) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listIssuesIssuesIssueConnectionNodesIssue) __premarshalJSON() (*__premarshallistIssuesIssuesIssueConnectionNodesIssue, error) {
	var retval __premarshallistIssuesIssuesIssueConnectionNodesIssue

	retval.Id = v.Id
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssue.CreatedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssue.UpdatedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssue.ArchivedAt: %w", err)
			}
		}
	}
	retval.Number = v.Number
	retval.Title = v.Title
	retval.Description = v.Description
	retval.Priority = v.Priority
	retval.Estimate = v.Estimate
	retval.SortOrder = v.SortOrder
	{

		dst := &retval.StartedAt
		src := v.StartedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssue.StartedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CompletedAt
		src := v.CompletedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssue.CompletedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CanceledAt
		src := v.CanceledAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssue.CanceledAt: %w", err)
			}
		}
	}
	{

		dst := &retval.AutoClosedAt
		src := v.AutoClosedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssue.AutoClosedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.AutoArchivedAt
		src := v.AutoArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssue.AutoArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.DueDate
		src := v.DueDate
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssue.DueDate: %w", err)
			}
		}
	}
	retval.Trashed = v.Trashed
	{

		dst := &retval.SnoozedUntilAt
		src := v.SnoozedUntilAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssue.SnoozedUntilAt: %w", err)
			}
		}
	}
	retval.PreviousIdentifiers = v.PreviousIdentifiers
	retval.SubIssueSortOrder = v.SubIssueSortOrder
	retval.PriorityLabel = v.PriorityLabel
	retval.Identifier = v.Identifier
	retval.Url = v.Url
	retval.BranchName = v.BranchName
	retval.CustomerTicketCount = v.CustomerTicketCount
	retval.Team = v.Team
	retval.Cycle = v.Cycle
	retval.Project = v.Project
	retval.Creator = v.Creator
	retval.Assignee = v.Assignee
	retval.SnoozedBy = v.SnoozedBy
	retval.State = v.State
	retval.Parent = v.Parent
	retval.ProjectMilestone = v.ProjectMilestone
	return &retval, nil
}

// listIssuesIssuesIssueConnectionNodesIssueAssigneeUser includes the requested fields of the GraphQL type User.
// The GraphQL type's documentation follows.
//
// A user that has access to the the resources of an organization.
type listIssuesIssuesIssueConnectionNodesIssueAssigneeUser struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// Whether the user account is active or disabled (suspended).
	Active *bool `json:"active"`
	// Whether the user is an organization administrator.
	Admin *bool `json:"admin"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// An URL to the user's avatar image.
	AvatarUrl *string `json:"avatarUrl"`
	// [DEPRECATED] Hash for the user to be used in calendar URLs.
	CalendarHash *string `json:"calendarHash"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Number of issues created.
	CreatedIssueCount *int `json:"createdIssueCount"`
	// A short description of the user, either its title or bio.
	Description *string `json:"description"`
	// Reason why is the account disabled.
	DisableReason *string `json:"disableReason"`
	// The user's display (nick) name. Unique within each organization.
	DisplayName *string `json:"displayName"`
	// The user's email address.
	Email *string `json:"email"`
	// Whether the user is a guest in the workspace and limited to accessing a subset of teams.
	Guest *bool `json:"guest"`
	// Unique hash for the user to be used in invite URLs.
	InviteHash *string `json:"inviteHash"`
	// Whether the user is the currently authenticated user.
	IsMe *bool `json:"isMe"`
	// The last time the user was seen online. If null, the user is currently online.
	LastSeen *time.Time `json:"-"`
	// The user's full name.
	Name *string `json:"name"`
	// The emoji to represent the user current status.
	StatusEmoji *string `json:"statusEmoji"`
	// The label of the user current status.
	StatusLabel *string `json:"statusLabel"`
	// A date at which the user current status should be cleared.
	StatusUntilAt *time.Time `json:"-"`
	// The local timezone of the user.
	Timezone *string `json:"timezone"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// User's profile URL.
	Url *string `json:"url"`
}

// GetId returns listIssuesIssuesIssueConnectionNodesIssueAssigneeUser.Id, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueAssigneeUser) GetId() *string { return v.Id }

// GetActive returns listIssuesIssuesIssueConnectionNodesIssueAssigneeUser.Active, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueAssigneeUser) GetActive() *bool { return v.Active }

// GetAdmin returns listIssuesIssuesIssueConnectionNodesIssueAssigneeUser.Admin, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueAssigneeUser) GetAdmin() *bool { return v.Admin }

// GetArchivedAt returns listIssuesIssuesIssueConnectionNodesIssueAssigneeUser.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueAssigneeUser) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetAvatarUrl returns listIssuesIssuesIssueConnectionNodesIssueAssigneeUser.AvatarUrl, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueAssigneeUser) GetAvatarUrl() *string {
	return v.AvatarUrl
}

// GetCalendarHash returns listIssuesIssuesIssueConnectionNodesIssueAssigneeUser.CalendarHash, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueAssigneeUser) GetCalendarHash() *string {
	return v.CalendarHash
}

// GetCreatedAt returns listIssuesIssuesIssueConnectionNodesIssueAssigneeUser.CreatedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueAssigneeUser) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetCreatedIssueCount returns listIssuesIssuesIssueConnectionNodesIssueAssigneeUser.CreatedIssueCount, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueAssigneeUser) GetCreatedIssueCount() *int {
	return v.CreatedIssueCount
}

// GetDescription returns listIssuesIssuesIssueConnectionNodesIssueAssigneeUser.Description, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueAssigneeUser) GetDescription() *string {
	return v.Description
}

// GetDisableReason returns listIssuesIssuesIssueConnectionNodesIssueAssigneeUser.DisableReason, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueAssigneeUser) GetDisableReason() *string {
	return v.DisableReason
}

// GetDisplayName returns listIssuesIssuesIssueConnectionNodesIssueAssigneeUser.DisplayName, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueAssigneeUser) GetDisplayName() *string {
	return v.DisplayName
}

// GetEmail returns listIssuesIssuesIssueConnectionNodesIssueAssigneeUser.Email, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueAssigneeUser) GetEmail() *string { return v.Email }

// GetGuest returns listIssuesIssuesIssueConnectionNodesIssueAssigneeUser.Guest, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueAssigneeUser) GetGuest() *bool { return v.Guest }

// GetInviteHash returns listIssuesIssuesIssueConnectionNodesIssueAssigneeUser.InviteHash, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueAssigneeUser) GetInviteHash() *string {
	return v.InviteHash
}

// GetIsMe returns listIssuesIssuesIssueConnectionNodesIssueAssigneeUser.IsMe, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueAssigneeUser) GetIsMe() *bool { return v.IsMe }

// GetLastSeen returns listIssuesIssuesIssueConnectionNodesIssueAssigneeUser.LastSeen, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueAssigneeUser) GetLastSeen() *time.Time {
	return v.LastSeen
}

// GetName returns listIssuesIssuesIssueConnectionNodesIssueAssigneeUser.Name, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueAssigneeUser) GetName() *string { return v.Name }

// GetStatusEmoji returns listIssuesIssuesIssueConnectionNodesIssueAssigneeUser.StatusEmoji, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueAssigneeUser) GetStatusEmoji() *string {
	return v.StatusEmoji
}

// GetStatusLabel returns listIssuesIssuesIssueConnectionNodesIssueAssigneeUser.StatusLabel, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueAssigneeUser) GetStatusLabel() *string {
	return v.StatusLabel
}

// GetStatusUntilAt returns listIssuesIssuesIssueConnectionNodesIssueAssigneeUser.StatusUntilAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueAssigneeUser) GetStatusUntilAt() *time.Time {
	return v.StatusUntilAt
}

// GetTimezone returns listIssuesIssuesIssueConnectionNodesIssueAssigneeUser.Timezone, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueAssigneeUser) GetTimezone() *string {
	return v.Timezone
}

// GetUpdatedAt returns listIssuesIssuesIssueConnectionNodesIssueAssigneeUser.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueAssigneeUser) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

// GetUrl returns listIssuesIssuesIssueConnectionNodesIssueAssigneeUser.Url, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueAssigneeUser) GetUrl() *string { return v.Url }

func (v *listIssuesIssuesIssueConnectionNodesIssueAssigneeUser) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listIssuesIssuesIssueConnectionNodesIssueAssigneeUser
		ArchivedAt    json.RawMessage `json:"archivedAt"`
		CreatedAt     json.RawMessage `json:"createdAt"`
		LastSeen      json.RawMessage `json:"lastSeen"`
		StatusUntilAt json.RawMessage `json:"statusUntilAt"`
		UpdatedAt     json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listIssuesIssuesIssueConnectionNodesIssueAssigneeUser = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueAssigneeUser.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueAssigneeUser.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.LastSeen
		src := firstPass.LastSeen
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueAssigneeUser.LastSeen: %w", err)
			}
		}
	}

	{
		dst := &v.StatusUntilAt
		src := firstPass.StatusUntilAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueAssigneeUser.StatusUntilAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueAssigneeUser.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistIssuesIssuesIssueConnectionNodesIssueAssigneeUser struct {
	Id *string `json:"id"`

	Active *bool `json:"active"`

	Admin *bool `json:"admin"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AvatarUrl *string `json:"avatarUrl"`

	CalendarHash *string `json:"calendarHash"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CreatedIssueCount *int `json:"createdIssueCount"`

	Description *string `json:"description"`

	DisableReason *string `json:"disableReason"`

	DisplayName *string `json:"displayName"`

	Email *string `json:"email"`

	Guest *bool `json:"guest"`

	InviteHash *string `json:"inviteHash"`

	IsMe *bool `json:"isMe"`

	LastSeen json.RawMessage `json:"lastSeen"`

	Name *string `json:"name"`

	StatusEmoji *string `json:"statusEmoji"`

	StatusLabel *string `json:"statusLabel"`

	StatusUntilAt json.RawMessage `json:"statusUntilAt"`

	Timezone *string `json:"timezone"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	Url *string `json:"url"`
}

func (v *listIssuesIssuesIssueConnectionNodesIssueAssigneeUser) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listIssuesIssuesIssueConnectionNodesIssueAssigneeUser) __premarshalJSON() (*__premarshallistIssuesIssuesIssueConnectionNodesIssueAssigneeUser, error) {
	var retval __premarshallistIssuesIssuesIssueConnectionNodesIssueAssigneeUser

	retval.Id = v.Id
	retval.Active = v.Active
	retval.Admin = v.Admin
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueAssigneeUser.ArchivedAt: %w", err)
			}
		}
	}
	retval.AvatarUrl = v.AvatarUrl
	retval.CalendarHash = v.CalendarHash
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueAssigneeUser.CreatedAt: %w", err)
			}
		}
	}
	retval.CreatedIssueCount = v.CreatedIssueCount
	retval.Description = v.Description
	retval.DisableReason = v.DisableReason
	retval.DisplayName = v.DisplayName
	retval.Email = v.Email
	retval.Guest = v.Guest
	retval.InviteHash = v.InviteHash
	retval.IsMe = v.IsMe
	{

		dst := &retval.LastSeen
		src := v.LastSeen
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueAssigneeUser.LastSeen: %w", err)
			}
		}
	}
	retval.Name = v.Name
	retval.StatusEmoji = v.StatusEmoji
	retval.StatusLabel = v.StatusLabel
	{

		dst := &retval.StatusUntilAt
		src := v.StatusUntilAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueAssigneeUser.StatusUntilAt: %w", err)
			}
		}
	}
	retval.Timezone = v.Timezone
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueAssigneeUser.UpdatedAt: %w", err)
			}
		}
	}
	retval.Url = v.Url
	return &retval, nil
}

// listIssuesIssuesIssueConnectionNodesIssueCreatorUser includes the requested fields of the GraphQL type User.
// The GraphQL type's documentation follows.
//
// A user that has access to the the resources of an organization.
type listIssuesIssuesIssueConnectionNodesIssueCreatorUser struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// Whether the user account is active or disabled (suspended).
	Active *bool `json:"active"`
	// Whether the user is an organization administrator.
	Admin *bool `json:"admin"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// An URL to the user's avatar image.
	AvatarUrl *string `json:"avatarUrl"`
	// [DEPRECATED] Hash for the user to be used in calendar URLs.
	CalendarHash *string `json:"calendarHash"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Number of issues created.
	CreatedIssueCount *int `json:"createdIssueCount"`
	// A short description of the user, either its title or bio.
	Description *string `json:"description"`
	// Reason why is the account disabled.
	DisableReason *string `json:"disableReason"`
	// The user's display (nick) name. Unique within each organization.
	DisplayName *string `json:"displayName"`
	// The user's email address.
	Email *string `json:"email"`
	// Whether the user is a guest in the workspace and limited to accessing a subset of teams.
	Guest *bool `json:"guest"`
	// Unique hash for the user to be used in invite URLs.
	InviteHash *string `json:"inviteHash"`
	// Whether the user is the currently authenticated user.
	IsMe *bool `json:"isMe"`
	// The last time the user was seen online. If null, the user is currently online.
	LastSeen *time.Time `json:"-"`
	// The user's full name.
	Name *string `json:"name"`
	// The emoji to represent the user current status.
	StatusEmoji *string `json:"statusEmoji"`
	// The label of the user current status.
	StatusLabel *string `json:"statusLabel"`
	// A date at which the user current status should be cleared.
	StatusUntilAt *time.Time `json:"-"`
	// The local timezone of the user.
	Timezone *string `json:"timezone"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// User's profile URL.
	Url *string `json:"url"`
}

// GetId returns listIssuesIssuesIssueConnectionNodesIssueCreatorUser.Id, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCreatorUser) GetId() *string { return v.Id }

// GetActive returns listIssuesIssuesIssueConnectionNodesIssueCreatorUser.Active, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCreatorUser) GetActive() *bool { return v.Active }

// GetAdmin returns listIssuesIssuesIssueConnectionNodesIssueCreatorUser.Admin, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCreatorUser) GetAdmin() *bool { return v.Admin }

// GetArchivedAt returns listIssuesIssuesIssueConnectionNodesIssueCreatorUser.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCreatorUser) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetAvatarUrl returns listIssuesIssuesIssueConnectionNodesIssueCreatorUser.AvatarUrl, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCreatorUser) GetAvatarUrl() *string {
	return v.AvatarUrl
}

// GetCalendarHash returns listIssuesIssuesIssueConnectionNodesIssueCreatorUser.CalendarHash, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCreatorUser) GetCalendarHash() *string {
	return v.CalendarHash
}

// GetCreatedAt returns listIssuesIssuesIssueConnectionNodesIssueCreatorUser.CreatedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCreatorUser) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetCreatedIssueCount returns listIssuesIssuesIssueConnectionNodesIssueCreatorUser.CreatedIssueCount, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCreatorUser) GetCreatedIssueCount() *int {
	return v.CreatedIssueCount
}

// GetDescription returns listIssuesIssuesIssueConnectionNodesIssueCreatorUser.Description, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCreatorUser) GetDescription() *string {
	return v.Description
}

// GetDisableReason returns listIssuesIssuesIssueConnectionNodesIssueCreatorUser.DisableReason, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCreatorUser) GetDisableReason() *string {
	return v.DisableReason
}

// GetDisplayName returns listIssuesIssuesIssueConnectionNodesIssueCreatorUser.DisplayName, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCreatorUser) GetDisplayName() *string {
	return v.DisplayName
}

// GetEmail returns listIssuesIssuesIssueConnectionNodesIssueCreatorUser.Email, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCreatorUser) GetEmail() *string { return v.Email }

// GetGuest returns listIssuesIssuesIssueConnectionNodesIssueCreatorUser.Guest, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCreatorUser) GetGuest() *bool { return v.Guest }

// GetInviteHash returns listIssuesIssuesIssueConnectionNodesIssueCreatorUser.InviteHash, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCreatorUser) GetInviteHash() *string {
	return v.InviteHash
}

// GetIsMe returns listIssuesIssuesIssueConnectionNodesIssueCreatorUser.IsMe, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCreatorUser) GetIsMe() *bool { return v.IsMe }

// GetLastSeen returns listIssuesIssuesIssueConnectionNodesIssueCreatorUser.LastSeen, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCreatorUser) GetLastSeen() *time.Time {
	return v.LastSeen
}

// GetName returns listIssuesIssuesIssueConnectionNodesIssueCreatorUser.Name, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCreatorUser) GetName() *string { return v.Name }

// GetStatusEmoji returns listIssuesIssuesIssueConnectionNodesIssueCreatorUser.StatusEmoji, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCreatorUser) GetStatusEmoji() *string {
	return v.StatusEmoji
}

// GetStatusLabel returns listIssuesIssuesIssueConnectionNodesIssueCreatorUser.StatusLabel, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCreatorUser) GetStatusLabel() *string {
	return v.StatusLabel
}

// GetStatusUntilAt returns listIssuesIssuesIssueConnectionNodesIssueCreatorUser.StatusUntilAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCreatorUser) GetStatusUntilAt() *time.Time {
	return v.StatusUntilAt
}

// GetTimezone returns listIssuesIssuesIssueConnectionNodesIssueCreatorUser.Timezone, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCreatorUser) GetTimezone() *string {
	return v.Timezone
}

// GetUpdatedAt returns listIssuesIssuesIssueConnectionNodesIssueCreatorUser.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCreatorUser) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

// GetUrl returns listIssuesIssuesIssueConnectionNodesIssueCreatorUser.Url, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCreatorUser) GetUrl() *string { return v.Url }

func (v *listIssuesIssuesIssueConnectionNodesIssueCreatorUser) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listIssuesIssuesIssueConnectionNodesIssueCreatorUser
		ArchivedAt    json.RawMessage `json:"archivedAt"`
		CreatedAt     json.RawMessage `json:"createdAt"`
		LastSeen      json.RawMessage `json:"lastSeen"`
		StatusUntilAt json.RawMessage `json:"statusUntilAt"`
		UpdatedAt     json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listIssuesIssuesIssueConnectionNodesIssueCreatorUser = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueCreatorUser.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueCreatorUser.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.LastSeen
		src := firstPass.LastSeen
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueCreatorUser.LastSeen: %w", err)
			}
		}
	}

	{
		dst := &v.StatusUntilAt
		src := firstPass.StatusUntilAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueCreatorUser.StatusUntilAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueCreatorUser.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistIssuesIssuesIssueConnectionNodesIssueCreatorUser struct {
	Id *string `json:"id"`

	Active *bool `json:"active"`

	Admin *bool `json:"admin"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AvatarUrl *string `json:"avatarUrl"`

	CalendarHash *string `json:"calendarHash"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CreatedIssueCount *int `json:"createdIssueCount"`

	Description *string `json:"description"`

	DisableReason *string `json:"disableReason"`

	DisplayName *string `json:"displayName"`

	Email *string `json:"email"`

	Guest *bool `json:"guest"`

	InviteHash *string `json:"inviteHash"`

	IsMe *bool `json:"isMe"`

	LastSeen json.RawMessage `json:"lastSeen"`

	Name *string `json:"name"`

	StatusEmoji *string `json:"statusEmoji"`

	StatusLabel *string `json:"statusLabel"`

	StatusUntilAt json.RawMessage `json:"statusUntilAt"`

	Timezone *string `json:"timezone"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	Url *string `json:"url"`
}

func (v *listIssuesIssuesIssueConnectionNodesIssueCreatorUser) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listIssuesIssuesIssueConnectionNodesIssueCreatorUser) __premarshalJSON() (*__premarshallistIssuesIssuesIssueConnectionNodesIssueCreatorUser, error) {
	var retval __premarshallistIssuesIssuesIssueConnectionNodesIssueCreatorUser

	retval.Id = v.Id
	retval.Active = v.Active
	retval.Admin = v.Admin
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueCreatorUser.ArchivedAt: %w", err)
			}
		}
	}
	retval.AvatarUrl = v.AvatarUrl
	retval.CalendarHash = v.CalendarHash
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueCreatorUser.CreatedAt: %w", err)
			}
		}
	}
	retval.CreatedIssueCount = v.CreatedIssueCount
	retval.Description = v.Description
	retval.DisableReason = v.DisableReason
	retval.DisplayName = v.DisplayName
	retval.Email = v.Email
	retval.Guest = v.Guest
	retval.InviteHash = v.InviteHash
	retval.IsMe = v.IsMe
	{

		dst := &retval.LastSeen
		src := v.LastSeen
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueCreatorUser.LastSeen: %w", err)
			}
		}
	}
	retval.Name = v.Name
	retval.StatusEmoji = v.StatusEmoji
	retval.StatusLabel = v.StatusLabel
	{

		dst := &retval.StatusUntilAt
		src := v.StatusUntilAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueCreatorUser.StatusUntilAt: %w", err)
			}
		}
	}
	retval.Timezone = v.Timezone
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueCreatorUser.UpdatedAt: %w", err)
			}
		}
	}
	retval.Url = v.Url
	return &retval, nil
}

// listIssuesIssuesIssueConnectionNodesIssueCycle includes the requested fields of the GraphQL type Cycle.
// The GraphQL type's documentation follows.
//
// A set of issues to be resolved in a specified amount of time.
type listIssuesIssuesIssueConnectionNodesIssueCycle struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The time at which the cycle was automatically archived by the auto pruning process.
	AutoArchivedAt *time.Time `json:"-"`
	// The completion time of the cycle. If null, the cycle hasn't been completed.
	CompletedAt *time.Time `json:"-"`
	// The number of completed issues in the cycle after each day.
	CompletedIssueCountHistory []*float64 `json:"completedIssueCountHistory"`
	// The number of completed estimation points after each day.
	CompletedScopeHistory []*float64 `json:"completedScopeHistory"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// The cycle's description.
	Description *string `json:"description"`
	// The end time of the cycle.
	EndsAt *time.Time `json:"-"`
	// The number of in progress estimation points after each day.
	InProgressScopeHistory []*float64 `json:"inProgressScopeHistory"`
	// The total number of issues in the cycle after each day.
	IssueCountHistory []*float64 `json:"issueCountHistory"`
	// The custom name of the cycle.
	Name *string `json:"name"`
	// The number of the cycle.
	Number *float64 `json:"number"`
	// The overall progress of the cycle. This is the (completed estimate points + 0.25 * in progress estimate points) / total estimate points.
	Progress *float64 `json:"progress"`
	// The total number of estimation points after each day.
	ScopeHistory []*float64 `json:"scopeHistory"`
	// The start time of the cycle.
	StartsAt *time.Time `json:"-"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
}

// GetId returns listIssuesIssuesIssueConnectionNodesIssueCycle.Id, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCycle) GetId() *string { return v.Id }

// GetArchivedAt returns listIssuesIssuesIssueConnectionNodesIssueCycle.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCycle) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetAutoArchivedAt returns listIssuesIssuesIssueConnectionNodesIssueCycle.AutoArchivedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCycle) GetAutoArchivedAt() *time.Time {
	return v.AutoArchivedAt
}

// GetCompletedAt returns listIssuesIssuesIssueConnectionNodesIssueCycle.CompletedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCycle) GetCompletedAt() *time.Time {
	return v.CompletedAt
}

// GetCompletedIssueCountHistory returns listIssuesIssuesIssueConnectionNodesIssueCycle.CompletedIssueCountHistory, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCycle) GetCompletedIssueCountHistory() []*float64 {
	return v.CompletedIssueCountHistory
}

// GetCompletedScopeHistory returns listIssuesIssuesIssueConnectionNodesIssueCycle.CompletedScopeHistory, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCycle) GetCompletedScopeHistory() []*float64 {
	return v.CompletedScopeHistory
}

// GetCreatedAt returns listIssuesIssuesIssueConnectionNodesIssueCycle.CreatedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCycle) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetDescription returns listIssuesIssuesIssueConnectionNodesIssueCycle.Description, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCycle) GetDescription() *string {
	return v.Description
}

// GetEndsAt returns listIssuesIssuesIssueConnectionNodesIssueCycle.EndsAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCycle) GetEndsAt() *time.Time { return v.EndsAt }

// GetInProgressScopeHistory returns listIssuesIssuesIssueConnectionNodesIssueCycle.InProgressScopeHistory, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCycle) GetInProgressScopeHistory() []*float64 {
	return v.InProgressScopeHistory
}

// GetIssueCountHistory returns listIssuesIssuesIssueConnectionNodesIssueCycle.IssueCountHistory, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCycle) GetIssueCountHistory() []*float64 {
	return v.IssueCountHistory
}

// GetName returns listIssuesIssuesIssueConnectionNodesIssueCycle.Name, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCycle) GetName() *string { return v.Name }

// GetNumber returns listIssuesIssuesIssueConnectionNodesIssueCycle.Number, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCycle) GetNumber() *float64 { return v.Number }

// GetProgress returns listIssuesIssuesIssueConnectionNodesIssueCycle.Progress, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCycle) GetProgress() *float64 { return v.Progress }

// GetScopeHistory returns listIssuesIssuesIssueConnectionNodesIssueCycle.ScopeHistory, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCycle) GetScopeHistory() []*float64 {
	return v.ScopeHistory
}

// GetStartsAt returns listIssuesIssuesIssueConnectionNodesIssueCycle.StartsAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCycle) GetStartsAt() *time.Time { return v.StartsAt }

// GetUpdatedAt returns listIssuesIssuesIssueConnectionNodesIssueCycle.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueCycle) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

func (v *listIssuesIssuesIssueConnectionNodesIssueCycle) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listIssuesIssuesIssueConnectionNodesIssueCycle
		ArchivedAt     json.RawMessage `json:"archivedAt"`
		AutoArchivedAt json.RawMessage `json:"autoArchivedAt"`
		CompletedAt    json.RawMessage `json:"completedAt"`
		CreatedAt      json.RawMessage `json:"createdAt"`
		EndsAt         json.RawMessage `json:"endsAt"`
		StartsAt       json.RawMessage `json:"startsAt"`
		UpdatedAt      json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listIssuesIssuesIssueConnectionNodesIssueCycle = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueCycle.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.AutoArchivedAt
		src := firstPass.AutoArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueCycle.AutoArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CompletedAt
		src := firstPass.CompletedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueCycle.CompletedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueCycle.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.EndsAt
		src := firstPass.EndsAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueCycle.EndsAt: %w", err)
			}
		}
	}

	{
		dst := &v.StartsAt
		src := firstPass.StartsAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueCycle.StartsAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueCycle.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistIssuesIssuesIssueConnectionNodesIssueCycle struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AutoArchivedAt json.RawMessage `json:"autoArchivedAt"`

	CompletedAt json.RawMessage `json:"completedAt"`

	CompletedIssueCountHistory []*float64 `json:"completedIssueCountHistory"`

	CompletedScopeHistory []*float64 `json:"completedScopeHistory"`

	CreatedAt json.RawMessage `json:"createdAt"`

	Description *string `json:"description"`

	EndsAt json.RawMessage `json:"endsAt"`

	InProgressScopeHistory []*float64 `json:"inProgressScopeHistory"`

	IssueCountHistory []*float64 `json:"issueCountHistory"`

	Name *string `json:"name"`

	Number *float64 `json:"number"`

	Progress *float64 `json:"progress"`

	ScopeHistory []*float64 `json:"scopeHistory"`

	StartsAt json.RawMessage `json:"startsAt"`

	UpdatedAt json.RawMessage `json:"updatedAt"`
}

func (v *listIssuesIssuesIssueConnectionNodesIssueCycle) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listIssuesIssuesIssueConnectionNodesIssueCycle) __premarshalJSON() (*__premarshallistIssuesIssuesIssueConnectionNodesIssueCycle, error) {
	var retval __premarshallistIssuesIssuesIssueConnectionNodesIssueCycle

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueCycle.ArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.AutoArchivedAt
		src := v.AutoArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueCycle.AutoArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CompletedAt
		src := v.CompletedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueCycle.CompletedAt: %w", err)
			}
		}
	}
	retval.CompletedIssueCountHistory = v.CompletedIssueCountHistory
	retval.CompletedScopeHistory = v.CompletedScopeHistory
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueCycle.CreatedAt: %w", err)
			}
		}
	}
	retval.Description = v.Description
	{

		dst := &retval.EndsAt
		src := v.EndsAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueCycle.EndsAt: %w", err)
			}
		}
	}
	retval.InProgressScopeHistory = v.InProgressScopeHistory
	retval.IssueCountHistory = v.IssueCountHistory
	retval.Name = v.Name
	retval.Number = v.Number
	retval.Progress = v.Progress
	retval.ScopeHistory = v.ScopeHistory
	{

		dst := &retval.StartsAt
		src := v.StartsAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueCycle.StartsAt: %w", err)
			}
		}
	}
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueCycle.UpdatedAt: %w", err)
			}
		}
	}
	return &retval, nil
}

// listIssuesIssuesIssueConnectionNodesIssueParentIssue includes the requested fields of the GraphQL type Issue.
// The GraphQL type's documentation follows.
//
// An issue.
type listIssuesIssuesIssueConnectionNodesIssueParentIssue struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The issue's unique number.
	Number *float64 `json:"number"`
	// The issue's title.
	Title *string `json:"title"`
	// The issue's description in markdown format.
	Description *string `json:"description"`
	// The priority of the issue. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low.
	Priority *float64 `json:"priority"`
	// The estimate of the complexity of the issue..
	Estimate *float64 `json:"estimate"`
	// The order of the item in relation to other items in the organization.
	SortOrder *float64 `json:"sortOrder"`
	// The time at which the issue was moved into started state.
	StartedAt *time.Time `json:"-"`
	// The time at which the issue was moved into completed state.
	CompletedAt *time.Time `json:"-"`
	// The time at which the issue was moved into canceled state.
	CanceledAt *time.Time `json:"-"`
	// The time at which the issue was automatically closed by the auto pruning process.
	AutoClosedAt *time.Time `json:"-"`
	// The time at which the issue was automatically archived by the auto pruning process.
	AutoArchivedAt *time.Time `json:"-"`
	// The date at which the issue is due.
	DueDate *time.Time `json:"-"`
	// A flag that indicates whether the issue is in the trash bin.
	Trashed *bool `json:"trashed"`
	// The time until an issue will be snoozed in Triage view.
	SnoozedUntilAt *time.Time `json:"-"`
	// Previous identifiers of the issue if it has been moved between teams.
	PreviousIdentifiers []*string `json:"previousIdentifiers"`
}

// GetId returns listIssuesIssuesIssueConnectionNodesIssueParentIssue.Id, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueParentIssue) GetId() *string { return v.Id }

// GetCreatedAt returns listIssuesIssuesIssueConnectionNodesIssueParentIssue.CreatedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueParentIssue) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetUpdatedAt returns listIssuesIssuesIssueConnectionNodesIssueParentIssue.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueParentIssue) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

// GetArchivedAt returns listIssuesIssuesIssueConnectionNodesIssueParentIssue.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueParentIssue) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetNumber returns listIssuesIssuesIssueConnectionNodesIssueParentIssue.Number, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueParentIssue) GetNumber() *float64 { return v.Number }

// GetTitle returns listIssuesIssuesIssueConnectionNodesIssueParentIssue.Title, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueParentIssue) GetTitle() *string { return v.Title }

// GetDescription returns listIssuesIssuesIssueConnectionNodesIssueParentIssue.Description, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueParentIssue) GetDescription() *string {
	return v.Description
}

// GetPriority returns listIssuesIssuesIssueConnectionNodesIssueParentIssue.Priority, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueParentIssue) GetPriority() *float64 {
	return v.Priority
}

// GetEstimate returns listIssuesIssuesIssueConnectionNodesIssueParentIssue.Estimate, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueParentIssue) GetEstimate() *float64 {
	return v.Estimate
}

// GetSortOrder returns listIssuesIssuesIssueConnectionNodesIssueParentIssue.SortOrder, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueParentIssue) GetSortOrder() *float64 {
	return v.SortOrder
}

// GetStartedAt returns listIssuesIssuesIssueConnectionNodesIssueParentIssue.StartedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueParentIssue) GetStartedAt() *time.Time {
	return v.StartedAt
}

// GetCompletedAt returns listIssuesIssuesIssueConnectionNodesIssueParentIssue.CompletedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueParentIssue) GetCompletedAt() *time.Time {
	return v.CompletedAt
}

// GetCanceledAt returns listIssuesIssuesIssueConnectionNodesIssueParentIssue.CanceledAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueParentIssue) GetCanceledAt() *time.Time {
	return v.CanceledAt
}

// GetAutoClosedAt returns listIssuesIssuesIssueConnectionNodesIssueParentIssue.AutoClosedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueParentIssue) GetAutoClosedAt() *time.Time {
	return v.AutoClosedAt
}

// GetAutoArchivedAt returns listIssuesIssuesIssueConnectionNodesIssueParentIssue.AutoArchivedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueParentIssue) GetAutoArchivedAt() *time.Time {
	return v.AutoArchivedAt
}

// GetDueDate returns listIssuesIssuesIssueConnectionNodesIssueParentIssue.DueDate, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueParentIssue) GetDueDate() *time.Time {
	return v.DueDate
}

// GetTrashed returns listIssuesIssuesIssueConnectionNodesIssueParentIssue.Trashed, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueParentIssue) GetTrashed() *bool { return v.Trashed }

// GetSnoozedUntilAt returns listIssuesIssuesIssueConnectionNodesIssueParentIssue.SnoozedUntilAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueParentIssue) GetSnoozedUntilAt() *time.Time {
	return v.SnoozedUntilAt
}

// GetPreviousIdentifiers returns listIssuesIssuesIssueConnectionNodesIssueParentIssue.PreviousIdentifiers, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueParentIssue) GetPreviousIdentifiers() []*string {
	return v.PreviousIdentifiers
}

func (v *listIssuesIssuesIssueConnectionNodesIssueParentIssue) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listIssuesIssuesIssueConnectionNodesIssueParentIssue
		CreatedAt      json.RawMessage `json:"createdAt"`
		UpdatedAt      json.RawMessage `json:"updatedAt"`
		ArchivedAt     json.RawMessage `json:"archivedAt"`
		StartedAt      json.RawMessage `json:"startedAt"`
		CompletedAt    json.RawMessage `json:"completedAt"`
		CanceledAt     json.RawMessage `json:"canceledAt"`
		AutoClosedAt   json.RawMessage `json:"autoClosedAt"`
		AutoArchivedAt json.RawMessage `json:"autoArchivedAt"`
		DueDate        json.RawMessage `json:"dueDate"`
		SnoozedUntilAt json.RawMessage `json:"snoozedUntilAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listIssuesIssuesIssueConnectionNodesIssueParentIssue = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueParentIssue.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueParentIssue.UpdatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueParentIssue.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.StartedAt
		src := firstPass.StartedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueParentIssue.StartedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CompletedAt
		src := firstPass.CompletedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueParentIssue.CompletedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CanceledAt
		src := firstPass.CanceledAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueParentIssue.CanceledAt: %w", err)
			}
		}
	}

	{
		dst := &v.AutoClosedAt
		src := firstPass.AutoClosedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueParentIssue.AutoClosedAt: %w", err)
			}
		}
	}

	{
		dst := &v.AutoArchivedAt
		src := firstPass.AutoArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueParentIssue.AutoArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.DueDate
		src := firstPass.DueDate
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueParentIssue.DueDate: %w", err)
			}
		}
	}

	{
		dst := &v.SnoozedUntilAt
		src := firstPass.SnoozedUntilAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueParentIssue.SnoozedUntilAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistIssuesIssuesIssueConnectionNodesIssueParentIssue struct {
	Id *string `json:"id"`

	CreatedAt json.RawMessage `json:"createdAt"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	Number *float64 `json:"number"`

	Title *string `json:"title"`

	Description *string `json:"description"`

	Priority *float64 `json:"priority"`

	Estimate *float64 `json:"estimate"`

	SortOrder *float64 `json:"sortOrder"`

	StartedAt json.RawMessage `json:"startedAt"`

	CompletedAt json.RawMessage `json:"completedAt"`

	CanceledAt json.RawMessage `json:"canceledAt"`

	AutoClosedAt json.RawMessage `json:"autoClosedAt"`

	AutoArchivedAt json.RawMessage `json:"autoArchivedAt"`

	DueDate json.RawMessage `json:"dueDate"`

	Trashed *bool `json:"trashed"`

	SnoozedUntilAt json.RawMessage `json:"snoozedUntilAt"`

	PreviousIdentifiers []*string `json:"previousIdentifiers"`
}

func (v *listIssuesIssuesIssueConnectionNodesIssueParentIssue) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listIssuesIssuesIssueConnectionNodesIssueParentIssue) __premarshalJSON() (*__premarshallistIssuesIssuesIssueConnectionNodesIssueParentIssue, error) {
	var retval __premarshallistIssuesIssuesIssueConnectionNodesIssueParentIssue

	retval.Id = v.Id
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueParentIssue.CreatedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueParentIssue.UpdatedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueParentIssue.ArchivedAt: %w", err)
			}
		}
	}
	retval.Number = v.Number
	retval.Title = v.Title
	retval.Description = v.Description
	retval.Priority = v.Priority
	retval.Estimate = v.Estimate
	retval.SortOrder = v.SortOrder
	{

		dst := &retval.StartedAt
		src := v.StartedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueParentIssue.StartedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CompletedAt
		src := v.CompletedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueParentIssue.CompletedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CanceledAt
		src := v.CanceledAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueParentIssue.CanceledAt: %w", err)
			}
		}
	}
	{

		dst := &retval.AutoClosedAt
		src := v.AutoClosedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueParentIssue.AutoClosedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.AutoArchivedAt
		src := v.AutoArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueParentIssue.AutoArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.DueDate
		src := v.DueDate
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueParentIssue.DueDate: %w", err)
			}
		}
	}
	retval.Trashed = v.Trashed
	{

		dst := &retval.SnoozedUntilAt
		src := v.SnoozedUntilAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueParentIssue.SnoozedUntilAt: %w", err)
			}
		}
	}
	retval.PreviousIdentifiers = v.PreviousIdentifiers
	return &retval, nil
}

// listIssuesIssuesIssueConnectionNodesIssueProject includes the requested fields of the GraphQL type Project.
// The GraphQL type's documentation follows.
//
// A project.
type listIssuesIssuesIssueConnectionNodesIssueProject struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The time at which the project was automatically archived by the auto pruning process.
	AutoArchivedAt *time.Time `json:"-"`
	// The time at which the project was moved into canceled state.
	CanceledAt *time.Time `json:"-"`
	// The project's color.
	Color *string `json:"color"`
	// The time at which the project was moved into completed state.
	CompletedAt *time.Time `json:"-"`
	// The number of completed issues in the project after each week.
	CompletedIssueCountHistory []*float64 `json:"completedIssueCountHistory"`
	// The number of completed estimation points after each week.
	CompletedScopeHistory []*float64 `json:"completedScopeHistory"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// The project's description.
	Description *string `json:"description"`
	// The icon of the project.
	Icon *string `json:"icon"`
	// The number of in progress estimation points after each week.
	InProgressScopeHistory []*float64 `json:"inProgressScopeHistory"`
	// The total number of issues in the project after each week.
	IssueCountHistory []*float64 `json:"issueCountHistory"`
	// The project's name.
	Name *string `json:"name"`
	// The overall progress of the project. This is the (completed estimate points + 0.25 * in progress estimate points) / total estimate points.
	Progress *float64 `json:"progress"`
	// The time until which project update reminders are paused.
	ProjectUpdateRemindersPausedUntilAt *time.Time `json:"-"`
	// The overall scope (total estimate points) of the project.
	Scope *float64 `json:"scope"`
	// The total number of estimation points after each week.
	ScopeHistory []*float64 `json:"scopeHistory"`
	// Whether to send new issue comment notifications to Slack.
	SlackIssueComments *bool `json:"slackIssueComments"`
	// Whether to send new issue status updates to Slack.
	SlackIssueStatuses *bool `json:"slackIssueStatuses"`
	// Whether to send new issue notifications to Slack.
	SlackNewIssue *bool `json:"slackNewIssue"`
	// The project's unique URL slug.
	SlugId *string `json:"slugId"`
	// The sort order for the project within the organization.
	SortOrder *float64 `json:"sortOrder"`
	// [Internal] The estimated start date of the project.
	StartDate *time.Time `json:"-"`
	// The time at which the project was moved into started state.
	StartedAt *time.Time `json:"-"`
	// The type of the state.
	State *string `json:"state"`
	// The estimated completion date of the project.
	TargetDate *time.Time `json:"-"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// Project URL.
	Url *string `json:"url"`
}

// GetId returns listIssuesIssuesIssueConnectionNodesIssueProject.Id, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueProject) GetId() *string { return v.Id }

// GetArchivedAt returns listIssuesIssuesIssueConnectionNodesIssueProject.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueProject) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetAutoArchivedAt returns listIssuesIssuesIssueConnectionNodesIssueProject.AutoArchivedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueProject) GetAutoArchivedAt() *time.Time {
	return v.AutoArchivedAt
}

// GetCanceledAt returns listIssuesIssuesIssueConnectionNodesIssueProject.CanceledAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueProject) GetCanceledAt() *time.Time {
	return v.CanceledAt
}

// GetColor returns listIssuesIssuesIssueConnectionNodesIssueProject.Color, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueProject) GetColor() *string { return v.Color }

// GetCompletedAt returns listIssuesIssuesIssueConnectionNodesIssueProject.CompletedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueProject) GetCompletedAt() *time.Time {
	return v.CompletedAt
}

// GetCompletedIssueCountHistory returns listIssuesIssuesIssueConnectionNodesIssueProject.CompletedIssueCountHistory, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueProject) GetCompletedIssueCountHistory() []*float64 {
	return v.CompletedIssueCountHistory
}

// GetCompletedScopeHistory returns listIssuesIssuesIssueConnectionNodesIssueProject.CompletedScopeHistory, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueProject) GetCompletedScopeHistory() []*float64 {
	return v.CompletedScopeHistory
}

// GetCreatedAt returns listIssuesIssuesIssueConnectionNodesIssueProject.CreatedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueProject) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetDescription returns listIssuesIssuesIssueConnectionNodesIssueProject.Description, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueProject) GetDescription() *string {
	return v.Description
}

// GetIcon returns listIssuesIssuesIssueConnectionNodesIssueProject.Icon, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueProject) GetIcon() *string { return v.Icon }

// GetInProgressScopeHistory returns listIssuesIssuesIssueConnectionNodesIssueProject.InProgressScopeHistory, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueProject) GetInProgressScopeHistory() []*float64 {
	return v.InProgressScopeHistory
}

// GetIssueCountHistory returns listIssuesIssuesIssueConnectionNodesIssueProject.IssueCountHistory, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueProject) GetIssueCountHistory() []*float64 {
	return v.IssueCountHistory
}

// GetName returns listIssuesIssuesIssueConnectionNodesIssueProject.Name, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueProject) GetName() *string { return v.Name }

// GetProgress returns listIssuesIssuesIssueConnectionNodesIssueProject.Progress, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueProject) GetProgress() *float64 { return v.Progress }

// GetProjectUpdateRemindersPausedUntilAt returns listIssuesIssuesIssueConnectionNodesIssueProject.ProjectUpdateRemindersPausedUntilAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueProject) GetProjectUpdateRemindersPausedUntilAt() *time.Time {
	return v.ProjectUpdateRemindersPausedUntilAt
}

// GetScope returns listIssuesIssuesIssueConnectionNodesIssueProject.Scope, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueProject) GetScope() *float64 { return v.Scope }

// GetScopeHistory returns listIssuesIssuesIssueConnectionNodesIssueProject.ScopeHistory, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueProject) GetScopeHistory() []*float64 {
	return v.ScopeHistory
}

// GetSlackIssueComments returns listIssuesIssuesIssueConnectionNodesIssueProject.SlackIssueComments, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueProject) GetSlackIssueComments() *bool {
	return v.SlackIssueComments
}

// GetSlackIssueStatuses returns listIssuesIssuesIssueConnectionNodesIssueProject.SlackIssueStatuses, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueProject) GetSlackIssueStatuses() *bool {
	return v.SlackIssueStatuses
}

// GetSlackNewIssue returns listIssuesIssuesIssueConnectionNodesIssueProject.SlackNewIssue, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueProject) GetSlackNewIssue() *bool {
	return v.SlackNewIssue
}

// GetSlugId returns listIssuesIssuesIssueConnectionNodesIssueProject.SlugId, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueProject) GetSlugId() *string { return v.SlugId }

// GetSortOrder returns listIssuesIssuesIssueConnectionNodesIssueProject.SortOrder, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueProject) GetSortOrder() *float64 {
	return v.SortOrder
}

// GetStartDate returns listIssuesIssuesIssueConnectionNodesIssueProject.StartDate, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueProject) GetStartDate() *time.Time {
	return v.StartDate
}

// GetStartedAt returns listIssuesIssuesIssueConnectionNodesIssueProject.StartedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueProject) GetStartedAt() *time.Time {
	return v.StartedAt
}

// GetState returns listIssuesIssuesIssueConnectionNodesIssueProject.State, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueProject) GetState() *string { return v.State }

// GetTargetDate returns listIssuesIssuesIssueConnectionNodesIssueProject.TargetDate, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueProject) GetTargetDate() *time.Time {
	return v.TargetDate
}

// GetUpdatedAt returns listIssuesIssuesIssueConnectionNodesIssueProject.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueProject) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

// GetUrl returns listIssuesIssuesIssueConnectionNodesIssueProject.Url, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueProject) GetUrl() *string { return v.Url }

func (v *listIssuesIssuesIssueConnectionNodesIssueProject) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listIssuesIssuesIssueConnectionNodesIssueProject
		ArchivedAt                          json.RawMessage `json:"archivedAt"`
		AutoArchivedAt                      json.RawMessage `json:"autoArchivedAt"`
		CanceledAt                          json.RawMessage `json:"canceledAt"`
		CompletedAt                         json.RawMessage `json:"completedAt"`
		CreatedAt                           json.RawMessage `json:"createdAt"`
		ProjectUpdateRemindersPausedUntilAt json.RawMessage `json:"projectUpdateRemindersPausedUntilAt"`
		StartDate                           json.RawMessage `json:"startDate"`
		StartedAt                           json.RawMessage `json:"startedAt"`
		TargetDate                          json.RawMessage `json:"targetDate"`
		UpdatedAt                           json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listIssuesIssuesIssueConnectionNodesIssueProject = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueProject.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.AutoArchivedAt
		src := firstPass.AutoArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueProject.AutoArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CanceledAt
		src := firstPass.CanceledAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueProject.CanceledAt: %w", err)
			}
		}
	}

	{
		dst := &v.CompletedAt
		src := firstPass.CompletedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueProject.CompletedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueProject.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.ProjectUpdateRemindersPausedUntilAt
		src := firstPass.ProjectUpdateRemindersPausedUntilAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueProject.ProjectUpdateRemindersPausedUntilAt: %w", err)
			}
		}
	}

	{
		dst := &v.StartDate
		src := firstPass.StartDate
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueProject.StartDate: %w", err)
			}
		}
	}

	{
		dst := &v.StartedAt
		src := firstPass.StartedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueProject.StartedAt: %w", err)
			}
		}
	}

	{
		dst := &v.TargetDate
		src := firstPass.TargetDate
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueProject.TargetDate: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueProject.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistIssuesIssuesIssueConnectionNodesIssueProject struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AutoArchivedAt json.RawMessage `json:"autoArchivedAt"`

	CanceledAt json.RawMessage `json:"canceledAt"`

	Color *string `json:"color"`

	CompletedAt json.RawMessage `json:"completedAt"`

	CompletedIssueCountHistory []*float64 `json:"completedIssueCountHistory"`

	CompletedScopeHistory []*float64 `json:"completedScopeHistory"`

	CreatedAt json.RawMessage `json:"createdAt"`

	Description *string `json:"description"`

	Icon *string `json:"icon"`

	InProgressScopeHistory []*float64 `json:"inProgressScopeHistory"`

	IssueCountHistory []*float64 `json:"issueCountHistory"`

	Name *string `json:"name"`

	Progress *float64 `json:"progress"`

	ProjectUpdateRemindersPausedUntilAt json.RawMessage `json:"projectUpdateRemindersPausedUntilAt"`

	Scope *float64 `json:"scope"`

	ScopeHistory []*float64 `json:"scopeHistory"`

	SlackIssueComments *bool `json:"slackIssueComments"`

	SlackIssueStatuses *bool `json:"slackIssueStatuses"`

	SlackNewIssue *bool `json:"slackNewIssue"`

	SlugId *string `json:"slugId"`

	SortOrder *float64 `json:"sortOrder"`

	StartDate json.RawMessage `json:"startDate"`

	StartedAt json.RawMessage `json:"startedAt"`

	State *string `json:"state"`

	TargetDate json.RawMessage `json:"targetDate"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	Url *string `json:"url"`
}

func (v *listIssuesIssuesIssueConnectionNodesIssueProject) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listIssuesIssuesIssueConnectionNodesIssueProject) __premarshalJSON() (*__premarshallistIssuesIssuesIssueConnectionNodesIssueProject, error) {
	var retval __premarshallistIssuesIssuesIssueConnectionNodesIssueProject

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueProject.ArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.AutoArchivedAt
		src := v.AutoArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueProject.AutoArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CanceledAt
		src := v.CanceledAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueProject.CanceledAt: %w", err)
			}
		}
	}
	retval.Color = v.Color
	{

		dst := &retval.CompletedAt
		src := v.CompletedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueProject.CompletedAt: %w", err)
			}
		}
	}
	retval.CompletedIssueCountHistory = v.CompletedIssueCountHistory
	retval.CompletedScopeHistory = v.CompletedScopeHistory
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueProject.CreatedAt: %w", err)
			}
		}
	}
	retval.Description = v.Description
	retval.Icon = v.Icon
	retval.InProgressScopeHistory = v.InProgressScopeHistory
	retval.IssueCountHistory = v.IssueCountHistory
	retval.Name = v.Name
	retval.Progress = v.Progress
	{

		dst := &retval.ProjectUpdateRemindersPausedUntilAt
		src := v.ProjectUpdateRemindersPausedUntilAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueProject.ProjectUpdateRemindersPausedUntilAt: %w", err)
			}
		}
	}
	retval.Scope = v.Scope
	retval.ScopeHistory = v.ScopeHistory
	retval.SlackIssueComments = v.SlackIssueComments
	retval.SlackIssueStatuses = v.SlackIssueStatuses
	retval.SlackNewIssue = v.SlackNewIssue
	retval.SlugId = v.SlugId
	retval.SortOrder = v.SortOrder
	{

		dst := &retval.StartDate
		src := v.StartDate
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueProject.StartDate: %w", err)
			}
		}
	}
	{

		dst := &retval.StartedAt
		src := v.StartedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueProject.StartedAt: %w", err)
			}
		}
	}
	retval.State = v.State
	{

		dst := &retval.TargetDate
		src := v.TargetDate
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueProject.TargetDate: %w", err)
			}
		}
	}
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueProject.UpdatedAt: %w", err)
			}
		}
	}
	retval.Url = v.Url
	return &retval, nil
}

// listIssuesIssuesIssueConnectionNodesIssueProjectMilestone includes the requested fields of the GraphQL type ProjectMilestone.
// The GraphQL type's documentation follows.
//
// A milestone for a project.
type listIssuesIssuesIssueConnectionNodesIssueProjectMilestone struct {
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// The description of the project milestone.
	Description *string `json:"description"`
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The name of the project milestone.
	Name *string `json:"name"`
	// The order of the milestone in relation to other milestones within a project.
	SortOrder *float64 `json:"sortOrder"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
}

// GetArchivedAt returns listIssuesIssuesIssueConnectionNodesIssueProjectMilestone.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueProjectMilestone) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetCreatedAt returns listIssuesIssuesIssueConnectionNodesIssueProjectMilestone.CreatedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueProjectMilestone) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetDescription returns listIssuesIssuesIssueConnectionNodesIssueProjectMilestone.Description, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueProjectMilestone) GetDescription() *string {
	return v.Description
}

// GetId returns listIssuesIssuesIssueConnectionNodesIssueProjectMilestone.Id, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueProjectMilestone) GetId() *string { return v.Id }

// GetName returns listIssuesIssuesIssueConnectionNodesIssueProjectMilestone.Name, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueProjectMilestone) GetName() *string { return v.Name }

// GetSortOrder returns listIssuesIssuesIssueConnectionNodesIssueProjectMilestone.SortOrder, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueProjectMilestone) GetSortOrder() *float64 {
	return v.SortOrder
}

// GetUpdatedAt returns listIssuesIssuesIssueConnectionNodesIssueProjectMilestone.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueProjectMilestone) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

func (v *listIssuesIssuesIssueConnectionNodesIssueProjectMilestone) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listIssuesIssuesIssueConnectionNodesIssueProjectMilestone
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listIssuesIssuesIssueConnectionNodesIssueProjectMilestone = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueProjectMilestone.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueProjectMilestone.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueProjectMilestone.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistIssuesIssuesIssueConnectionNodesIssueProjectMilestone struct {
	ArchivedAt json.RawMessage `json:"archivedAt"`

	CreatedAt json.RawMessage `json:"createdAt"`

	Description *string `json:"description"`

	Id *string `json:"id"`

	Name *string `json:"name"`

	SortOrder *float64 `json:"sortOrder"`

	UpdatedAt json.RawMessage `json:"updatedAt"`
}

func (v *listIssuesIssuesIssueConnectionNodesIssueProjectMilestone) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listIssuesIssuesIssueConnectionNodesIssueProjectMilestone) __premarshalJSON() (*__premarshallistIssuesIssuesIssueConnectionNodesIssueProjectMilestone, error) {
	var retval __premarshallistIssuesIssuesIssueConnectionNodesIssueProjectMilestone

	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueProjectMilestone.ArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueProjectMilestone.CreatedAt: %w", err)
			}
		}
	}
	retval.Description = v.Description
	retval.Id = v.Id
	retval.Name = v.Name
	retval.SortOrder = v.SortOrder
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueProjectMilestone.UpdatedAt: %w", err)
			}
		}
	}
	return &retval, nil
}

// listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser includes the requested fields of the GraphQL type User.
// The GraphQL type's documentation follows.
//
// A user that has access to the the resources of an organization.
type listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// Whether the user account is active or disabled (suspended).
	Active *bool `json:"active"`
	// Whether the user is an organization administrator.
	Admin *bool `json:"admin"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// An URL to the user's avatar image.
	AvatarUrl *string `json:"avatarUrl"`
	// [DEPRECATED] Hash for the user to be used in calendar URLs.
	CalendarHash *string `json:"calendarHash"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Number of issues created.
	CreatedIssueCount *int `json:"createdIssueCount"`
	// A short description of the user, either its title or bio.
	Description *string `json:"description"`
	// Reason why is the account disabled.
	DisableReason *string `json:"disableReason"`
	// The user's display (nick) name. Unique within each organization.
	DisplayName *string `json:"displayName"`
	// The user's email address.
	Email *string `json:"email"`
	// Whether the user is a guest in the workspace and limited to accessing a subset of teams.
	Guest *bool `json:"guest"`
	// Unique hash for the user to be used in invite URLs.
	InviteHash *string `json:"inviteHash"`
	// Whether the user is the currently authenticated user.
	IsMe *bool `json:"isMe"`
	// The last time the user was seen online. If null, the user is currently online.
	LastSeen *time.Time `json:"-"`
	// The user's full name.
	Name *string `json:"name"`
	// The emoji to represent the user current status.
	StatusEmoji *string `json:"statusEmoji"`
	// The label of the user current status.
	StatusLabel *string `json:"statusLabel"`
	// A date at which the user current status should be cleared.
	StatusUntilAt *time.Time `json:"-"`
	// The local timezone of the user.
	Timezone *string `json:"timezone"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// User's profile URL.
	Url *string `json:"url"`
}

// GetId returns listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser.Id, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser) GetId() *string { return v.Id }

// GetActive returns listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser.Active, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser) GetActive() *bool { return v.Active }

// GetAdmin returns listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser.Admin, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser) GetAdmin() *bool { return v.Admin }

// GetArchivedAt returns listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetAvatarUrl returns listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser.AvatarUrl, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser) GetAvatarUrl() *string {
	return v.AvatarUrl
}

// GetCalendarHash returns listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser.CalendarHash, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser) GetCalendarHash() *string {
	return v.CalendarHash
}

// GetCreatedAt returns listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser.CreatedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetCreatedIssueCount returns listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser.CreatedIssueCount, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser) GetCreatedIssueCount() *int {
	return v.CreatedIssueCount
}

// GetDescription returns listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser.Description, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser) GetDescription() *string {
	return v.Description
}

// GetDisableReason returns listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser.DisableReason, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser) GetDisableReason() *string {
	return v.DisableReason
}

// GetDisplayName returns listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser.DisplayName, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser) GetDisplayName() *string {
	return v.DisplayName
}

// GetEmail returns listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser.Email, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser) GetEmail() *string { return v.Email }

// GetGuest returns listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser.Guest, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser) GetGuest() *bool { return v.Guest }

// GetInviteHash returns listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser.InviteHash, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser) GetInviteHash() *string {
	return v.InviteHash
}

// GetIsMe returns listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser.IsMe, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser) GetIsMe() *bool { return v.IsMe }

// GetLastSeen returns listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser.LastSeen, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser) GetLastSeen() *time.Time {
	return v.LastSeen
}

// GetName returns listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser.Name, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser) GetName() *string { return v.Name }

// GetStatusEmoji returns listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser.StatusEmoji, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser) GetStatusEmoji() *string {
	return v.StatusEmoji
}

// GetStatusLabel returns listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser.StatusLabel, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser) GetStatusLabel() *string {
	return v.StatusLabel
}

// GetStatusUntilAt returns listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser.StatusUntilAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser) GetStatusUntilAt() *time.Time {
	return v.StatusUntilAt
}

// GetTimezone returns listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser.Timezone, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser) GetTimezone() *string {
	return v.Timezone
}

// GetUpdatedAt returns listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

// GetUrl returns listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser.Url, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser) GetUrl() *string { return v.Url }

func (v *listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser
		ArchivedAt    json.RawMessage `json:"archivedAt"`
		CreatedAt     json.RawMessage `json:"createdAt"`
		LastSeen      json.RawMessage `json:"lastSeen"`
		StatusUntilAt json.RawMessage `json:"statusUntilAt"`
		UpdatedAt     json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.LastSeen
		src := firstPass.LastSeen
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser.LastSeen: %w", err)
			}
		}
	}

	{
		dst := &v.StatusUntilAt
		src := firstPass.StatusUntilAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser.StatusUntilAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistIssuesIssuesIssueConnectionNodesIssueSnoozedByUser struct {
	Id *string `json:"id"`

	Active *bool `json:"active"`

	Admin *bool `json:"admin"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AvatarUrl *string `json:"avatarUrl"`

	CalendarHash *string `json:"calendarHash"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CreatedIssueCount *int `json:"createdIssueCount"`

	Description *string `json:"description"`

	DisableReason *string `json:"disableReason"`

	DisplayName *string `json:"displayName"`

	Email *string `json:"email"`

	Guest *bool `json:"guest"`

	InviteHash *string `json:"inviteHash"`

	IsMe *bool `json:"isMe"`

	LastSeen json.RawMessage `json:"lastSeen"`

	Name *string `json:"name"`

	StatusEmoji *string `json:"statusEmoji"`

	StatusLabel *string `json:"statusLabel"`

	StatusUntilAt json.RawMessage `json:"statusUntilAt"`

	Timezone *string `json:"timezone"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	Url *string `json:"url"`
}

func (v *listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser) __premarshalJSON() (*__premarshallistIssuesIssuesIssueConnectionNodesIssueSnoozedByUser, error) {
	var retval __premarshallistIssuesIssuesIssueConnectionNodesIssueSnoozedByUser

	retval.Id = v.Id
	retval.Active = v.Active
	retval.Admin = v.Admin
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser.ArchivedAt: %w", err)
			}
		}
	}
	retval.AvatarUrl = v.AvatarUrl
	retval.CalendarHash = v.CalendarHash
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser.CreatedAt: %w", err)
			}
		}
	}
	retval.CreatedIssueCount = v.CreatedIssueCount
	retval.Description = v.Description
	retval.DisableReason = v.DisableReason
	retval.DisplayName = v.DisplayName
	retval.Email = v.Email
	retval.Guest = v.Guest
	retval.InviteHash = v.InviteHash
	retval.IsMe = v.IsMe
	{

		dst := &retval.LastSeen
		src := v.LastSeen
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser.LastSeen: %w", err)
			}
		}
	}
	retval.Name = v.Name
	retval.StatusEmoji = v.StatusEmoji
	retval.StatusLabel = v.StatusLabel
	{

		dst := &retval.StatusUntilAt
		src := v.StatusUntilAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser.StatusUntilAt: %w", err)
			}
		}
	}
	retval.Timezone = v.Timezone
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueSnoozedByUser.UpdatedAt: %w", err)
			}
		}
	}
	retval.Url = v.Url
	return &retval, nil
}

// listIssuesIssuesIssueConnectionNodesIssueStateWorkflowState includes the requested fields of the GraphQL type WorkflowState.
// The GraphQL type's documentation follows.
//
// A state in a team workflow.
type listIssuesIssuesIssueConnectionNodesIssueStateWorkflowState struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The state's UI color as a HEX string.
	Color *string `json:"color"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Description of the state.
	Description *string `json:"description"`
	// The state's name.
	Name *string `json:"name"`
	// The position of the state in the team flow.
	Position *float64 `json:"position"`
	// The type of the state.
	Type *string `json:"type"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
}

// GetId returns listIssuesIssuesIssueConnectionNodesIssueStateWorkflowState.Id, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueStateWorkflowState) GetId() *string { return v.Id }

// GetArchivedAt returns listIssuesIssuesIssueConnectionNodesIssueStateWorkflowState.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueStateWorkflowState) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetColor returns listIssuesIssuesIssueConnectionNodesIssueStateWorkflowState.Color, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueStateWorkflowState) GetColor() *string {
	return v.Color
}

// GetCreatedAt returns listIssuesIssuesIssueConnectionNodesIssueStateWorkflowState.CreatedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueStateWorkflowState) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetDescription returns listIssuesIssuesIssueConnectionNodesIssueStateWorkflowState.Description, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueStateWorkflowState) GetDescription() *string {
	return v.Description
}

// GetName returns listIssuesIssuesIssueConnectionNodesIssueStateWorkflowState.Name, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueStateWorkflowState) GetName() *string {
	return v.Name
}

// GetPosition returns listIssuesIssuesIssueConnectionNodesIssueStateWorkflowState.Position, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueStateWorkflowState) GetPosition() *float64 {
	return v.Position
}

// GetType returns listIssuesIssuesIssueConnectionNodesIssueStateWorkflowState.Type, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueStateWorkflowState) GetType() *string {
	return v.Type
}

// GetUpdatedAt returns listIssuesIssuesIssueConnectionNodesIssueStateWorkflowState.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueStateWorkflowState) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

func (v *listIssuesIssuesIssueConnectionNodesIssueStateWorkflowState) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listIssuesIssuesIssueConnectionNodesIssueStateWorkflowState
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listIssuesIssuesIssueConnectionNodesIssueStateWorkflowState = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueStateWorkflowState.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueStateWorkflowState.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueStateWorkflowState.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistIssuesIssuesIssueConnectionNodesIssueStateWorkflowState struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	Color *string `json:"color"`

	CreatedAt json.RawMessage `json:"createdAt"`

	Description *string `json:"description"`

	Name *string `json:"name"`

	Position *float64 `json:"position"`

	Type *string `json:"type"`

	UpdatedAt json.RawMessage `json:"updatedAt"`
}

func (v *listIssuesIssuesIssueConnectionNodesIssueStateWorkflowState) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listIssuesIssuesIssueConnectionNodesIssueStateWorkflowState) __premarshalJSON() (*__premarshallistIssuesIssuesIssueConnectionNodesIssueStateWorkflowState, error) {
	var retval __premarshallistIssuesIssuesIssueConnectionNodesIssueStateWorkflowState

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueStateWorkflowState.ArchivedAt: %w", err)
			}
		}
	}
	retval.Color = v.Color
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueStateWorkflowState.CreatedAt: %w", err)
			}
		}
	}
	retval.Description = v.Description
	retval.Name = v.Name
	retval.Position = v.Position
	retval.Type = v.Type
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueStateWorkflowState.UpdatedAt: %w", err)
			}
		}
	}
	return &retval, nil
}

// listIssuesIssuesIssueConnectionNodesIssueTeam includes the requested fields of the GraphQL type Team.
// The GraphQL type's documentation follows.
//
// An organizational unit that contains issues.
type listIssuesIssuesIssueConnectionNodesIssueTeam struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// Period after which automatically closed and completed issues are automatically archived in months.
	AutoArchivePeriod *float64 `json:"autoArchivePeriod"`
	// Period after which issues are automatically closed in months. Null/undefined means disabled.
	AutoClosePeriod *float64 `json:"autoClosePeriod"`
	// The canceled workflow state which auto closed issues will be set to. Defaults to the first canceled state.
	AutoCloseStateId *string `json:"autoCloseStateId"`
	// The team's color.
	Color *string `json:"color"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Calendar feed URL (iCal) for cycles.
	CycleCalenderUrl *string `json:"cycleCalenderUrl"`
	// The cooldown time after each cycle in weeks.
	CycleCooldownTime *float64 `json:"cycleCooldownTime"`
	// The duration of a cycle in weeks.
	CycleDuration *float64 `json:"cycleDuration"`
	// Auto assign completed issues to current cycle.
	CycleIssueAutoAssignCompleted *bool `json:"cycleIssueAutoAssignCompleted"`
	// Auto assign started issues to current cycle.
	CycleIssueAutoAssignStarted *bool `json:"cycleIssueAutoAssignStarted"`
	// Only allow issues issues with cycles in Active Issues.
	CycleLockToActive *bool `json:"cycleLockToActive"`
	// The day of the week that a new cycle starts.
	CycleStartDay *float64 `json:"cycleStartDay"`
	// Whether the team uses cycles.
	CyclesEnabled *bool `json:"cyclesEnabled"`
	// What to use as an default estimate for unestimated issues.
	DefaultIssueEstimate *float64 `json:"defaultIssueEstimate"`
	// The id of the default template to use for new issues created by members of the team.
	DefaultTemplateForMembersId *string `json:"defaultTemplateForMembersId"`
	// The id of the default template to use for new issues created by non-members of the team.
	DefaultTemplateForNonMembersId *string `json:"defaultTemplateForNonMembersId"`
	// The team's description.
	Description *string `json:"description"`
	// Whether to group recent issue history entries.
	GroupIssueHistory *bool `json:"groupIssueHistory"`
	// The icon of the team.
	Icon *string `json:"icon"`
	// Unique hash for the team to be used in invite URLs.
	InviteHash *string `json:"inviteHash"`
	// Whether to allow zeros in issues estimates.
	IssueEstimationAllowZero *bool `json:"issueEstimationAllowZero"`
	// Whether to add additional points to the estimate scale.
	IssueEstimationExtended *bool `json:"issueEstimationExtended"`
	// The issue estimation type to use.
	IssueEstimationType *string `json:"issueEstimationType"`
	// Whether issues without priority should be sorted first.
	IssueOrderingNoPriorityFirst *bool `json:"issueOrderingNoPriorityFirst"`
	// Whether to move issues to bottom of the column when changing state.
	IssueSortOrderDefaultToBottom *bool `json:"issueSortOrderDefaultToBottom"`
	// The team's unique key. The key is used in URLs.
	Key *string `json:"key"`
	// The team's name.
	Name *string `json:"name"`
	// Whether the team is private or not.
	Private *bool `json:"private"`
	// Whether an issue needs to have a priority set before leaving triage
	RequirePriorityToLeaveTriage *bool `json:"requirePriorityToLeaveTriage"`
	// Whether to send new issue comment notifications to Slack.
	SlackIssueComments *bool `json:"slackIssueComments"`
	// Whether to send new issue status updates to Slack.
	SlackIssueStatuses *bool `json:"slackIssueStatuses"`
	// Whether to send new issue notifications to Slack.
	SlackNewIssue *bool `json:"slackNewIssue"`
	// The timezone of the team. Defaults to "America/Los_Angeles"
	Timezone *string `json:"timezone"`
	// Whether triage mode is enabled for the team or not.
	TriageEnabled *bool `json:"triageEnabled"`
	// How many upcoming cycles to create.
	UpcomingCycleCount *float64 `json:"upcomingCycleCount"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
}

// GetId returns listIssuesIssuesIssueConnectionNodesIssueTeam.Id, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) GetId() *string { return v.Id }

// GetArchivedAt returns listIssuesIssuesIssueConnectionNodesIssueTeam.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetAutoArchivePeriod returns listIssuesIssuesIssueConnectionNodesIssueTeam.AutoArchivePeriod, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) GetAutoArchivePeriod() *float64 {
	return v.AutoArchivePeriod
}

// GetAutoClosePeriod returns listIssuesIssuesIssueConnectionNodesIssueTeam.AutoClosePeriod, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) GetAutoClosePeriod() *float64 {
	return v.AutoClosePeriod
}

// GetAutoCloseStateId returns listIssuesIssuesIssueConnectionNodesIssueTeam.AutoCloseStateId, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) GetAutoCloseStateId() *string {
	return v.AutoCloseStateId
}

// GetColor returns listIssuesIssuesIssueConnectionNodesIssueTeam.Color, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) GetColor() *string { return v.Color }

// GetCreatedAt returns listIssuesIssuesIssueConnectionNodesIssueTeam.CreatedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetCycleCalenderUrl returns listIssuesIssuesIssueConnectionNodesIssueTeam.CycleCalenderUrl, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) GetCycleCalenderUrl() *string {
	return v.CycleCalenderUrl
}

// GetCycleCooldownTime returns listIssuesIssuesIssueConnectionNodesIssueTeam.CycleCooldownTime, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) GetCycleCooldownTime() *float64 {
	return v.CycleCooldownTime
}

// GetCycleDuration returns listIssuesIssuesIssueConnectionNodesIssueTeam.CycleDuration, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) GetCycleDuration() *float64 {
	return v.CycleDuration
}

// GetCycleIssueAutoAssignCompleted returns listIssuesIssuesIssueConnectionNodesIssueTeam.CycleIssueAutoAssignCompleted, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) GetCycleIssueAutoAssignCompleted() *bool {
	return v.CycleIssueAutoAssignCompleted
}

// GetCycleIssueAutoAssignStarted returns listIssuesIssuesIssueConnectionNodesIssueTeam.CycleIssueAutoAssignStarted, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) GetCycleIssueAutoAssignStarted() *bool {
	return v.CycleIssueAutoAssignStarted
}

// GetCycleLockToActive returns listIssuesIssuesIssueConnectionNodesIssueTeam.CycleLockToActive, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) GetCycleLockToActive() *bool {
	return v.CycleLockToActive
}

// GetCycleStartDay returns listIssuesIssuesIssueConnectionNodesIssueTeam.CycleStartDay, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) GetCycleStartDay() *float64 {
	return v.CycleStartDay
}

// GetCyclesEnabled returns listIssuesIssuesIssueConnectionNodesIssueTeam.CyclesEnabled, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) GetCyclesEnabled() *bool {
	return v.CyclesEnabled
}

// GetDefaultIssueEstimate returns listIssuesIssuesIssueConnectionNodesIssueTeam.DefaultIssueEstimate, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) GetDefaultIssueEstimate() *float64 {
	return v.DefaultIssueEstimate
}

// GetDefaultTemplateForMembersId returns listIssuesIssuesIssueConnectionNodesIssueTeam.DefaultTemplateForMembersId, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) GetDefaultTemplateForMembersId() *string {
	return v.DefaultTemplateForMembersId
}

// GetDefaultTemplateForNonMembersId returns listIssuesIssuesIssueConnectionNodesIssueTeam.DefaultTemplateForNonMembersId, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) GetDefaultTemplateForNonMembersId() *string {
	return v.DefaultTemplateForNonMembersId
}

// GetDescription returns listIssuesIssuesIssueConnectionNodesIssueTeam.Description, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) GetDescription() *string {
	return v.Description
}

// GetGroupIssueHistory returns listIssuesIssuesIssueConnectionNodesIssueTeam.GroupIssueHistory, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) GetGroupIssueHistory() *bool {
	return v.GroupIssueHistory
}

// GetIcon returns listIssuesIssuesIssueConnectionNodesIssueTeam.Icon, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) GetIcon() *string { return v.Icon }

// GetInviteHash returns listIssuesIssuesIssueConnectionNodesIssueTeam.InviteHash, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) GetInviteHash() *string { return v.InviteHash }

// GetIssueEstimationAllowZero returns listIssuesIssuesIssueConnectionNodesIssueTeam.IssueEstimationAllowZero, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) GetIssueEstimationAllowZero() *bool {
	return v.IssueEstimationAllowZero
}

// GetIssueEstimationExtended returns listIssuesIssuesIssueConnectionNodesIssueTeam.IssueEstimationExtended, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) GetIssueEstimationExtended() *bool {
	return v.IssueEstimationExtended
}

// GetIssueEstimationType returns listIssuesIssuesIssueConnectionNodesIssueTeam.IssueEstimationType, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) GetIssueEstimationType() *string {
	return v.IssueEstimationType
}

// GetIssueOrderingNoPriorityFirst returns listIssuesIssuesIssueConnectionNodesIssueTeam.IssueOrderingNoPriorityFirst, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) GetIssueOrderingNoPriorityFirst() *bool {
	return v.IssueOrderingNoPriorityFirst
}

// GetIssueSortOrderDefaultToBottom returns listIssuesIssuesIssueConnectionNodesIssueTeam.IssueSortOrderDefaultToBottom, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) GetIssueSortOrderDefaultToBottom() *bool {
	return v.IssueSortOrderDefaultToBottom
}

// GetKey returns listIssuesIssuesIssueConnectionNodesIssueTeam.Key, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) GetKey() *string { return v.Key }

// GetName returns listIssuesIssuesIssueConnectionNodesIssueTeam.Name, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) GetName() *string { return v.Name }

// GetPrivate returns listIssuesIssuesIssueConnectionNodesIssueTeam.Private, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) GetPrivate() *bool { return v.Private }

// GetRequirePriorityToLeaveTriage returns listIssuesIssuesIssueConnectionNodesIssueTeam.RequirePriorityToLeaveTriage, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) GetRequirePriorityToLeaveTriage() *bool {
	return v.RequirePriorityToLeaveTriage
}

// GetSlackIssueComments returns listIssuesIssuesIssueConnectionNodesIssueTeam.SlackIssueComments, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) GetSlackIssueComments() *bool {
	return v.SlackIssueComments
}

// GetSlackIssueStatuses returns listIssuesIssuesIssueConnectionNodesIssueTeam.SlackIssueStatuses, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) GetSlackIssueStatuses() *bool {
	return v.SlackIssueStatuses
}

// GetSlackNewIssue returns listIssuesIssuesIssueConnectionNodesIssueTeam.SlackNewIssue, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) GetSlackNewIssue() *bool {
	return v.SlackNewIssue
}

// GetTimezone returns listIssuesIssuesIssueConnectionNodesIssueTeam.Timezone, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) GetTimezone() *string { return v.Timezone }

// GetTriageEnabled returns listIssuesIssuesIssueConnectionNodesIssueTeam.TriageEnabled, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) GetTriageEnabled() *bool {
	return v.TriageEnabled
}

// GetUpcomingCycleCount returns listIssuesIssuesIssueConnectionNodesIssueTeam.UpcomingCycleCount, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) GetUpcomingCycleCount() *float64 {
	return v.UpcomingCycleCount
}

// GetUpdatedAt returns listIssuesIssuesIssueConnectionNodesIssueTeam.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) GetUpdatedAt() *time.Time { return v.UpdatedAt }

func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listIssuesIssuesIssueConnectionNodesIssueTeam
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listIssuesIssuesIssueConnectionNodesIssueTeam = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueTeam.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueTeam.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listIssuesIssuesIssueConnectionNodesIssueTeam.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistIssuesIssuesIssueConnectionNodesIssueTeam struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AutoArchivePeriod *float64 `json:"autoArchivePeriod"`

	AutoClosePeriod *float64 `json:"autoClosePeriod"`

	AutoCloseStateId *string `json:"autoCloseStateId"`

	Color *string `json:"color"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CycleCalenderUrl *string `json:"cycleCalenderUrl"`

	CycleCooldownTime *float64 `json:"cycleCooldownTime"`

	CycleDuration *float64 `json:"cycleDuration"`

	CycleIssueAutoAssignCompleted *bool `json:"cycleIssueAutoAssignCompleted"`

	CycleIssueAutoAssignStarted *bool `json:"cycleIssueAutoAssignStarted"`

	CycleLockToActive *bool `json:"cycleLockToActive"`

	CycleStartDay *float64 `json:"cycleStartDay"`

	CyclesEnabled *bool `json:"cyclesEnabled"`

	DefaultIssueEstimate *float64 `json:"defaultIssueEstimate"`

	DefaultTemplateForMembersId *string `json:"defaultTemplateForMembersId"`

	DefaultTemplateForNonMembersId *string `json:"defaultTemplateForNonMembersId"`

	Description *string `json:"description"`

	GroupIssueHistory *bool `json:"groupIssueHistory"`

	Icon *string `json:"icon"`

	InviteHash *string `json:"inviteHash"`

	IssueEstimationAllowZero *bool `json:"issueEstimationAllowZero"`

	IssueEstimationExtended *bool `json:"issueEstimationExtended"`

	IssueEstimationType *string `json:"issueEstimationType"`

	IssueOrderingNoPriorityFirst *bool `json:"issueOrderingNoPriorityFirst"`

	IssueSortOrderDefaultToBottom *bool `json:"issueSortOrderDefaultToBottom"`

	Key *string `json:"key"`

	Name *string `json:"name"`

	Private *bool `json:"private"`

	RequirePriorityToLeaveTriage *bool `json:"requirePriorityToLeaveTriage"`

	SlackIssueComments *bool `json:"slackIssueComments"`

	SlackIssueStatuses *bool `json:"slackIssueStatuses"`

	SlackNewIssue *bool `json:"slackNewIssue"`

	Timezone *string `json:"timezone"`

	TriageEnabled *bool `json:"triageEnabled"`

	UpcomingCycleCount *float64 `json:"upcomingCycleCount"`

	UpdatedAt json.RawMessage `json:"updatedAt"`
}

func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listIssuesIssuesIssueConnectionNodesIssueTeam) __premarshalJSON() (*__premarshallistIssuesIssuesIssueConnectionNodesIssueTeam, error) {
	var retval __premarshallistIssuesIssuesIssueConnectionNodesIssueTeam

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueTeam.ArchivedAt: %w", err)
			}
		}
	}
	retval.AutoArchivePeriod = v.AutoArchivePeriod
	retval.AutoClosePeriod = v.AutoClosePeriod
	retval.AutoCloseStateId = v.AutoCloseStateId
	retval.Color = v.Color
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueTeam.CreatedAt: %w", err)
			}
		}
	}
	retval.CycleCalenderUrl = v.CycleCalenderUrl
	retval.CycleCooldownTime = v.CycleCooldownTime
	retval.CycleDuration = v.CycleDuration
	retval.CycleIssueAutoAssignCompleted = v.CycleIssueAutoAssignCompleted
	retval.CycleIssueAutoAssignStarted = v.CycleIssueAutoAssignStarted
	retval.CycleLockToActive = v.CycleLockToActive
	retval.CycleStartDay = v.CycleStartDay
	retval.CyclesEnabled = v.CyclesEnabled
	retval.DefaultIssueEstimate = v.DefaultIssueEstimate
	retval.DefaultTemplateForMembersId = v.DefaultTemplateForMembersId
	retval.DefaultTemplateForNonMembersId = v.DefaultTemplateForNonMembersId
	retval.Description = v.Description
	retval.GroupIssueHistory = v.GroupIssueHistory
	retval.Icon = v.Icon
	retval.InviteHash = v.InviteHash
	retval.IssueEstimationAllowZero = v.IssueEstimationAllowZero
	retval.IssueEstimationExtended = v.IssueEstimationExtended
	retval.IssueEstimationType = v.IssueEstimationType
	retval.IssueOrderingNoPriorityFirst = v.IssueOrderingNoPriorityFirst
	retval.IssueSortOrderDefaultToBottom = v.IssueSortOrderDefaultToBottom
	retval.Key = v.Key
	retval.Name = v.Name
	retval.Private = v.Private
	retval.RequirePriorityToLeaveTriage = v.RequirePriorityToLeaveTriage
	retval.SlackIssueComments = v.SlackIssueComments
	retval.SlackIssueStatuses = v.SlackIssueStatuses
	retval.SlackNewIssue = v.SlackNewIssue
	retval.Timezone = v.Timezone
	retval.TriageEnabled = v.TriageEnabled
	retval.UpcomingCycleCount = v.UpcomingCycleCount
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listIssuesIssuesIssueConnectionNodesIssueTeam.UpdatedAt: %w", err)
			}
		}
	}
	return &retval, nil
}

// listIssuesIssuesIssueConnectionPageInfo includes the requested fields of the GraphQL type PageInfo.
type listIssuesIssuesIssueConnectionPageInfo struct {
	// Indicates if there are more results when paginating forward.
	HasNextPage *bool `json:"hasNextPage"`
	// Cursor representing the last result in the paginated results.
	EndCursor *string `json:"endCursor"`
}

// GetHasNextPage returns listIssuesIssuesIssueConnectionPageInfo.HasNextPage, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionPageInfo) GetHasNextPage() *bool { return v.HasNextPage }

// GetEndCursor returns listIssuesIssuesIssueConnectionPageInfo.EndCursor, and is useful for accessing the field via an interface.
func (v *listIssuesIssuesIssueConnectionPageInfo) GetEndCursor() *string { return v.EndCursor }

// listIssuesResponse is returned by listIssues on success.
type listIssuesResponse struct {
	// All issues.
	Issues *listIssuesIssuesIssueConnection `json:"issues"`
}

// GetIssues returns listIssuesResponse.Issues, and is useful for accessing the field via an interface.
func (v *listIssuesResponse) GetIssues() *listIssuesIssuesIssueConnection { return v.Issues }

// listProjectsProjectsProjectConnection includes the requested fields of the GraphQL type ProjectConnection.
type listProjectsProjectsProjectConnection struct {
	PageInfo *listProjectsProjectsProjectConnectionPageInfo       `json:"pageInfo"`
	Nodes    []*listProjectsProjectsProjectConnectionNodesProject `json:"nodes"`
}

// GetPageInfo returns listProjectsProjectsProjectConnection.PageInfo, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnection) GetPageInfo() *listProjectsProjectsProjectConnectionPageInfo {
	return v.PageInfo
}

// GetNodes returns listProjectsProjectsProjectConnection.Nodes, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnection) GetNodes() []*listProjectsProjectsProjectConnectionNodesProject {
	return v.Nodes
}

// listProjectsProjectsProjectConnectionNodesProject includes the requested fields of the GraphQL type Project.
// The GraphQL type's documentation follows.
//
// A project.
type listProjectsProjectsProjectConnectionNodesProject struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The time at which the project was automatically archived by the auto pruning process.
	AutoArchivedAt *time.Time `json:"-"`
	// The time at which the project was moved into canceled state.
	CanceledAt *time.Time `json:"-"`
	// The project's color.
	Color *string `json:"color"`
	// The time at which the project was moved into completed state.
	CompletedAt *time.Time `json:"-"`
	// The number of completed issues in the project after each week.
	CompletedIssueCountHistory []*float64 `json:"completedIssueCountHistory"`
	// The number of completed estimation points after each week.
	CompletedScopeHistory []*float64 `json:"completedScopeHistory"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// The project's description.
	Description *string `json:"description"`
	// The icon of the project.
	Icon *string `json:"icon"`
	// The number of in progress estimation points after each week.
	InProgressScopeHistory []*float64 `json:"inProgressScopeHistory"`
	// The total number of issues in the project after each week.
	IssueCountHistory []*float64 `json:"issueCountHistory"`
	// The project's name.
	Name *string `json:"name"`
	// The overall progress of the project. This is the (completed estimate points + 0.25 * in progress estimate points) / total estimate points.
	Progress *float64 `json:"progress"`
	// The time until which project update reminders are paused.
	ProjectUpdateRemindersPausedUntilAt *time.Time `json:"-"`
	// The overall scope (total estimate points) of the project.
	Scope *float64 `json:"scope"`
	// The total number of estimation points after each week.
	ScopeHistory []*float64 `json:"scopeHistory"`
	// Whether to send new issue comment notifications to Slack.
	SlackIssueComments *bool `json:"slackIssueComments"`
	// Whether to send new issue status updates to Slack.
	SlackIssueStatuses *bool `json:"slackIssueStatuses"`
	// Whether to send new issue notifications to Slack.
	SlackNewIssue *bool `json:"slackNewIssue"`
	// The project's unique URL slug.
	SlugId *string `json:"slugId"`
	// The sort order for the project within the organization.
	SortOrder *float64 `json:"sortOrder"`
	// [Internal] The estimated start date of the project.
	StartDate *time.Time `json:"-"`
	// The time at which the project was moved into started state.
	StartedAt *time.Time `json:"-"`
	// The type of the state.
	State *string `json:"state"`
	// The estimated completion date of the project.
	TargetDate *time.Time `json:"-"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// Project URL.
	Url *string `json:"url"`
	// The project was created based on this issue.
	ConvertedFromIssue *listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue `json:"convertedFromIssue"`
	// Settings for all integrations associated with that project.
	IntegrationsSettings *listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings `json:"integrationsSettings"`
	// The user who created the project.
	Creator *listProjectsProjectsProjectConnectionNodesProjectCreatorUser `json:"creator"`
	// The project lead.
	Lead *listProjectsProjectsProjectConnectionNodesProjectLeadUser `json:"lead"`
}

// GetId returns listProjectsProjectsProjectConnectionNodesProject.Id, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProject) GetId() *string { return v.Id }

// GetArchivedAt returns listProjectsProjectsProjectConnectionNodesProject.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProject) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetAutoArchivedAt returns listProjectsProjectsProjectConnectionNodesProject.AutoArchivedAt, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProject) GetAutoArchivedAt() *time.Time {
	return v.AutoArchivedAt
}

// GetCanceledAt returns listProjectsProjectsProjectConnectionNodesProject.CanceledAt, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProject) GetCanceledAt() *time.Time {
	return v.CanceledAt
}

// GetColor returns listProjectsProjectsProjectConnectionNodesProject.Color, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProject) GetColor() *string { return v.Color }

// GetCompletedAt returns listProjectsProjectsProjectConnectionNodesProject.CompletedAt, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProject) GetCompletedAt() *time.Time {
	return v.CompletedAt
}

// GetCompletedIssueCountHistory returns listProjectsProjectsProjectConnectionNodesProject.CompletedIssueCountHistory, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProject) GetCompletedIssueCountHistory() []*float64 {
	return v.CompletedIssueCountHistory
}

// GetCompletedScopeHistory returns listProjectsProjectsProjectConnectionNodesProject.CompletedScopeHistory, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProject) GetCompletedScopeHistory() []*float64 {
	return v.CompletedScopeHistory
}

// GetCreatedAt returns listProjectsProjectsProjectConnectionNodesProject.CreatedAt, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProject) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetDescription returns listProjectsProjectsProjectConnectionNodesProject.Description, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProject) GetDescription() *string {
	return v.Description
}

// GetIcon returns listProjectsProjectsProjectConnectionNodesProject.Icon, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProject) GetIcon() *string { return v.Icon }

// GetInProgressScopeHistory returns listProjectsProjectsProjectConnectionNodesProject.InProgressScopeHistory, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProject) GetInProgressScopeHistory() []*float64 {
	return v.InProgressScopeHistory
}

// GetIssueCountHistory returns listProjectsProjectsProjectConnectionNodesProject.IssueCountHistory, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProject) GetIssueCountHistory() []*float64 {
	return v.IssueCountHistory
}

// GetName returns listProjectsProjectsProjectConnectionNodesProject.Name, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProject) GetName() *string { return v.Name }

// GetProgress returns listProjectsProjectsProjectConnectionNodesProject.Progress, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProject) GetProgress() *float64 { return v.Progress }

// GetProjectUpdateRemindersPausedUntilAt returns listProjectsProjectsProjectConnectionNodesProject.ProjectUpdateRemindersPausedUntilAt, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProject) GetProjectUpdateRemindersPausedUntilAt() *time.Time {
	return v.ProjectUpdateRemindersPausedUntilAt
}

// GetScope returns listProjectsProjectsProjectConnectionNodesProject.Scope, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProject) GetScope() *float64 { return v.Scope }

// GetScopeHistory returns listProjectsProjectsProjectConnectionNodesProject.ScopeHistory, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProject) GetScopeHistory() []*float64 {
	return v.ScopeHistory
}

// GetSlackIssueComments returns listProjectsProjectsProjectConnectionNodesProject.SlackIssueComments, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProject) GetSlackIssueComments() *bool {
	return v.SlackIssueComments
}

// GetSlackIssueStatuses returns listProjectsProjectsProjectConnectionNodesProject.SlackIssueStatuses, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProject) GetSlackIssueStatuses() *bool {
	return v.SlackIssueStatuses
}

// GetSlackNewIssue returns listProjectsProjectsProjectConnectionNodesProject.SlackNewIssue, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProject) GetSlackNewIssue() *bool {
	return v.SlackNewIssue
}

// GetSlugId returns listProjectsProjectsProjectConnectionNodesProject.SlugId, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProject) GetSlugId() *string { return v.SlugId }

// GetSortOrder returns listProjectsProjectsProjectConnectionNodesProject.SortOrder, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProject) GetSortOrder() *float64 {
	return v.SortOrder
}

// GetStartDate returns listProjectsProjectsProjectConnectionNodesProject.StartDate, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProject) GetStartDate() *time.Time {
	return v.StartDate
}

// GetStartedAt returns listProjectsProjectsProjectConnectionNodesProject.StartedAt, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProject) GetStartedAt() *time.Time {
	return v.StartedAt
}

// GetState returns listProjectsProjectsProjectConnectionNodesProject.State, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProject) GetState() *string { return v.State }

// GetTargetDate returns listProjectsProjectsProjectConnectionNodesProject.TargetDate, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProject) GetTargetDate() *time.Time {
	return v.TargetDate
}

// GetUpdatedAt returns listProjectsProjectsProjectConnectionNodesProject.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProject) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

// GetUrl returns listProjectsProjectsProjectConnectionNodesProject.Url, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProject) GetUrl() *string { return v.Url }

// GetConvertedFromIssue returns listProjectsProjectsProjectConnectionNodesProject.ConvertedFromIssue, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProject) GetConvertedFromIssue() *listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue {
	return v.ConvertedFromIssue
}

// GetIntegrationsSettings returns listProjectsProjectsProjectConnectionNodesProject.IntegrationsSettings, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProject) GetIntegrationsSettings() *listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings {
	return v.IntegrationsSettings
}

// GetCreator returns listProjectsProjectsProjectConnectionNodesProject.Creator, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProject) GetCreator() *listProjectsProjectsProjectConnectionNodesProjectCreatorUser {
	return v.Creator
}

// GetLead returns listProjectsProjectsProjectConnectionNodesProject.Lead, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProject) GetLead() *listProjectsProjectsProjectConnectionNodesProjectLeadUser {
	return v.Lead
}

func (v *listProjectsProjectsProjectConnectionNodesProject) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listProjectsProjectsProjectConnectionNodesProject
		ArchivedAt                          json.RawMessage `json:"archivedAt"`
		AutoArchivedAt                      json.RawMessage `json:"autoArchivedAt"`
		CanceledAt                          json.RawMessage `json:"canceledAt"`
		CompletedAt                         json.RawMessage `json:"completedAt"`
		CreatedAt                           json.RawMessage `json:"createdAt"`
		ProjectUpdateRemindersPausedUntilAt json.RawMessage `json:"projectUpdateRemindersPausedUntilAt"`
		StartDate                           json.RawMessage `json:"startDate"`
		StartedAt                           json.RawMessage `json:"startedAt"`
		TargetDate                          json.RawMessage `json:"targetDate"`
		UpdatedAt                           json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listProjectsProjectsProjectConnectionNodesProject = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listProjectsProjectsProjectConnectionNodesProject.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.AutoArchivedAt
		src := firstPass.AutoArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listProjectsProjectsProjectConnectionNodesProject.AutoArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CanceledAt
		src := firstPass.CanceledAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listProjectsProjectsProjectConnectionNodesProject.CanceledAt: %w", err)
			}
		}
	}

	{
		dst := &v.CompletedAt
		src := firstPass.CompletedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listProjectsProjectsProjectConnectionNodesProject.CompletedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listProjectsProjectsProjectConnectionNodesProject.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.ProjectUpdateRemindersPausedUntilAt
		src := firstPass.ProjectUpdateRemindersPausedUntilAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listProjectsProjectsProjectConnectionNodesProject.ProjectUpdateRemindersPausedUntilAt: %w", err)
			}
		}
	}

	{
		dst := &v.StartDate
		src := firstPass.StartDate
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listProjectsProjectsProjectConnectionNodesProject.StartDate: %w", err)
			}
		}
	}

	{
		dst := &v.StartedAt
		src := firstPass.StartedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listProjectsProjectsProjectConnectionNodesProject.StartedAt: %w", err)
			}
		}
	}

	{
		dst := &v.TargetDate
		src := firstPass.TargetDate
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listProjectsProjectsProjectConnectionNodesProject.TargetDate: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listProjectsProjectsProjectConnectionNodesProject.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistProjectsProjectsProjectConnectionNodesProject struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AutoArchivedAt json.RawMessage `json:"autoArchivedAt"`

	CanceledAt json.RawMessage `json:"canceledAt"`

	Color *string `json:"color"`

	CompletedAt json.RawMessage `json:"completedAt"`

	CompletedIssueCountHistory []*float64 `json:"completedIssueCountHistory"`

	CompletedScopeHistory []*float64 `json:"completedScopeHistory"`

	CreatedAt json.RawMessage `json:"createdAt"`

	Description *string `json:"description"`

	Icon *string `json:"icon"`

	InProgressScopeHistory []*float64 `json:"inProgressScopeHistory"`

	IssueCountHistory []*float64 `json:"issueCountHistory"`

	Name *string `json:"name"`

	Progress *float64 `json:"progress"`

	ProjectUpdateRemindersPausedUntilAt json.RawMessage `json:"projectUpdateRemindersPausedUntilAt"`

	Scope *float64 `json:"scope"`

	ScopeHistory []*float64 `json:"scopeHistory"`

	SlackIssueComments *bool `json:"slackIssueComments"`

	SlackIssueStatuses *bool `json:"slackIssueStatuses"`

	SlackNewIssue *bool `json:"slackNewIssue"`

	SlugId *string `json:"slugId"`

	SortOrder *float64 `json:"sortOrder"`

	StartDate json.RawMessage `json:"startDate"`

	StartedAt json.RawMessage `json:"startedAt"`

	State *string `json:"state"`

	TargetDate json.RawMessage `json:"targetDate"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	Url *string `json:"url"`

	ConvertedFromIssue *listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue `json:"convertedFromIssue"`

	IntegrationsSettings *listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings `json:"integrationsSettings"`

	Creator *listProjectsProjectsProjectConnectionNodesProjectCreatorUser `json:"creator"`

	Lead *listProjectsProjectsProjectConnectionNodesProjectLeadUser `json:"lead"`
}

func (v *listProjectsProjectsProjectConnectionNodesProject) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listProjectsProjectsProjectConnectionNodesProject) __premarshalJSON() (*__premarshallistProjectsProjectsProjectConnectionNodesProject, error) {
	var retval __premarshallistProjectsProjectsProjectConnectionNodesProject

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listProjectsProjectsProjectConnectionNodesProject.ArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.AutoArchivedAt
		src := v.AutoArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listProjectsProjectsProjectConnectionNodesProject.AutoArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CanceledAt
		src := v.CanceledAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listProjectsProjectsProjectConnectionNodesProject.CanceledAt: %w", err)
			}
		}
	}
	retval.Color = v.Color
	{

		dst := &retval.CompletedAt
		src := v.CompletedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listProjectsProjectsProjectConnectionNodesProject.CompletedAt: %w", err)
			}
		}
	}
	retval.CompletedIssueCountHistory = v.CompletedIssueCountHistory
	retval.CompletedScopeHistory = v.CompletedScopeHistory
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listProjectsProjectsProjectConnectionNodesProject.CreatedAt: %w", err)
			}
		}
	}
	retval.Description = v.Description
	retval.Icon = v.Icon
	retval.InProgressScopeHistory = v.InProgressScopeHistory
	retval.IssueCountHistory = v.IssueCountHistory
	retval.Name = v.Name
	retval.Progress = v.Progress
	{

		dst := &retval.ProjectUpdateRemindersPausedUntilAt
		src := v.ProjectUpdateRemindersPausedUntilAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listProjectsProjectsProjectConnectionNodesProject.ProjectUpdateRemindersPausedUntilAt: %w", err)
			}
		}
	}
	retval.Scope = v.Scope
	retval.ScopeHistory = v.ScopeHistory
	retval.SlackIssueComments = v.SlackIssueComments
	retval.SlackIssueStatuses = v.SlackIssueStatuses
	retval.SlackNewIssue = v.SlackNewIssue
	retval.SlugId = v.SlugId
	retval.SortOrder = v.SortOrder
	{

		dst := &retval.StartDate
		src := v.StartDate
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listProjectsProjectsProjectConnectionNodesProject.StartDate: %w", err)
			}
		}
	}
	{

		dst := &retval.StartedAt
		src := v.StartedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listProjectsProjectsProjectConnectionNodesProject.StartedAt: %w", err)
			}
		}
	}
	retval.State = v.State
	{

		dst := &retval.TargetDate
		src := v.TargetDate
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listProjectsProjectsProjectConnectionNodesProject.TargetDate: %w", err)
			}
		}
	}
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listProjectsProjectsProjectConnectionNodesProject.UpdatedAt: %w", err)
			}
		}
	}
	retval.Url = v.Url
	retval.ConvertedFromIssue = v.ConvertedFromIssue
	retval.IntegrationsSettings = v.IntegrationsSettings
	retval.Creator = v.Creator
	retval.Lead = v.Lead
	return &retval, nil
}

// listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue includes the requested fields of the GraphQL type Issue.
// The GraphQL type's documentation follows.
//
// An issue.
type listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The issue's unique number.
	Number *float64 `json:"number"`
	// The issue's title.
	Title *string `json:"title"`
	// The issue's description in markdown format.
	Description *string `json:"description"`
	// The priority of the issue. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low.
	Priority *float64 `json:"priority"`
	// The estimate of the complexity of the issue..
	Estimate *float64 `json:"estimate"`
	// The order of the item in relation to other items in the organization.
	SortOrder *float64 `json:"sortOrder"`
	// The time at which the issue was moved into started state.
	StartedAt *time.Time `json:"-"`
	// The time at which the issue was moved into completed state.
	CompletedAt *time.Time `json:"-"`
	// The time at which the issue was moved into canceled state.
	CanceledAt *time.Time `json:"-"`
	// The time at which the issue was automatically closed by the auto pruning process.
	AutoClosedAt *time.Time `json:"-"`
	// The time at which the issue was automatically archived by the auto pruning process.
	AutoArchivedAt *time.Time `json:"-"`
	// The date at which the issue is due.
	DueDate *time.Time `json:"-"`
	// A flag that indicates whether the issue is in the trash bin.
	Trashed *bool `json:"trashed"`
	// The time until an issue will be snoozed in Triage view.
	SnoozedUntilAt *time.Time `json:"-"`
	// Previous identifiers of the issue if it has been moved between teams.
	PreviousIdentifiers []*string `json:"previousIdentifiers"`
	// The order of the item in the sub-issue list. Only set if the issue has a parent.
	SubIssueSortOrder *float64 `json:"subIssueSortOrder"`
	// Label for the priority.
	PriorityLabel *string `json:"priorityLabel"`
	// Issue's human readable identifier (e.g. ENG-123).
	Identifier *string `json:"identifier"`
	// Issue URL.
	Url *string `json:"url"`
	// Suggested branch name for the issue.
	BranchName *string `json:"branchName"`
	// Returns the number of Attachment resources which are created by customer support ticketing systems (e.g. Zendesk).
	CustomerTicketCount *int `json:"customerTicketCount"`
}

// GetId returns listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.Id, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue) GetId() *string {
	return v.Id
}

// GetCreatedAt returns listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.CreatedAt, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetUpdatedAt returns listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

// GetArchivedAt returns listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetNumber returns listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.Number, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue) GetNumber() *float64 {
	return v.Number
}

// GetTitle returns listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.Title, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue) GetTitle() *string {
	return v.Title
}

// GetDescription returns listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.Description, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue) GetDescription() *string {
	return v.Description
}

// GetPriority returns listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.Priority, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue) GetPriority() *float64 {
	return v.Priority
}

// GetEstimate returns listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.Estimate, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue) GetEstimate() *float64 {
	return v.Estimate
}

// GetSortOrder returns listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.SortOrder, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue) GetSortOrder() *float64 {
	return v.SortOrder
}

// GetStartedAt returns listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.StartedAt, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue) GetStartedAt() *time.Time {
	return v.StartedAt
}

// GetCompletedAt returns listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.CompletedAt, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue) GetCompletedAt() *time.Time {
	return v.CompletedAt
}

// GetCanceledAt returns listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.CanceledAt, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue) GetCanceledAt() *time.Time {
	return v.CanceledAt
}

// GetAutoClosedAt returns listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.AutoClosedAt, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue) GetAutoClosedAt() *time.Time {
	return v.AutoClosedAt
}

// GetAutoArchivedAt returns listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.AutoArchivedAt, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue) GetAutoArchivedAt() *time.Time {
	return v.AutoArchivedAt
}

// GetDueDate returns listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.DueDate, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue) GetDueDate() *time.Time {
	return v.DueDate
}

// GetTrashed returns listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.Trashed, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue) GetTrashed() *bool {
	return v.Trashed
}

// GetSnoozedUntilAt returns listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.SnoozedUntilAt, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue) GetSnoozedUntilAt() *time.Time {
	return v.SnoozedUntilAt
}

// GetPreviousIdentifiers returns listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.PreviousIdentifiers, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue) GetPreviousIdentifiers() []*string {
	return v.PreviousIdentifiers
}

// GetSubIssueSortOrder returns listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.SubIssueSortOrder, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue) GetSubIssueSortOrder() *float64 {
	return v.SubIssueSortOrder
}

// GetPriorityLabel returns listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.PriorityLabel, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue) GetPriorityLabel() *string {
	return v.PriorityLabel
}

// GetIdentifier returns listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.Identifier, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue) GetIdentifier() *string {
	return v.Identifier
}

// GetUrl returns listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.Url, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue) GetUrl() *string {
	return v.Url
}

// GetBranchName returns listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.BranchName, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue) GetBranchName() *string {
	return v.BranchName
}

// GetCustomerTicketCount returns listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.CustomerTicketCount, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue) GetCustomerTicketCount() *int {
	return v.CustomerTicketCount
}

func (v *listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue
		CreatedAt      json.RawMessage `json:"createdAt"`
		UpdatedAt      json.RawMessage `json:"updatedAt"`
		ArchivedAt     json.RawMessage `json:"archivedAt"`
		StartedAt      json.RawMessage `json:"startedAt"`
		CompletedAt    json.RawMessage `json:"completedAt"`
		CanceledAt     json.RawMessage `json:"canceledAt"`
		AutoClosedAt   json.RawMessage `json:"autoClosedAt"`
		AutoArchivedAt json.RawMessage `json:"autoArchivedAt"`
		DueDate        json.RawMessage `json:"dueDate"`
		SnoozedUntilAt json.RawMessage `json:"snoozedUntilAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.UpdatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.StartedAt
		src := firstPass.StartedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.StartedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CompletedAt
		src := firstPass.CompletedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.CompletedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CanceledAt
		src := firstPass.CanceledAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.CanceledAt: %w", err)
			}
		}
	}

	{
		dst := &v.AutoClosedAt
		src := firstPass.AutoClosedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.AutoClosedAt: %w", err)
			}
		}
	}

	{
		dst := &v.AutoArchivedAt
		src := firstPass.AutoArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.AutoArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.DueDate
		src := firstPass.DueDate
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.DueDate: %w", err)
			}
		}
	}

	{
		dst := &v.SnoozedUntilAt
		src := firstPass.SnoozedUntilAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.SnoozedUntilAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue struct {
	Id *string `json:"id"`

	CreatedAt json.RawMessage `json:"createdAt"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	Number *float64 `json:"number"`

	Title *string `json:"title"`

	Description *string `json:"description"`

	Priority *float64 `json:"priority"`

	Estimate *float64 `json:"estimate"`

	SortOrder *float64 `json:"sortOrder"`

	StartedAt json.RawMessage `json:"startedAt"`

	CompletedAt json.RawMessage `json:"completedAt"`

	CanceledAt json.RawMessage `json:"canceledAt"`

	AutoClosedAt json.RawMessage `json:"autoClosedAt"`

	AutoArchivedAt json.RawMessage `json:"autoArchivedAt"`

	DueDate json.RawMessage `json:"dueDate"`

	Trashed *bool `json:"trashed"`

	SnoozedUntilAt json.RawMessage `json:"snoozedUntilAt"`

	PreviousIdentifiers []*string `json:"previousIdentifiers"`

	SubIssueSortOrder *float64 `json:"subIssueSortOrder"`

	PriorityLabel *string `json:"priorityLabel"`

	Identifier *string `json:"identifier"`

	Url *string `json:"url"`

	BranchName *string `json:"branchName"`

	CustomerTicketCount *int `json:"customerTicketCount"`
}

func (v *listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue) __premarshalJSON() (*__premarshallistProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue, error) {
	var retval __premarshallistProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue

	retval.Id = v.Id
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.CreatedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.UpdatedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.ArchivedAt: %w", err)
			}
		}
	}
	retval.Number = v.Number
	retval.Title = v.Title
	retval.Description = v.Description
	retval.Priority = v.Priority
	retval.Estimate = v.Estimate
	retval.SortOrder = v.SortOrder
	{

		dst := &retval.StartedAt
		src := v.StartedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.StartedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CompletedAt
		src := v.CompletedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.CompletedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CanceledAt
		src := v.CanceledAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.CanceledAt: %w", err)
			}
		}
	}
	{

		dst := &retval.AutoClosedAt
		src := v.AutoClosedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.AutoClosedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.AutoArchivedAt
		src := v.AutoArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.AutoArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.DueDate
		src := v.DueDate
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.DueDate: %w", err)
			}
		}
	}
	retval.Trashed = v.Trashed
	{

		dst := &retval.SnoozedUntilAt
		src := v.SnoozedUntilAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listProjectsProjectsProjectConnectionNodesProjectConvertedFromIssue.SnoozedUntilAt: %w", err)
			}
		}
	}
	retval.PreviousIdentifiers = v.PreviousIdentifiers
	retval.SubIssueSortOrder = v.SubIssueSortOrder
	retval.PriorityLabel = v.PriorityLabel
	retval.Identifier = v.Identifier
	retval.Url = v.Url
	retval.BranchName = v.BranchName
	retval.CustomerTicketCount = v.CustomerTicketCount
	return &retval, nil
}

// listProjectsProjectsProjectConnectionNodesProjectCreatorUser includes the requested fields of the GraphQL type User.
// The GraphQL type's documentation follows.
//
// A user that has access to the the resources of an organization.
type listProjectsProjectsProjectConnectionNodesProjectCreatorUser struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// Whether the user account is active or disabled (suspended).
	Active *bool `json:"active"`
	// Whether the user is an organization administrator.
	Admin *bool `json:"admin"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// An URL to the user's avatar image.
	AvatarUrl *string `json:"avatarUrl"`
	// [DEPRECATED] Hash for the user to be used in calendar URLs.
	CalendarHash *string `json:"calendarHash"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Number of issues created.
	CreatedIssueCount *int `json:"createdIssueCount"`
	// A short description of the user, either its title or bio.
	Description *string `json:"description"`
	// Reason why is the account disabled.
	DisableReason *string `json:"disableReason"`
	// The user's display (nick) name. Unique within each organization.
	DisplayName *string `json:"displayName"`
	// The user's email address.
	Email *string `json:"email"`
	// Whether the user is a guest in the workspace and limited to accessing a subset of teams.
	Guest *bool `json:"guest"`
	// Unique hash for the user to be used in invite URLs.
	InviteHash *string `json:"inviteHash"`
	// Whether the user is the currently authenticated user.
	IsMe *bool `json:"isMe"`
	// The last time the user was seen online. If null, the user is currently online.
	LastSeen *time.Time `json:"-"`
	// The user's full name.
	Name *string `json:"name"`
	// The emoji to represent the user current status.
	StatusEmoji *string `json:"statusEmoji"`
	// The label of the user current status.
	StatusLabel *string `json:"statusLabel"`
	// A date at which the user current status should be cleared.
	StatusUntilAt *time.Time `json:"-"`
	// The local timezone of the user.
	Timezone *string `json:"timezone"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// User's profile URL.
	Url *string `json:"url"`
}

// GetId returns listProjectsProjectsProjectConnectionNodesProjectCreatorUser.Id, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectCreatorUser) GetId() *string { return v.Id }

// GetActive returns listProjectsProjectsProjectConnectionNodesProjectCreatorUser.Active, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectCreatorUser) GetActive() *bool {
	return v.Active
}

// GetAdmin returns listProjectsProjectsProjectConnectionNodesProjectCreatorUser.Admin, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectCreatorUser) GetAdmin() *bool {
	return v.Admin
}

// GetArchivedAt returns listProjectsProjectsProjectConnectionNodesProjectCreatorUser.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectCreatorUser) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetAvatarUrl returns listProjectsProjectsProjectConnectionNodesProjectCreatorUser.AvatarUrl, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectCreatorUser) GetAvatarUrl() *string {
	return v.AvatarUrl
}

// GetCalendarHash returns listProjectsProjectsProjectConnectionNodesProjectCreatorUser.CalendarHash, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectCreatorUser) GetCalendarHash() *string {
	return v.CalendarHash
}

// GetCreatedAt returns listProjectsProjectsProjectConnectionNodesProjectCreatorUser.CreatedAt, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectCreatorUser) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetCreatedIssueCount returns listProjectsProjectsProjectConnectionNodesProjectCreatorUser.CreatedIssueCount, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectCreatorUser) GetCreatedIssueCount() *int {
	return v.CreatedIssueCount
}

// GetDescription returns listProjectsProjectsProjectConnectionNodesProjectCreatorUser.Description, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectCreatorUser) GetDescription() *string {
	return v.Description
}

// GetDisableReason returns listProjectsProjectsProjectConnectionNodesProjectCreatorUser.DisableReason, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectCreatorUser) GetDisableReason() *string {
	return v.DisableReason
}

// GetDisplayName returns listProjectsProjectsProjectConnectionNodesProjectCreatorUser.DisplayName, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectCreatorUser) GetDisplayName() *string {
	return v.DisplayName
}

// GetEmail returns listProjectsProjectsProjectConnectionNodesProjectCreatorUser.Email, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectCreatorUser) GetEmail() *string {
	return v.Email
}

// GetGuest returns listProjectsProjectsProjectConnectionNodesProjectCreatorUser.Guest, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectCreatorUser) GetGuest() *bool {
	return v.Guest
}

// GetInviteHash returns listProjectsProjectsProjectConnectionNodesProjectCreatorUser.InviteHash, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectCreatorUser) GetInviteHash() *string {
	return v.InviteHash
}

// GetIsMe returns listProjectsProjectsProjectConnectionNodesProjectCreatorUser.IsMe, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectCreatorUser) GetIsMe() *bool { return v.IsMe }

// GetLastSeen returns listProjectsProjectsProjectConnectionNodesProjectCreatorUser.LastSeen, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectCreatorUser) GetLastSeen() *time.Time {
	return v.LastSeen
}

// GetName returns listProjectsProjectsProjectConnectionNodesProjectCreatorUser.Name, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectCreatorUser) GetName() *string {
	return v.Name
}

// GetStatusEmoji returns listProjectsProjectsProjectConnectionNodesProjectCreatorUser.StatusEmoji, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectCreatorUser) GetStatusEmoji() *string {
	return v.StatusEmoji
}

// GetStatusLabel returns listProjectsProjectsProjectConnectionNodesProjectCreatorUser.StatusLabel, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectCreatorUser) GetStatusLabel() *string {
	return v.StatusLabel
}

// GetStatusUntilAt returns listProjectsProjectsProjectConnectionNodesProjectCreatorUser.StatusUntilAt, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectCreatorUser) GetStatusUntilAt() *time.Time {
	return v.StatusUntilAt
}

// GetTimezone returns listProjectsProjectsProjectConnectionNodesProjectCreatorUser.Timezone, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectCreatorUser) GetTimezone() *string {
	return v.Timezone
}

// GetUpdatedAt returns listProjectsProjectsProjectConnectionNodesProjectCreatorUser.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectCreatorUser) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

// GetUrl returns listProjectsProjectsProjectConnectionNodesProjectCreatorUser.Url, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectCreatorUser) GetUrl() *string { return v.Url }

func (v *listProjectsProjectsProjectConnectionNodesProjectCreatorUser) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listProjectsProjectsProjectConnectionNodesProjectCreatorUser
		ArchivedAt    json.RawMessage `json:"archivedAt"`
		CreatedAt     json.RawMessage `json:"createdAt"`
		LastSeen      json.RawMessage `json:"lastSeen"`
		StatusUntilAt json.RawMessage `json:"statusUntilAt"`
		UpdatedAt     json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listProjectsProjectsProjectConnectionNodesProjectCreatorUser = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listProjectsProjectsProjectConnectionNodesProjectCreatorUser.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listProjectsProjectsProjectConnectionNodesProjectCreatorUser.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.LastSeen
		src := firstPass.LastSeen
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listProjectsProjectsProjectConnectionNodesProjectCreatorUser.LastSeen: %w", err)
			}
		}
	}

	{
		dst := &v.StatusUntilAt
		src := firstPass.StatusUntilAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listProjectsProjectsProjectConnectionNodesProjectCreatorUser.StatusUntilAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listProjectsProjectsProjectConnectionNodesProjectCreatorUser.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistProjectsProjectsProjectConnectionNodesProjectCreatorUser struct {
	Id *string `json:"id"`

	Active *bool `json:"active"`

	Admin *bool `json:"admin"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AvatarUrl *string `json:"avatarUrl"`

	CalendarHash *string `json:"calendarHash"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CreatedIssueCount *int `json:"createdIssueCount"`

	Description *string `json:"description"`

	DisableReason *string `json:"disableReason"`

	DisplayName *string `json:"displayName"`

	Email *string `json:"email"`

	Guest *bool `json:"guest"`

	InviteHash *string `json:"inviteHash"`

	IsMe *bool `json:"isMe"`

	LastSeen json.RawMessage `json:"lastSeen"`

	Name *string `json:"name"`

	StatusEmoji *string `json:"statusEmoji"`

	StatusLabel *string `json:"statusLabel"`

	StatusUntilAt json.RawMessage `json:"statusUntilAt"`

	Timezone *string `json:"timezone"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	Url *string `json:"url"`
}

func (v *listProjectsProjectsProjectConnectionNodesProjectCreatorUser) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listProjectsProjectsProjectConnectionNodesProjectCreatorUser) __premarshalJSON() (*__premarshallistProjectsProjectsProjectConnectionNodesProjectCreatorUser, error) {
	var retval __premarshallistProjectsProjectsProjectConnectionNodesProjectCreatorUser

	retval.Id = v.Id
	retval.Active = v.Active
	retval.Admin = v.Admin
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listProjectsProjectsProjectConnectionNodesProjectCreatorUser.ArchivedAt: %w", err)
			}
		}
	}
	retval.AvatarUrl = v.AvatarUrl
	retval.CalendarHash = v.CalendarHash
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listProjectsProjectsProjectConnectionNodesProjectCreatorUser.CreatedAt: %w", err)
			}
		}
	}
	retval.CreatedIssueCount = v.CreatedIssueCount
	retval.Description = v.Description
	retval.DisableReason = v.DisableReason
	retval.DisplayName = v.DisplayName
	retval.Email = v.Email
	retval.Guest = v.Guest
	retval.InviteHash = v.InviteHash
	retval.IsMe = v.IsMe
	{

		dst := &retval.LastSeen
		src := v.LastSeen
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listProjectsProjectsProjectConnectionNodesProjectCreatorUser.LastSeen: %w", err)
			}
		}
	}
	retval.Name = v.Name
	retval.StatusEmoji = v.StatusEmoji
	retval.StatusLabel = v.StatusLabel
	{

		dst := &retval.StatusUntilAt
		src := v.StatusUntilAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listProjectsProjectsProjectConnectionNodesProjectCreatorUser.StatusUntilAt: %w", err)
			}
		}
	}
	retval.Timezone = v.Timezone
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listProjectsProjectsProjectConnectionNodesProjectCreatorUser.UpdatedAt: %w", err)
			}
		}
	}
	retval.Url = v.Url
	return &retval, nil
}

// listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings includes the requested fields of the GraphQL type IntegrationsSettings.
// The GraphQL type's documentation follows.
//
// The configuration of all integrations for a project or a team.
type listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Whether to send a Slack message when a new issue is added to triage.
	SlackIssueAddedToTriage *bool `json:"slackIssueAddedToTriage"`
	// Whether to send a Slack message when a new issue is created for the project or the team.
	SlackIssueCreated *bool `json:"slackIssueCreated"`
	// Whether to send a Slack message when a comment is created on any of the project or team's issues.
	SlackIssueNewComment *bool `json:"slackIssueNewComment"`
	// Whether to send a Slack message when an SLA is breached
	SlackIssueSlaBreached *bool `json:"slackIssueSlaBreached"`
	// Whether to send a Slack message when an SLA is at high risk
	SlackIssueSlaHighRisk *bool `json:"slackIssueSlaHighRisk"`
	// Whether to send a Slack message when any of the project or team's issues has a change in status.
	SlackIssueStatusChangedAll *bool `json:"slackIssueStatusChangedAll"`
	// Whether to send a Slack message when any of the project or team's issues change to completed or cancelled.
	SlackIssueStatusChangedDone *bool `json:"slackIssueStatusChangedDone"`
	// Whether to send a Slack message when a project update is created.
	SlackProjectUpdateCreated *bool `json:"slackProjectUpdateCreated"`
	// Whether to send a new project update to team Slack channels.
	SlackProjectUpdateCreatedToTeam *bool `json:"slackProjectUpdateCreatedToTeam"`
	// Whether to send a new project update to workspace Slack channel.
	SlackProjectUpdateCreatedToWorkspace *bool `json:"slackProjectUpdateCreatedToWorkspace"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
}

// GetId returns listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings.Id, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings) GetId() *string {
	return v.Id
}

// GetArchivedAt returns listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetCreatedAt returns listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings.CreatedAt, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetSlackIssueAddedToTriage returns listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings.SlackIssueAddedToTriage, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings) GetSlackIssueAddedToTriage() *bool {
	return v.SlackIssueAddedToTriage
}

// GetSlackIssueCreated returns listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings.SlackIssueCreated, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings) GetSlackIssueCreated() *bool {
	return v.SlackIssueCreated
}

// GetSlackIssueNewComment returns listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings.SlackIssueNewComment, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings) GetSlackIssueNewComment() *bool {
	return v.SlackIssueNewComment
}

// GetSlackIssueSlaBreached returns listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings.SlackIssueSlaBreached, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings) GetSlackIssueSlaBreached() *bool {
	return v.SlackIssueSlaBreached
}

// GetSlackIssueSlaHighRisk returns listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings.SlackIssueSlaHighRisk, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings) GetSlackIssueSlaHighRisk() *bool {
	return v.SlackIssueSlaHighRisk
}

// GetSlackIssueStatusChangedAll returns listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings.SlackIssueStatusChangedAll, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings) GetSlackIssueStatusChangedAll() *bool {
	return v.SlackIssueStatusChangedAll
}

// GetSlackIssueStatusChangedDone returns listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings.SlackIssueStatusChangedDone, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings) GetSlackIssueStatusChangedDone() *bool {
	return v.SlackIssueStatusChangedDone
}

// GetSlackProjectUpdateCreated returns listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings.SlackProjectUpdateCreated, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings) GetSlackProjectUpdateCreated() *bool {
	return v.SlackProjectUpdateCreated
}

// GetSlackProjectUpdateCreatedToTeam returns listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings.SlackProjectUpdateCreatedToTeam, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings) GetSlackProjectUpdateCreatedToTeam() *bool {
	return v.SlackProjectUpdateCreatedToTeam
}

// GetSlackProjectUpdateCreatedToWorkspace returns listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings.SlackProjectUpdateCreatedToWorkspace, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings) GetSlackProjectUpdateCreatedToWorkspace() *bool {
	return v.SlackProjectUpdateCreatedToWorkspace
}

// GetUpdatedAt returns listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

func (v *listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	CreatedAt json.RawMessage `json:"createdAt"`

	SlackIssueAddedToTriage *bool `json:"slackIssueAddedToTriage"`

	SlackIssueCreated *bool `json:"slackIssueCreated"`

	SlackIssueNewComment *bool `json:"slackIssueNewComment"`

	SlackIssueSlaBreached *bool `json:"slackIssueSlaBreached"`

	SlackIssueSlaHighRisk *bool `json:"slackIssueSlaHighRisk"`

	SlackIssueStatusChangedAll *bool `json:"slackIssueStatusChangedAll"`

	SlackIssueStatusChangedDone *bool `json:"slackIssueStatusChangedDone"`

	SlackProjectUpdateCreated *bool `json:"slackProjectUpdateCreated"`

	SlackProjectUpdateCreatedToTeam *bool `json:"slackProjectUpdateCreatedToTeam"`

	SlackProjectUpdateCreatedToWorkspace *bool `json:"slackProjectUpdateCreatedToWorkspace"`

	UpdatedAt json.RawMessage `json:"updatedAt"`
}

func (v *listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings) __premarshalJSON() (*__premarshallistProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings, error) {
	var retval __premarshallistProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings.ArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings.CreatedAt: %w", err)
			}
		}
	}
	retval.SlackIssueAddedToTriage = v.SlackIssueAddedToTriage
	retval.SlackIssueCreated = v.SlackIssueCreated
	retval.SlackIssueNewComment = v.SlackIssueNewComment
	retval.SlackIssueSlaBreached = v.SlackIssueSlaBreached
	retval.SlackIssueSlaHighRisk = v.SlackIssueSlaHighRisk
	retval.SlackIssueStatusChangedAll = v.SlackIssueStatusChangedAll
	retval.SlackIssueStatusChangedDone = v.SlackIssueStatusChangedDone
	retval.SlackProjectUpdateCreated = v.SlackProjectUpdateCreated
	retval.SlackProjectUpdateCreatedToTeam = v.SlackProjectUpdateCreatedToTeam
	retval.SlackProjectUpdateCreatedToWorkspace = v.SlackProjectUpdateCreatedToWorkspace
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listProjectsProjectsProjectConnectionNodesProjectIntegrationsSettings.UpdatedAt: %w", err)
			}
		}
	}
	return &retval, nil
}

// listProjectsProjectsProjectConnectionNodesProjectLeadUser includes the requested fields of the GraphQL type User.
// The GraphQL type's documentation follows.
//
// A user that has access to the the resources of an organization.
type listProjectsProjectsProjectConnectionNodesProjectLeadUser struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// Whether the user account is active or disabled (suspended).
	Active *bool `json:"active"`
	// Whether the user is an organization administrator.
	Admin *bool `json:"admin"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// An URL to the user's avatar image.
	AvatarUrl *string `json:"avatarUrl"`
	// [DEPRECATED] Hash for the user to be used in calendar URLs.
	CalendarHash *string `json:"calendarHash"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Number of issues created.
	CreatedIssueCount *int `json:"createdIssueCount"`
	// A short description of the user, either its title or bio.
	Description *string `json:"description"`
	// Reason why is the account disabled.
	DisableReason *string `json:"disableReason"`
	// The user's display (nick) name. Unique within each organization.
	DisplayName *string `json:"displayName"`
	// The user's email address.
	Email *string `json:"email"`
	// Whether the user is a guest in the workspace and limited to accessing a subset of teams.
	Guest *bool `json:"guest"`
	// Unique hash for the user to be used in invite URLs.
	InviteHash *string `json:"inviteHash"`
	// Whether the user is the currently authenticated user.
	IsMe *bool `json:"isMe"`
	// The last time the user was seen online. If null, the user is currently online.
	LastSeen *time.Time `json:"-"`
	// The user's full name.
	Name *string `json:"name"`
	// The emoji to represent the user current status.
	StatusEmoji *string `json:"statusEmoji"`
	// The label of the user current status.
	StatusLabel *string `json:"statusLabel"`
	// A date at which the user current status should be cleared.
	StatusUntilAt *time.Time `json:"-"`
	// The local timezone of the user.
	Timezone *string `json:"timezone"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// User's profile URL.
	Url *string `json:"url"`
}

// GetId returns listProjectsProjectsProjectConnectionNodesProjectLeadUser.Id, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectLeadUser) GetId() *string { return v.Id }

// GetActive returns listProjectsProjectsProjectConnectionNodesProjectLeadUser.Active, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectLeadUser) GetActive() *bool {
	return v.Active
}

// GetAdmin returns listProjectsProjectsProjectConnectionNodesProjectLeadUser.Admin, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectLeadUser) GetAdmin() *bool { return v.Admin }

// GetArchivedAt returns listProjectsProjectsProjectConnectionNodesProjectLeadUser.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectLeadUser) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetAvatarUrl returns listProjectsProjectsProjectConnectionNodesProjectLeadUser.AvatarUrl, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectLeadUser) GetAvatarUrl() *string {
	return v.AvatarUrl
}

// GetCalendarHash returns listProjectsProjectsProjectConnectionNodesProjectLeadUser.CalendarHash, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectLeadUser) GetCalendarHash() *string {
	return v.CalendarHash
}

// GetCreatedAt returns listProjectsProjectsProjectConnectionNodesProjectLeadUser.CreatedAt, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectLeadUser) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetCreatedIssueCount returns listProjectsProjectsProjectConnectionNodesProjectLeadUser.CreatedIssueCount, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectLeadUser) GetCreatedIssueCount() *int {
	return v.CreatedIssueCount
}

// GetDescription returns listProjectsProjectsProjectConnectionNodesProjectLeadUser.Description, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectLeadUser) GetDescription() *string {
	return v.Description
}

// GetDisableReason returns listProjectsProjectsProjectConnectionNodesProjectLeadUser.DisableReason, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectLeadUser) GetDisableReason() *string {
	return v.DisableReason
}

// GetDisplayName returns listProjectsProjectsProjectConnectionNodesProjectLeadUser.DisplayName, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectLeadUser) GetDisplayName() *string {
	return v.DisplayName
}

// GetEmail returns listProjectsProjectsProjectConnectionNodesProjectLeadUser.Email, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectLeadUser) GetEmail() *string {
	return v.Email
}

// GetGuest returns listProjectsProjectsProjectConnectionNodesProjectLeadUser.Guest, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectLeadUser) GetGuest() *bool { return v.Guest }

// GetInviteHash returns listProjectsProjectsProjectConnectionNodesProjectLeadUser.InviteHash, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectLeadUser) GetInviteHash() *string {
	return v.InviteHash
}

// GetIsMe returns listProjectsProjectsProjectConnectionNodesProjectLeadUser.IsMe, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectLeadUser) GetIsMe() *bool { return v.IsMe }

// GetLastSeen returns listProjectsProjectsProjectConnectionNodesProjectLeadUser.LastSeen, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectLeadUser) GetLastSeen() *time.Time {
	return v.LastSeen
}

// GetName returns listProjectsProjectsProjectConnectionNodesProjectLeadUser.Name, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectLeadUser) GetName() *string { return v.Name }

// GetStatusEmoji returns listProjectsProjectsProjectConnectionNodesProjectLeadUser.StatusEmoji, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectLeadUser) GetStatusEmoji() *string {
	return v.StatusEmoji
}

// GetStatusLabel returns listProjectsProjectsProjectConnectionNodesProjectLeadUser.StatusLabel, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectLeadUser) GetStatusLabel() *string {
	return v.StatusLabel
}

// GetStatusUntilAt returns listProjectsProjectsProjectConnectionNodesProjectLeadUser.StatusUntilAt, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectLeadUser) GetStatusUntilAt() *time.Time {
	return v.StatusUntilAt
}

// GetTimezone returns listProjectsProjectsProjectConnectionNodesProjectLeadUser.Timezone, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectLeadUser) GetTimezone() *string {
	return v.Timezone
}

// GetUpdatedAt returns listProjectsProjectsProjectConnectionNodesProjectLeadUser.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectLeadUser) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

// GetUrl returns listProjectsProjectsProjectConnectionNodesProjectLeadUser.Url, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionNodesProjectLeadUser) GetUrl() *string { return v.Url }

func (v *listProjectsProjectsProjectConnectionNodesProjectLeadUser) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listProjectsProjectsProjectConnectionNodesProjectLeadUser
		ArchivedAt    json.RawMessage `json:"archivedAt"`
		CreatedAt     json.RawMessage `json:"createdAt"`
		LastSeen      json.RawMessage `json:"lastSeen"`
		StatusUntilAt json.RawMessage `json:"statusUntilAt"`
		UpdatedAt     json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listProjectsProjectsProjectConnectionNodesProjectLeadUser = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listProjectsProjectsProjectConnectionNodesProjectLeadUser.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listProjectsProjectsProjectConnectionNodesProjectLeadUser.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.LastSeen
		src := firstPass.LastSeen
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listProjectsProjectsProjectConnectionNodesProjectLeadUser.LastSeen: %w", err)
			}
		}
	}

	{
		dst := &v.StatusUntilAt
		src := firstPass.StatusUntilAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listProjectsProjectsProjectConnectionNodesProjectLeadUser.StatusUntilAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listProjectsProjectsProjectConnectionNodesProjectLeadUser.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistProjectsProjectsProjectConnectionNodesProjectLeadUser struct {
	Id *string `json:"id"`

	Active *bool `json:"active"`

	Admin *bool `json:"admin"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AvatarUrl *string `json:"avatarUrl"`

	CalendarHash *string `json:"calendarHash"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CreatedIssueCount *int `json:"createdIssueCount"`

	Description *string `json:"description"`

	DisableReason *string `json:"disableReason"`

	DisplayName *string `json:"displayName"`

	Email *string `json:"email"`

	Guest *bool `json:"guest"`

	InviteHash *string `json:"inviteHash"`

	IsMe *bool `json:"isMe"`

	LastSeen json.RawMessage `json:"lastSeen"`

	Name *string `json:"name"`

	StatusEmoji *string `json:"statusEmoji"`

	StatusLabel *string `json:"statusLabel"`

	StatusUntilAt json.RawMessage `json:"statusUntilAt"`

	Timezone *string `json:"timezone"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	Url *string `json:"url"`
}

func (v *listProjectsProjectsProjectConnectionNodesProjectLeadUser) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listProjectsProjectsProjectConnectionNodesProjectLeadUser) __premarshalJSON() (*__premarshallistProjectsProjectsProjectConnectionNodesProjectLeadUser, error) {
	var retval __premarshallistProjectsProjectsProjectConnectionNodesProjectLeadUser

	retval.Id = v.Id
	retval.Active = v.Active
	retval.Admin = v.Admin
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listProjectsProjectsProjectConnectionNodesProjectLeadUser.ArchivedAt: %w", err)
			}
		}
	}
	retval.AvatarUrl = v.AvatarUrl
	retval.CalendarHash = v.CalendarHash
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listProjectsProjectsProjectConnectionNodesProjectLeadUser.CreatedAt: %w", err)
			}
		}
	}
	retval.CreatedIssueCount = v.CreatedIssueCount
	retval.Description = v.Description
	retval.DisableReason = v.DisableReason
	retval.DisplayName = v.DisplayName
	retval.Email = v.Email
	retval.Guest = v.Guest
	retval.InviteHash = v.InviteHash
	retval.IsMe = v.IsMe
	{

		dst := &retval.LastSeen
		src := v.LastSeen
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listProjectsProjectsProjectConnectionNodesProjectLeadUser.LastSeen: %w", err)
			}
		}
	}
	retval.Name = v.Name
	retval.StatusEmoji = v.StatusEmoji
	retval.StatusLabel = v.StatusLabel
	{

		dst := &retval.StatusUntilAt
		src := v.StatusUntilAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listProjectsProjectsProjectConnectionNodesProjectLeadUser.StatusUntilAt: %w", err)
			}
		}
	}
	retval.Timezone = v.Timezone
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listProjectsProjectsProjectConnectionNodesProjectLeadUser.UpdatedAt: %w", err)
			}
		}
	}
	retval.Url = v.Url
	return &retval, nil
}

// listProjectsProjectsProjectConnectionPageInfo includes the requested fields of the GraphQL type PageInfo.
type listProjectsProjectsProjectConnectionPageInfo struct {
	// Indicates if there are more results when paginating forward.
	HasNextPage *bool `json:"hasNextPage"`
	// Cursor representing the last result in the paginated results.
	EndCursor *string `json:"endCursor"`
}

// GetHasNextPage returns listProjectsProjectsProjectConnectionPageInfo.HasNextPage, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionPageInfo) GetHasNextPage() *bool { return v.HasNextPage }

// GetEndCursor returns listProjectsProjectsProjectConnectionPageInfo.EndCursor, and is useful for accessing the field via an interface.
func (v *listProjectsProjectsProjectConnectionPageInfo) GetEndCursor() *string { return v.EndCursor }

// listProjectsResponse is returned by listProjects on success.
type listProjectsResponse struct {
	// All projects.
	Projects *listProjectsProjectsProjectConnection `json:"projects"`
}

// GetProjects returns listProjectsResponse.Projects, and is useful for accessing the field via an interface.
func (v *listProjectsResponse) GetProjects() *listProjectsProjectsProjectConnection {
	return v.Projects
}

// listTeamMembershipsResponse is returned by listTeamMemberships on success.
type listTeamMembershipsResponse struct {
	// All team memberships.
	TeamMemberships *listTeamMembershipsTeamMembershipsTeamMembershipConnection `json:"teamMemberships"`
}

// GetTeamMemberships returns listTeamMembershipsResponse.TeamMemberships, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsResponse) GetTeamMemberships() *listTeamMembershipsTeamMembershipsTeamMembershipConnection {
	return v.TeamMemberships
}

// listTeamMembershipsTeamMembershipsTeamMembershipConnection includes the requested fields of the GraphQL type TeamMembershipConnection.
type listTeamMembershipsTeamMembershipsTeamMembershipConnection struct {
	PageInfo *listTeamMembershipsTeamMembershipsTeamMembershipConnectionPageInfo              `json:"pageInfo"`
	Nodes    []*listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembership `json:"nodes"`
}

// GetPageInfo returns listTeamMembershipsTeamMembershipsTeamMembershipConnection.PageInfo, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnection) GetPageInfo() *listTeamMembershipsTeamMembershipsTeamMembershipConnectionPageInfo {
	return v.PageInfo
}

// GetNodes returns listTeamMembershipsTeamMembershipsTeamMembershipConnection.Nodes, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnection) GetNodes() []*listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembership {
	return v.Nodes
}

// listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembership includes the requested fields of the GraphQL type TeamMembership.
// The GraphQL type's documentation follows.
//
// Defines the membership of a user to a team.
type listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembership struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Whether the user is the owner of the team
	Owner *bool `json:"owner"`
	// The order of the item in the users team list.
	SortOrder *float64 `json:"sortOrder"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// The team that the membership is associated with.
	Team *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam `json:"team"`
	// The user that the membership is associated with.
	User *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser `json:"user"`
}

// GetId returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembership.Id, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembership) GetId() *string {
	return v.Id
}

// GetArchivedAt returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembership.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembership) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetCreatedAt returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembership.CreatedAt, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembership) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetOwner returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembership.Owner, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembership) GetOwner() *bool {
	return v.Owner
}

// GetSortOrder returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembership.SortOrder, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembership) GetSortOrder() *float64 {
	return v.SortOrder
}

// GetUpdatedAt returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembership.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembership) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

// GetTeam returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembership.Team, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembership) GetTeam() *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam {
	return v.Team
}

// GetUser returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembership.User, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembership) GetUser() *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser {
	return v.User
}

func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembership) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembership
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembership = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembership.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembership.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembership.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembership struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	CreatedAt json.RawMessage `json:"createdAt"`

	Owner *bool `json:"owner"`

	SortOrder *float64 `json:"sortOrder"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	Team *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam `json:"team"`

	User *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser `json:"user"`
}

func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembership) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembership) __premarshalJSON() (*__premarshallistTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembership, error) {
	var retval __premarshallistTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembership

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembership.ArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembership.CreatedAt: %w", err)
			}
		}
	}
	retval.Owner = v.Owner
	retval.SortOrder = v.SortOrder
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembership.UpdatedAt: %w", err)
			}
		}
	}
	retval.Team = v.Team
	retval.User = v.User
	return &retval, nil
}

// listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam includes the requested fields of the GraphQL type Team.
// The GraphQL type's documentation follows.
//
// An organizational unit that contains issues.
type listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// Period after which automatically closed and completed issues are automatically archived in months.
	AutoArchivePeriod *float64 `json:"autoArchivePeriod"`
	// Period after which issues are automatically closed in months. Null/undefined means disabled.
	AutoClosePeriod *float64 `json:"autoClosePeriod"`
	// The canceled workflow state which auto closed issues will be set to. Defaults to the first canceled state.
	AutoCloseStateId *string `json:"autoCloseStateId"`
	// The team's color.
	Color *string `json:"color"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Calendar feed URL (iCal) for cycles.
	CycleCalenderUrl *string `json:"cycleCalenderUrl"`
	// The cooldown time after each cycle in weeks.
	CycleCooldownTime *float64 `json:"cycleCooldownTime"`
	// The duration of a cycle in weeks.
	CycleDuration *float64 `json:"cycleDuration"`
	// Auto assign completed issues to current cycle.
	CycleIssueAutoAssignCompleted *bool `json:"cycleIssueAutoAssignCompleted"`
	// Auto assign started issues to current cycle.
	CycleIssueAutoAssignStarted *bool `json:"cycleIssueAutoAssignStarted"`
	// Only allow issues issues with cycles in Active Issues.
	CycleLockToActive *bool `json:"cycleLockToActive"`
	// The day of the week that a new cycle starts.
	CycleStartDay *float64 `json:"cycleStartDay"`
	// Whether the team uses cycles.
	CyclesEnabled *bool `json:"cyclesEnabled"`
	// What to use as an default estimate for unestimated issues.
	DefaultIssueEstimate *float64 `json:"defaultIssueEstimate"`
	// The id of the default template to use for new issues created by members of the team.
	DefaultTemplateForMembersId *string `json:"defaultTemplateForMembersId"`
	// The id of the default template to use for new issues created by non-members of the team.
	DefaultTemplateForNonMembersId *string `json:"defaultTemplateForNonMembersId"`
	// The team's description.
	Description *string `json:"description"`
	// Whether to group recent issue history entries.
	GroupIssueHistory *bool `json:"groupIssueHistory"`
	// The icon of the team.
	Icon *string `json:"icon"`
	// Unique hash for the team to be used in invite URLs.
	InviteHash *string `json:"inviteHash"`
	// Whether to allow zeros in issues estimates.
	IssueEstimationAllowZero *bool `json:"issueEstimationAllowZero"`
	// Whether to add additional points to the estimate scale.
	IssueEstimationExtended *bool `json:"issueEstimationExtended"`
	// The issue estimation type to use.
	IssueEstimationType *string `json:"issueEstimationType"`
	// Whether issues without priority should be sorted first.
	IssueOrderingNoPriorityFirst *bool `json:"issueOrderingNoPriorityFirst"`
	// Whether to move issues to bottom of the column when changing state.
	IssueSortOrderDefaultToBottom *bool `json:"issueSortOrderDefaultToBottom"`
	// The team's unique key. The key is used in URLs.
	Key *string `json:"key"`
	// The team's name.
	Name *string `json:"name"`
	// Whether the team is private or not.
	Private *bool `json:"private"`
	// Whether an issue needs to have a priority set before leaving triage
	RequirePriorityToLeaveTriage *bool `json:"requirePriorityToLeaveTriage"`
	// Whether to send new issue comment notifications to Slack.
	SlackIssueComments *bool `json:"slackIssueComments"`
	// Whether to send new issue status updates to Slack.
	SlackIssueStatuses *bool `json:"slackIssueStatuses"`
	// Whether to send new issue notifications to Slack.
	SlackNewIssue *bool `json:"slackNewIssue"`
	// The timezone of the team. Defaults to "America/Los_Angeles"
	Timezone *string `json:"timezone"`
	// Whether triage mode is enabled for the team or not.
	TriageEnabled *bool `json:"triageEnabled"`
	// How many upcoming cycles to create.
	UpcomingCycleCount *float64 `json:"upcomingCycleCount"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
}

// GetId returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.Id, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) GetId() *string {
	return v.Id
}

// GetArchivedAt returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetAutoArchivePeriod returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.AutoArchivePeriod, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) GetAutoArchivePeriod() *float64 {
	return v.AutoArchivePeriod
}

// GetAutoClosePeriod returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.AutoClosePeriod, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) GetAutoClosePeriod() *float64 {
	return v.AutoClosePeriod
}

// GetAutoCloseStateId returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.AutoCloseStateId, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) GetAutoCloseStateId() *string {
	return v.AutoCloseStateId
}

// GetColor returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.Color, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) GetColor() *string {
	return v.Color
}

// GetCreatedAt returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.CreatedAt, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetCycleCalenderUrl returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.CycleCalenderUrl, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) GetCycleCalenderUrl() *string {
	return v.CycleCalenderUrl
}

// GetCycleCooldownTime returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.CycleCooldownTime, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) GetCycleCooldownTime() *float64 {
	return v.CycleCooldownTime
}

// GetCycleDuration returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.CycleDuration, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) GetCycleDuration() *float64 {
	return v.CycleDuration
}

// GetCycleIssueAutoAssignCompleted returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.CycleIssueAutoAssignCompleted, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) GetCycleIssueAutoAssignCompleted() *bool {
	return v.CycleIssueAutoAssignCompleted
}

// GetCycleIssueAutoAssignStarted returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.CycleIssueAutoAssignStarted, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) GetCycleIssueAutoAssignStarted() *bool {
	return v.CycleIssueAutoAssignStarted
}

// GetCycleLockToActive returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.CycleLockToActive, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) GetCycleLockToActive() *bool {
	return v.CycleLockToActive
}

// GetCycleStartDay returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.CycleStartDay, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) GetCycleStartDay() *float64 {
	return v.CycleStartDay
}

// GetCyclesEnabled returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.CyclesEnabled, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) GetCyclesEnabled() *bool {
	return v.CyclesEnabled
}

// GetDefaultIssueEstimate returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.DefaultIssueEstimate, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) GetDefaultIssueEstimate() *float64 {
	return v.DefaultIssueEstimate
}

// GetDefaultTemplateForMembersId returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.DefaultTemplateForMembersId, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) GetDefaultTemplateForMembersId() *string {
	return v.DefaultTemplateForMembersId
}

// GetDefaultTemplateForNonMembersId returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.DefaultTemplateForNonMembersId, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) GetDefaultTemplateForNonMembersId() *string {
	return v.DefaultTemplateForNonMembersId
}

// GetDescription returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.Description, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) GetDescription() *string {
	return v.Description
}

// GetGroupIssueHistory returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.GroupIssueHistory, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) GetGroupIssueHistory() *bool {
	return v.GroupIssueHistory
}

// GetIcon returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.Icon, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) GetIcon() *string {
	return v.Icon
}

// GetInviteHash returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.InviteHash, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) GetInviteHash() *string {
	return v.InviteHash
}

// GetIssueEstimationAllowZero returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.IssueEstimationAllowZero, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) GetIssueEstimationAllowZero() *bool {
	return v.IssueEstimationAllowZero
}

// GetIssueEstimationExtended returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.IssueEstimationExtended, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) GetIssueEstimationExtended() *bool {
	return v.IssueEstimationExtended
}

// GetIssueEstimationType returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.IssueEstimationType, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) GetIssueEstimationType() *string {
	return v.IssueEstimationType
}

// GetIssueOrderingNoPriorityFirst returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.IssueOrderingNoPriorityFirst, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) GetIssueOrderingNoPriorityFirst() *bool {
	return v.IssueOrderingNoPriorityFirst
}

// GetIssueSortOrderDefaultToBottom returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.IssueSortOrderDefaultToBottom, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) GetIssueSortOrderDefaultToBottom() *bool {
	return v.IssueSortOrderDefaultToBottom
}

// GetKey returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.Key, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) GetKey() *string {
	return v.Key
}

// GetName returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.Name, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) GetName() *string {
	return v.Name
}

// GetPrivate returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.Private, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) GetPrivate() *bool {
	return v.Private
}

// GetRequirePriorityToLeaveTriage returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.RequirePriorityToLeaveTriage, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) GetRequirePriorityToLeaveTriage() *bool {
	return v.RequirePriorityToLeaveTriage
}

// GetSlackIssueComments returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.SlackIssueComments, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) GetSlackIssueComments() *bool {
	return v.SlackIssueComments
}

// GetSlackIssueStatuses returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.SlackIssueStatuses, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) GetSlackIssueStatuses() *bool {
	return v.SlackIssueStatuses
}

// GetSlackNewIssue returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.SlackNewIssue, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) GetSlackNewIssue() *bool {
	return v.SlackNewIssue
}

// GetTimezone returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.Timezone, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) GetTimezone() *string {
	return v.Timezone
}

// GetTriageEnabled returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.TriageEnabled, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) GetTriageEnabled() *bool {
	return v.TriageEnabled
}

// GetUpcomingCycleCount returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.UpcomingCycleCount, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) GetUpcomingCycleCount() *float64 {
	return v.UpcomingCycleCount
}

// GetUpdatedAt returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AutoArchivePeriod *float64 `json:"autoArchivePeriod"`

	AutoClosePeriod *float64 `json:"autoClosePeriod"`

	AutoCloseStateId *string `json:"autoCloseStateId"`

	Color *string `json:"color"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CycleCalenderUrl *string `json:"cycleCalenderUrl"`

	CycleCooldownTime *float64 `json:"cycleCooldownTime"`

	CycleDuration *float64 `json:"cycleDuration"`

	CycleIssueAutoAssignCompleted *bool `json:"cycleIssueAutoAssignCompleted"`

	CycleIssueAutoAssignStarted *bool `json:"cycleIssueAutoAssignStarted"`

	CycleLockToActive *bool `json:"cycleLockToActive"`

	CycleStartDay *float64 `json:"cycleStartDay"`

	CyclesEnabled *bool `json:"cyclesEnabled"`

	DefaultIssueEstimate *float64 `json:"defaultIssueEstimate"`

	DefaultTemplateForMembersId *string `json:"defaultTemplateForMembersId"`

	DefaultTemplateForNonMembersId *string `json:"defaultTemplateForNonMembersId"`

	Description *string `json:"description"`

	GroupIssueHistory *bool `json:"groupIssueHistory"`

	Icon *string `json:"icon"`

	InviteHash *string `json:"inviteHash"`

	IssueEstimationAllowZero *bool `json:"issueEstimationAllowZero"`

	IssueEstimationExtended *bool `json:"issueEstimationExtended"`

	IssueEstimationType *string `json:"issueEstimationType"`

	IssueOrderingNoPriorityFirst *bool `json:"issueOrderingNoPriorityFirst"`

	IssueSortOrderDefaultToBottom *bool `json:"issueSortOrderDefaultToBottom"`

	Key *string `json:"key"`

	Name *string `json:"name"`

	Private *bool `json:"private"`

	RequirePriorityToLeaveTriage *bool `json:"requirePriorityToLeaveTriage"`

	SlackIssueComments *bool `json:"slackIssueComments"`

	SlackIssueStatuses *bool `json:"slackIssueStatuses"`

	SlackNewIssue *bool `json:"slackNewIssue"`

	Timezone *string `json:"timezone"`

	TriageEnabled *bool `json:"triageEnabled"`

	UpcomingCycleCount *float64 `json:"upcomingCycleCount"`

	UpdatedAt json.RawMessage `json:"updatedAt"`
}

func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam) __premarshalJSON() (*__premarshallistTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam, error) {
	var retval __premarshallistTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.ArchivedAt: %w", err)
			}
		}
	}
	retval.AutoArchivePeriod = v.AutoArchivePeriod
	retval.AutoClosePeriod = v.AutoClosePeriod
	retval.AutoCloseStateId = v.AutoCloseStateId
	retval.Color = v.Color
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.CreatedAt: %w", err)
			}
		}
	}
	retval.CycleCalenderUrl = v.CycleCalenderUrl
	retval.CycleCooldownTime = v.CycleCooldownTime
	retval.CycleDuration = v.CycleDuration
	retval.CycleIssueAutoAssignCompleted = v.CycleIssueAutoAssignCompleted
	retval.CycleIssueAutoAssignStarted = v.CycleIssueAutoAssignStarted
	retval.CycleLockToActive = v.CycleLockToActive
	retval.CycleStartDay = v.CycleStartDay
	retval.CyclesEnabled = v.CyclesEnabled
	retval.DefaultIssueEstimate = v.DefaultIssueEstimate
	retval.DefaultTemplateForMembersId = v.DefaultTemplateForMembersId
	retval.DefaultTemplateForNonMembersId = v.DefaultTemplateForNonMembersId
	retval.Description = v.Description
	retval.GroupIssueHistory = v.GroupIssueHistory
	retval.Icon = v.Icon
	retval.InviteHash = v.InviteHash
	retval.IssueEstimationAllowZero = v.IssueEstimationAllowZero
	retval.IssueEstimationExtended = v.IssueEstimationExtended
	retval.IssueEstimationType = v.IssueEstimationType
	retval.IssueOrderingNoPriorityFirst = v.IssueOrderingNoPriorityFirst
	retval.IssueSortOrderDefaultToBottom = v.IssueSortOrderDefaultToBottom
	retval.Key = v.Key
	retval.Name = v.Name
	retval.Private = v.Private
	retval.RequirePriorityToLeaveTriage = v.RequirePriorityToLeaveTriage
	retval.SlackIssueComments = v.SlackIssueComments
	retval.SlackIssueStatuses = v.SlackIssueStatuses
	retval.SlackNewIssue = v.SlackNewIssue
	retval.Timezone = v.Timezone
	retval.TriageEnabled = v.TriageEnabled
	retval.UpcomingCycleCount = v.UpcomingCycleCount
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipTeam.UpdatedAt: %w", err)
			}
		}
	}
	return &retval, nil
}

// listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser includes the requested fields of the GraphQL type User.
// The GraphQL type's documentation follows.
//
// A user that has access to the the resources of an organization.
type listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// Whether the user account is active or disabled (suspended).
	Active *bool `json:"active"`
	// Whether the user is an organization administrator.
	Admin *bool `json:"admin"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// An URL to the user's avatar image.
	AvatarUrl *string `json:"avatarUrl"`
	// [DEPRECATED] Hash for the user to be used in calendar URLs.
	CalendarHash *string `json:"calendarHash"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Number of issues created.
	CreatedIssueCount *int `json:"createdIssueCount"`
	// A short description of the user, either its title or bio.
	Description *string `json:"description"`
	// Reason why is the account disabled.
	DisableReason *string `json:"disableReason"`
	// The user's display (nick) name. Unique within each organization.
	DisplayName *string `json:"displayName"`
	// The user's email address.
	Email *string `json:"email"`
	// Whether the user is a guest in the workspace and limited to accessing a subset of teams.
	Guest *bool `json:"guest"`
	// Unique hash for the user to be used in invite URLs.
	InviteHash *string `json:"inviteHash"`
	// Whether the user is the currently authenticated user.
	IsMe *bool `json:"isMe"`
	// The last time the user was seen online. If null, the user is currently online.
	LastSeen *time.Time `json:"-"`
	// The user's full name.
	Name *string `json:"name"`
	// The emoji to represent the user current status.
	StatusEmoji *string `json:"statusEmoji"`
	// The label of the user current status.
	StatusLabel *string `json:"statusLabel"`
	// A date at which the user current status should be cleared.
	StatusUntilAt *time.Time `json:"-"`
	// The local timezone of the user.
	Timezone *string `json:"timezone"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// User's profile URL.
	Url *string `json:"url"`
}

// GetId returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser.Id, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser) GetId() *string {
	return v.Id
}

// GetActive returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser.Active, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser) GetActive() *bool {
	return v.Active
}

// GetAdmin returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser.Admin, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser) GetAdmin() *bool {
	return v.Admin
}

// GetArchivedAt returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetAvatarUrl returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser.AvatarUrl, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser) GetAvatarUrl() *string {
	return v.AvatarUrl
}

// GetCalendarHash returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser.CalendarHash, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser) GetCalendarHash() *string {
	return v.CalendarHash
}

// GetCreatedAt returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser.CreatedAt, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetCreatedIssueCount returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser.CreatedIssueCount, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser) GetCreatedIssueCount() *int {
	return v.CreatedIssueCount
}

// GetDescription returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser.Description, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser) GetDescription() *string {
	return v.Description
}

// GetDisableReason returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser.DisableReason, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser) GetDisableReason() *string {
	return v.DisableReason
}

// GetDisplayName returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser.DisplayName, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser) GetDisplayName() *string {
	return v.DisplayName
}

// GetEmail returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser.Email, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser) GetEmail() *string {
	return v.Email
}

// GetGuest returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser.Guest, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser) GetGuest() *bool {
	return v.Guest
}

// GetInviteHash returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser.InviteHash, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser) GetInviteHash() *string {
	return v.InviteHash
}

// GetIsMe returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser.IsMe, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser) GetIsMe() *bool {
	return v.IsMe
}

// GetLastSeen returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser.LastSeen, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser) GetLastSeen() *time.Time {
	return v.LastSeen
}

// GetName returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser.Name, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser) GetName() *string {
	return v.Name
}

// GetStatusEmoji returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser.StatusEmoji, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser) GetStatusEmoji() *string {
	return v.StatusEmoji
}

// GetStatusLabel returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser.StatusLabel, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser) GetStatusLabel() *string {
	return v.StatusLabel
}

// GetStatusUntilAt returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser.StatusUntilAt, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser) GetStatusUntilAt() *time.Time {
	return v.StatusUntilAt
}

// GetTimezone returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser.Timezone, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser) GetTimezone() *string {
	return v.Timezone
}

// GetUpdatedAt returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

// GetUrl returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser.Url, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser) GetUrl() *string {
	return v.Url
}

func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser
		ArchivedAt    json.RawMessage `json:"archivedAt"`
		CreatedAt     json.RawMessage `json:"createdAt"`
		LastSeen      json.RawMessage `json:"lastSeen"`
		StatusUntilAt json.RawMessage `json:"statusUntilAt"`
		UpdatedAt     json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.LastSeen
		src := firstPass.LastSeen
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser.LastSeen: %w", err)
			}
		}
	}

	{
		dst := &v.StatusUntilAt
		src := firstPass.StatusUntilAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser.StatusUntilAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser struct {
	Id *string `json:"id"`

	Active *bool `json:"active"`

	Admin *bool `json:"admin"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AvatarUrl *string `json:"avatarUrl"`

	CalendarHash *string `json:"calendarHash"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CreatedIssueCount *int `json:"createdIssueCount"`

	Description *string `json:"description"`

	DisableReason *string `json:"disableReason"`

	DisplayName *string `json:"displayName"`

	Email *string `json:"email"`

	Guest *bool `json:"guest"`

	InviteHash *string `json:"inviteHash"`

	IsMe *bool `json:"isMe"`

	LastSeen json.RawMessage `json:"lastSeen"`

	Name *string `json:"name"`

	StatusEmoji *string `json:"statusEmoji"`

	StatusLabel *string `json:"statusLabel"`

	StatusUntilAt json.RawMessage `json:"statusUntilAt"`

	Timezone *string `json:"timezone"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	Url *string `json:"url"`
}

func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser) __premarshalJSON() (*__premarshallistTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser, error) {
	var retval __premarshallistTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser

	retval.Id = v.Id
	retval.Active = v.Active
	retval.Admin = v.Admin
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser.ArchivedAt: %w", err)
			}
		}
	}
	retval.AvatarUrl = v.AvatarUrl
	retval.CalendarHash = v.CalendarHash
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser.CreatedAt: %w", err)
			}
		}
	}
	retval.CreatedIssueCount = v.CreatedIssueCount
	retval.Description = v.Description
	retval.DisableReason = v.DisableReason
	retval.DisplayName = v.DisplayName
	retval.Email = v.Email
	retval.Guest = v.Guest
	retval.InviteHash = v.InviteHash
	retval.IsMe = v.IsMe
	{

		dst := &retval.LastSeen
		src := v.LastSeen
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser.LastSeen: %w", err)
			}
		}
	}
	retval.Name = v.Name
	retval.StatusEmoji = v.StatusEmoji
	retval.StatusLabel = v.StatusLabel
	{

		dst := &retval.StatusUntilAt
		src := v.StatusUntilAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser.StatusUntilAt: %w", err)
			}
		}
	}
	retval.Timezone = v.Timezone
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamMembershipsTeamMembershipsTeamMembershipConnectionNodesTeamMembershipUser.UpdatedAt: %w", err)
			}
		}
	}
	retval.Url = v.Url
	return &retval, nil
}

// listTeamMembershipsTeamMembershipsTeamMembershipConnectionPageInfo includes the requested fields of the GraphQL type PageInfo.
type listTeamMembershipsTeamMembershipsTeamMembershipConnectionPageInfo struct {
	// Indicates if there are more results when paginating forward.
	HasNextPage *bool `json:"hasNextPage"`
	// Cursor representing the last result in the paginated results.
	EndCursor *string `json:"endCursor"`
}

// GetHasNextPage returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionPageInfo.HasNextPage, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionPageInfo) GetHasNextPage() *bool {
	return v.HasNextPage
}

// GetEndCursor returns listTeamMembershipsTeamMembershipsTeamMembershipConnectionPageInfo.EndCursor, and is useful for accessing the field via an interface.
func (v *listTeamMembershipsTeamMembershipsTeamMembershipConnectionPageInfo) GetEndCursor() *string {
	return v.EndCursor
}

// listTeamsResponse is returned by listTeams on success.
type listTeamsResponse struct {
	// All teams whose issues can be accessed by the user. This might be different from `administrableTeams`, which also includes teams whose settings can be changed by the user.
	Teams *listTeamsTeamsTeamConnection `json:"teams"`
}

// GetTeams returns listTeamsResponse.Teams, and is useful for accessing the field via an interface.
func (v *listTeamsResponse) GetTeams() *listTeamsTeamsTeamConnection { return v.Teams }

// listTeamsTeamsTeamConnection includes the requested fields of the GraphQL type TeamConnection.
type listTeamsTeamsTeamConnection struct {
	PageInfo *listTeamsTeamsTeamConnectionPageInfo    `json:"pageInfo"`
	Nodes    []*listTeamsTeamsTeamConnectionNodesTeam `json:"nodes"`
}

// GetPageInfo returns listTeamsTeamsTeamConnection.PageInfo, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnection) GetPageInfo() *listTeamsTeamsTeamConnectionPageInfo {
	return v.PageInfo
}

// GetNodes returns listTeamsTeamsTeamConnection.Nodes, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnection) GetNodes() []*listTeamsTeamsTeamConnectionNodesTeam {
	return v.Nodes
}

// listTeamsTeamsTeamConnectionNodesTeam includes the requested fields of the GraphQL type Team.
// The GraphQL type's documentation follows.
//
// An organizational unit that contains issues.
type listTeamsTeamsTeamConnectionNodesTeam struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// Period after which automatically closed and completed issues are automatically archived in months.
	AutoArchivePeriod *float64 `json:"autoArchivePeriod"`
	// Period after which issues are automatically closed in months. Null/undefined means disabled.
	AutoClosePeriod *float64 `json:"autoClosePeriod"`
	// The canceled workflow state which auto closed issues will be set to. Defaults to the first canceled state.
	AutoCloseStateId *string `json:"autoCloseStateId"`
	// The team's color.
	Color *string `json:"color"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Calendar feed URL (iCal) for cycles.
	CycleCalenderUrl *string `json:"cycleCalenderUrl"`
	// The cooldown time after each cycle in weeks.
	CycleCooldownTime *float64 `json:"cycleCooldownTime"`
	// The duration of a cycle in weeks.
	CycleDuration *float64 `json:"cycleDuration"`
	// Auto assign completed issues to current cycle.
	CycleIssueAutoAssignCompleted *bool `json:"cycleIssueAutoAssignCompleted"`
	// Auto assign started issues to current cycle.
	CycleIssueAutoAssignStarted *bool `json:"cycleIssueAutoAssignStarted"`
	// Only allow issues issues with cycles in Active Issues.
	CycleLockToActive *bool `json:"cycleLockToActive"`
	// The day of the week that a new cycle starts.
	CycleStartDay *float64 `json:"cycleStartDay"`
	// Whether the team uses cycles.
	CyclesEnabled *bool `json:"cyclesEnabled"`
	// What to use as an default estimate for unestimated issues.
	DefaultIssueEstimate *float64 `json:"defaultIssueEstimate"`
	// The id of the default template to use for new issues created by members of the team.
	DefaultTemplateForMembersId *string `json:"defaultTemplateForMembersId"`
	// The id of the default template to use for new issues created by non-members of the team.
	DefaultTemplateForNonMembersId *string `json:"defaultTemplateForNonMembersId"`
	// The team's description.
	Description *string `json:"description"`
	// Whether to group recent issue history entries.
	GroupIssueHistory *bool `json:"groupIssueHistory"`
	// The icon of the team.
	Icon *string `json:"icon"`
	// Unique hash for the team to be used in invite URLs.
	InviteHash *string `json:"inviteHash"`
	// Whether to allow zeros in issues estimates.
	IssueEstimationAllowZero *bool `json:"issueEstimationAllowZero"`
	// Whether to add additional points to the estimate scale.
	IssueEstimationExtended *bool `json:"issueEstimationExtended"`
	// The issue estimation type to use.
	IssueEstimationType *string `json:"issueEstimationType"`
	// Whether issues without priority should be sorted first.
	IssueOrderingNoPriorityFirst *bool `json:"issueOrderingNoPriorityFirst"`
	// Whether to move issues to bottom of the column when changing state.
	IssueSortOrderDefaultToBottom *bool `json:"issueSortOrderDefaultToBottom"`
	// The team's unique key. The key is used in URLs.
	Key *string `json:"key"`
	// The team's name.
	Name *string `json:"name"`
	// Whether the team is private or not.
	Private *bool `json:"private"`
	// Whether an issue needs to have a priority set before leaving triage
	RequirePriorityToLeaveTriage *bool `json:"requirePriorityToLeaveTriage"`
	// Whether to send new issue comment notifications to Slack.
	SlackIssueComments *bool `json:"slackIssueComments"`
	// Whether to send new issue status updates to Slack.
	SlackIssueStatuses *bool `json:"slackIssueStatuses"`
	// Whether to send new issue notifications to Slack.
	SlackNewIssue *bool `json:"slackNewIssue"`
	// The timezone of the team. Defaults to "America/Los_Angeles"
	Timezone *string `json:"timezone"`
	// Whether triage mode is enabled for the team or not.
	TriageEnabled *bool `json:"triageEnabled"`
	// How many upcoming cycles to create.
	UpcomingCycleCount *float64 `json:"upcomingCycleCount"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// Team's currently active cycle.
	ActiveCycle *listTeamsTeamsTeamConnectionNodesTeamActiveCycle `json:"activeCycle"`
	// The default workflow state into which issues are set when they are opened by team members.
	DefaultIssueState *listTeamsTeamsTeamConnectionNodesTeamDefaultIssueStateWorkflowState `json:"defaultIssueState"`
	// The default template to use for new issues created by members of the team.
	DefaultTemplateForMembers *listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForMembersTemplate `json:"defaultTemplateForMembers"`
	// The default template to use for new issues created by non-members of the team.
	DefaultTemplateForNonMembers *listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForNonMembersTemplate `json:"defaultTemplateForNonMembers"`
	// The workflow state into which issues are moved when a PR has been opened as draft.
	DraftWorkflowState *listTeamsTeamsTeamConnectionNodesTeamDraftWorkflowState `json:"draftWorkflowState"`
	// Settings for all integrations associated with that team.
	IntegrationsSettings *listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings `json:"integrationsSettings"`
	// The workflow state into which issues are moved when they are marked as a duplicate of another issue. Defaults to the first canceled state.
	MarkedAsDuplicateWorkflowState *listTeamsTeamsTeamConnectionNodesTeamMarkedAsDuplicateWorkflowState `json:"markedAsDuplicateWorkflowState"`
	// The organization that the team is associated with.
	Organization *listTeamsTeamsTeamConnectionNodesTeamOrganization `json:"organization"`
	// The workflow state into which issues are moved when a review has been requested for the PR.
	ReviewWorkflowState *listTeamsTeamsTeamConnectionNodesTeamReviewWorkflowState `json:"reviewWorkflowState"`
	// The workflow state into which issues are moved when a PR has been opened.
	StartWorkflowState *listTeamsTeamsTeamConnectionNodesTeamStartWorkflowState `json:"startWorkflowState"`
	// The workflow state into which issues are set when they are opened by non-team members or integrations if triage is enabled.
	TriageIssueState *listTeamsTeamsTeamConnectionNodesTeamTriageIssueStateWorkflowState `json:"triageIssueState"`
}

// GetId returns listTeamsTeamsTeamConnectionNodesTeam.Id, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetId() *string { return v.Id }

// GetArchivedAt returns listTeamsTeamsTeamConnectionNodesTeam.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetAutoArchivePeriod returns listTeamsTeamsTeamConnectionNodesTeam.AutoArchivePeriod, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetAutoArchivePeriod() *float64 {
	return v.AutoArchivePeriod
}

// GetAutoClosePeriod returns listTeamsTeamsTeamConnectionNodesTeam.AutoClosePeriod, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetAutoClosePeriod() *float64 {
	return v.AutoClosePeriod
}

// GetAutoCloseStateId returns listTeamsTeamsTeamConnectionNodesTeam.AutoCloseStateId, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetAutoCloseStateId() *string {
	return v.AutoCloseStateId
}

// GetColor returns listTeamsTeamsTeamConnectionNodesTeam.Color, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetColor() *string { return v.Color }

// GetCreatedAt returns listTeamsTeamsTeamConnectionNodesTeam.CreatedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetCycleCalenderUrl returns listTeamsTeamsTeamConnectionNodesTeam.CycleCalenderUrl, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetCycleCalenderUrl() *string {
	return v.CycleCalenderUrl
}

// GetCycleCooldownTime returns listTeamsTeamsTeamConnectionNodesTeam.CycleCooldownTime, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetCycleCooldownTime() *float64 {
	return v.CycleCooldownTime
}

// GetCycleDuration returns listTeamsTeamsTeamConnectionNodesTeam.CycleDuration, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetCycleDuration() *float64 { return v.CycleDuration }

// GetCycleIssueAutoAssignCompleted returns listTeamsTeamsTeamConnectionNodesTeam.CycleIssueAutoAssignCompleted, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetCycleIssueAutoAssignCompleted() *bool {
	return v.CycleIssueAutoAssignCompleted
}

// GetCycleIssueAutoAssignStarted returns listTeamsTeamsTeamConnectionNodesTeam.CycleIssueAutoAssignStarted, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetCycleIssueAutoAssignStarted() *bool {
	return v.CycleIssueAutoAssignStarted
}

// GetCycleLockToActive returns listTeamsTeamsTeamConnectionNodesTeam.CycleLockToActive, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetCycleLockToActive() *bool {
	return v.CycleLockToActive
}

// GetCycleStartDay returns listTeamsTeamsTeamConnectionNodesTeam.CycleStartDay, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetCycleStartDay() *float64 { return v.CycleStartDay }

// GetCyclesEnabled returns listTeamsTeamsTeamConnectionNodesTeam.CyclesEnabled, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetCyclesEnabled() *bool { return v.CyclesEnabled }

// GetDefaultIssueEstimate returns listTeamsTeamsTeamConnectionNodesTeam.DefaultIssueEstimate, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetDefaultIssueEstimate() *float64 {
	return v.DefaultIssueEstimate
}

// GetDefaultTemplateForMembersId returns listTeamsTeamsTeamConnectionNodesTeam.DefaultTemplateForMembersId, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetDefaultTemplateForMembersId() *string {
	return v.DefaultTemplateForMembersId
}

// GetDefaultTemplateForNonMembersId returns listTeamsTeamsTeamConnectionNodesTeam.DefaultTemplateForNonMembersId, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetDefaultTemplateForNonMembersId() *string {
	return v.DefaultTemplateForNonMembersId
}

// GetDescription returns listTeamsTeamsTeamConnectionNodesTeam.Description, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetDescription() *string { return v.Description }

// GetGroupIssueHistory returns listTeamsTeamsTeamConnectionNodesTeam.GroupIssueHistory, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetGroupIssueHistory() *bool {
	return v.GroupIssueHistory
}

// GetIcon returns listTeamsTeamsTeamConnectionNodesTeam.Icon, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetIcon() *string { return v.Icon }

// GetInviteHash returns listTeamsTeamsTeamConnectionNodesTeam.InviteHash, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetInviteHash() *string { return v.InviteHash }

// GetIssueEstimationAllowZero returns listTeamsTeamsTeamConnectionNodesTeam.IssueEstimationAllowZero, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetIssueEstimationAllowZero() *bool {
	return v.IssueEstimationAllowZero
}

// GetIssueEstimationExtended returns listTeamsTeamsTeamConnectionNodesTeam.IssueEstimationExtended, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetIssueEstimationExtended() *bool {
	return v.IssueEstimationExtended
}

// GetIssueEstimationType returns listTeamsTeamsTeamConnectionNodesTeam.IssueEstimationType, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetIssueEstimationType() *string {
	return v.IssueEstimationType
}

// GetIssueOrderingNoPriorityFirst returns listTeamsTeamsTeamConnectionNodesTeam.IssueOrderingNoPriorityFirst, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetIssueOrderingNoPriorityFirst() *bool {
	return v.IssueOrderingNoPriorityFirst
}

// GetIssueSortOrderDefaultToBottom returns listTeamsTeamsTeamConnectionNodesTeam.IssueSortOrderDefaultToBottom, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetIssueSortOrderDefaultToBottom() *bool {
	return v.IssueSortOrderDefaultToBottom
}

// GetKey returns listTeamsTeamsTeamConnectionNodesTeam.Key, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetKey() *string { return v.Key }

// GetName returns listTeamsTeamsTeamConnectionNodesTeam.Name, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetName() *string { return v.Name }

// GetPrivate returns listTeamsTeamsTeamConnectionNodesTeam.Private, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetPrivate() *bool { return v.Private }

// GetRequirePriorityToLeaveTriage returns listTeamsTeamsTeamConnectionNodesTeam.RequirePriorityToLeaveTriage, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetRequirePriorityToLeaveTriage() *bool {
	return v.RequirePriorityToLeaveTriage
}

// GetSlackIssueComments returns listTeamsTeamsTeamConnectionNodesTeam.SlackIssueComments, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetSlackIssueComments() *bool {
	return v.SlackIssueComments
}

// GetSlackIssueStatuses returns listTeamsTeamsTeamConnectionNodesTeam.SlackIssueStatuses, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetSlackIssueStatuses() *bool {
	return v.SlackIssueStatuses
}

// GetSlackNewIssue returns listTeamsTeamsTeamConnectionNodesTeam.SlackNewIssue, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetSlackNewIssue() *bool { return v.SlackNewIssue }

// GetTimezone returns listTeamsTeamsTeamConnectionNodesTeam.Timezone, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetTimezone() *string { return v.Timezone }

// GetTriageEnabled returns listTeamsTeamsTeamConnectionNodesTeam.TriageEnabled, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetTriageEnabled() *bool { return v.TriageEnabled }

// GetUpcomingCycleCount returns listTeamsTeamsTeamConnectionNodesTeam.UpcomingCycleCount, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetUpcomingCycleCount() *float64 {
	return v.UpcomingCycleCount
}

// GetUpdatedAt returns listTeamsTeamsTeamConnectionNodesTeam.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetUpdatedAt() *time.Time { return v.UpdatedAt }

// GetActiveCycle returns listTeamsTeamsTeamConnectionNodesTeam.ActiveCycle, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetActiveCycle() *listTeamsTeamsTeamConnectionNodesTeamActiveCycle {
	return v.ActiveCycle
}

// GetDefaultIssueState returns listTeamsTeamsTeamConnectionNodesTeam.DefaultIssueState, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetDefaultIssueState() *listTeamsTeamsTeamConnectionNodesTeamDefaultIssueStateWorkflowState {
	return v.DefaultIssueState
}

// GetDefaultTemplateForMembers returns listTeamsTeamsTeamConnectionNodesTeam.DefaultTemplateForMembers, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetDefaultTemplateForMembers() *listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForMembersTemplate {
	return v.DefaultTemplateForMembers
}

// GetDefaultTemplateForNonMembers returns listTeamsTeamsTeamConnectionNodesTeam.DefaultTemplateForNonMembers, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetDefaultTemplateForNonMembers() *listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForNonMembersTemplate {
	return v.DefaultTemplateForNonMembers
}

// GetDraftWorkflowState returns listTeamsTeamsTeamConnectionNodesTeam.DraftWorkflowState, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetDraftWorkflowState() *listTeamsTeamsTeamConnectionNodesTeamDraftWorkflowState {
	return v.DraftWorkflowState
}

// GetIntegrationsSettings returns listTeamsTeamsTeamConnectionNodesTeam.IntegrationsSettings, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetIntegrationsSettings() *listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings {
	return v.IntegrationsSettings
}

// GetMarkedAsDuplicateWorkflowState returns listTeamsTeamsTeamConnectionNodesTeam.MarkedAsDuplicateWorkflowState, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetMarkedAsDuplicateWorkflowState() *listTeamsTeamsTeamConnectionNodesTeamMarkedAsDuplicateWorkflowState {
	return v.MarkedAsDuplicateWorkflowState
}

// GetOrganization returns listTeamsTeamsTeamConnectionNodesTeam.Organization, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetOrganization() *listTeamsTeamsTeamConnectionNodesTeamOrganization {
	return v.Organization
}

// GetReviewWorkflowState returns listTeamsTeamsTeamConnectionNodesTeam.ReviewWorkflowState, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetReviewWorkflowState() *listTeamsTeamsTeamConnectionNodesTeamReviewWorkflowState {
	return v.ReviewWorkflowState
}

// GetStartWorkflowState returns listTeamsTeamsTeamConnectionNodesTeam.StartWorkflowState, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetStartWorkflowState() *listTeamsTeamsTeamConnectionNodesTeamStartWorkflowState {
	return v.StartWorkflowState
}

// GetTriageIssueState returns listTeamsTeamsTeamConnectionNodesTeam.TriageIssueState, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeam) GetTriageIssueState() *listTeamsTeamsTeamConnectionNodesTeamTriageIssueStateWorkflowState {
	return v.TriageIssueState
}

func (v *listTeamsTeamsTeamConnectionNodesTeam) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listTeamsTeamsTeamConnectionNodesTeam
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listTeamsTeamsTeamConnectionNodesTeam = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeam.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeam.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeam.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistTeamsTeamsTeamConnectionNodesTeam struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AutoArchivePeriod *float64 `json:"autoArchivePeriod"`

	AutoClosePeriod *float64 `json:"autoClosePeriod"`

	AutoCloseStateId *string `json:"autoCloseStateId"`

	Color *string `json:"color"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CycleCalenderUrl *string `json:"cycleCalenderUrl"`

	CycleCooldownTime *float64 `json:"cycleCooldownTime"`

	CycleDuration *float64 `json:"cycleDuration"`

	CycleIssueAutoAssignCompleted *bool `json:"cycleIssueAutoAssignCompleted"`

	CycleIssueAutoAssignStarted *bool `json:"cycleIssueAutoAssignStarted"`

	CycleLockToActive *bool `json:"cycleLockToActive"`

	CycleStartDay *float64 `json:"cycleStartDay"`

	CyclesEnabled *bool `json:"cyclesEnabled"`

	DefaultIssueEstimate *float64 `json:"defaultIssueEstimate"`

	DefaultTemplateForMembersId *string `json:"defaultTemplateForMembersId"`

	DefaultTemplateForNonMembersId *string `json:"defaultTemplateForNonMembersId"`

	Description *string `json:"description"`

	GroupIssueHistory *bool `json:"groupIssueHistory"`

	Icon *string `json:"icon"`

	InviteHash *string `json:"inviteHash"`

	IssueEstimationAllowZero *bool `json:"issueEstimationAllowZero"`

	IssueEstimationExtended *bool `json:"issueEstimationExtended"`

	IssueEstimationType *string `json:"issueEstimationType"`

	IssueOrderingNoPriorityFirst *bool `json:"issueOrderingNoPriorityFirst"`

	IssueSortOrderDefaultToBottom *bool `json:"issueSortOrderDefaultToBottom"`

	Key *string `json:"key"`

	Name *string `json:"name"`

	Private *bool `json:"private"`

	RequirePriorityToLeaveTriage *bool `json:"requirePriorityToLeaveTriage"`

	SlackIssueComments *bool `json:"slackIssueComments"`

	SlackIssueStatuses *bool `json:"slackIssueStatuses"`

	SlackNewIssue *bool `json:"slackNewIssue"`

	Timezone *string `json:"timezone"`

	TriageEnabled *bool `json:"triageEnabled"`

	UpcomingCycleCount *float64 `json:"upcomingCycleCount"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	ActiveCycle *listTeamsTeamsTeamConnectionNodesTeamActiveCycle `json:"activeCycle"`

	DefaultIssueState *listTeamsTeamsTeamConnectionNodesTeamDefaultIssueStateWorkflowState `json:"defaultIssueState"`

	DefaultTemplateForMembers *listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForMembersTemplate `json:"defaultTemplateForMembers"`

	DefaultTemplateForNonMembers *listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForNonMembersTemplate `json:"defaultTemplateForNonMembers"`

	DraftWorkflowState *listTeamsTeamsTeamConnectionNodesTeamDraftWorkflowState `json:"draftWorkflowState"`

	IntegrationsSettings *listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings `json:"integrationsSettings"`

	MarkedAsDuplicateWorkflowState *listTeamsTeamsTeamConnectionNodesTeamMarkedAsDuplicateWorkflowState `json:"markedAsDuplicateWorkflowState"`

	Organization *listTeamsTeamsTeamConnectionNodesTeamOrganization `json:"organization"`

	ReviewWorkflowState *listTeamsTeamsTeamConnectionNodesTeamReviewWorkflowState `json:"reviewWorkflowState"`

	StartWorkflowState *listTeamsTeamsTeamConnectionNodesTeamStartWorkflowState `json:"startWorkflowState"`

	TriageIssueState *listTeamsTeamsTeamConnectionNodesTeamTriageIssueStateWorkflowState `json:"triageIssueState"`
}

func (v *listTeamsTeamsTeamConnectionNodesTeam) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listTeamsTeamsTeamConnectionNodesTeam) __premarshalJSON() (*__premarshallistTeamsTeamsTeamConnectionNodesTeam, error) {
	var retval __premarshallistTeamsTeamsTeamConnectionNodesTeam

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeam.ArchivedAt: %w", err)
			}
		}
	}
	retval.AutoArchivePeriod = v.AutoArchivePeriod
	retval.AutoClosePeriod = v.AutoClosePeriod
	retval.AutoCloseStateId = v.AutoCloseStateId
	retval.Color = v.Color
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeam.CreatedAt: %w", err)
			}
		}
	}
	retval.CycleCalenderUrl = v.CycleCalenderUrl
	retval.CycleCooldownTime = v.CycleCooldownTime
	retval.CycleDuration = v.CycleDuration
	retval.CycleIssueAutoAssignCompleted = v.CycleIssueAutoAssignCompleted
	retval.CycleIssueAutoAssignStarted = v.CycleIssueAutoAssignStarted
	retval.CycleLockToActive = v.CycleLockToActive
	retval.CycleStartDay = v.CycleStartDay
	retval.CyclesEnabled = v.CyclesEnabled
	retval.DefaultIssueEstimate = v.DefaultIssueEstimate
	retval.DefaultTemplateForMembersId = v.DefaultTemplateForMembersId
	retval.DefaultTemplateForNonMembersId = v.DefaultTemplateForNonMembersId
	retval.Description = v.Description
	retval.GroupIssueHistory = v.GroupIssueHistory
	retval.Icon = v.Icon
	retval.InviteHash = v.InviteHash
	retval.IssueEstimationAllowZero = v.IssueEstimationAllowZero
	retval.IssueEstimationExtended = v.IssueEstimationExtended
	retval.IssueEstimationType = v.IssueEstimationType
	retval.IssueOrderingNoPriorityFirst = v.IssueOrderingNoPriorityFirst
	retval.IssueSortOrderDefaultToBottom = v.IssueSortOrderDefaultToBottom
	retval.Key = v.Key
	retval.Name = v.Name
	retval.Private = v.Private
	retval.RequirePriorityToLeaveTriage = v.RequirePriorityToLeaveTriage
	retval.SlackIssueComments = v.SlackIssueComments
	retval.SlackIssueStatuses = v.SlackIssueStatuses
	retval.SlackNewIssue = v.SlackNewIssue
	retval.Timezone = v.Timezone
	retval.TriageEnabled = v.TriageEnabled
	retval.UpcomingCycleCount = v.UpcomingCycleCount
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeam.UpdatedAt: %w", err)
			}
		}
	}
	retval.ActiveCycle = v.ActiveCycle
	retval.DefaultIssueState = v.DefaultIssueState
	retval.DefaultTemplateForMembers = v.DefaultTemplateForMembers
	retval.DefaultTemplateForNonMembers = v.DefaultTemplateForNonMembers
	retval.DraftWorkflowState = v.DraftWorkflowState
	retval.IntegrationsSettings = v.IntegrationsSettings
	retval.MarkedAsDuplicateWorkflowState = v.MarkedAsDuplicateWorkflowState
	retval.Organization = v.Organization
	retval.ReviewWorkflowState = v.ReviewWorkflowState
	retval.StartWorkflowState = v.StartWorkflowState
	retval.TriageIssueState = v.TriageIssueState
	return &retval, nil
}

// listTeamsTeamsTeamConnectionNodesTeamActiveCycle includes the requested fields of the GraphQL type Cycle.
// The GraphQL type's documentation follows.
//
// A set of issues to be resolved in a specified amount of time.
type listTeamsTeamsTeamConnectionNodesTeamActiveCycle struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The time at which the cycle was automatically archived by the auto pruning process.
	AutoArchivedAt *time.Time `json:"-"`
	// The completion time of the cycle. If null, the cycle hasn't been completed.
	CompletedAt *time.Time `json:"-"`
	// The number of completed issues in the cycle after each day.
	CompletedIssueCountHistory []*float64 `json:"completedIssueCountHistory"`
	// The number of completed estimation points after each day.
	CompletedScopeHistory []*float64 `json:"completedScopeHistory"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// The cycle's description.
	Description *string `json:"description"`
	// The end time of the cycle.
	EndsAt *time.Time `json:"-"`
	// The number of in progress estimation points after each day.
	InProgressScopeHistory []*float64 `json:"inProgressScopeHistory"`
	// The total number of issues in the cycle after each day.
	IssueCountHistory []*float64 `json:"issueCountHistory"`
	// The custom name of the cycle.
	Name *string `json:"name"`
	// The number of the cycle.
	Number *float64 `json:"number"`
	// The overall progress of the cycle. This is the (completed estimate points + 0.25 * in progress estimate points) / total estimate points.
	Progress *float64 `json:"progress"`
	// The total number of estimation points after each day.
	ScopeHistory []*float64 `json:"scopeHistory"`
	// The start time of the cycle.
	StartsAt *time.Time `json:"-"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
}

// GetId returns listTeamsTeamsTeamConnectionNodesTeamActiveCycle.Id, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamActiveCycle) GetId() *string { return v.Id }

// GetArchivedAt returns listTeamsTeamsTeamConnectionNodesTeamActiveCycle.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamActiveCycle) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetAutoArchivedAt returns listTeamsTeamsTeamConnectionNodesTeamActiveCycle.AutoArchivedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamActiveCycle) GetAutoArchivedAt() *time.Time {
	return v.AutoArchivedAt
}

// GetCompletedAt returns listTeamsTeamsTeamConnectionNodesTeamActiveCycle.CompletedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamActiveCycle) GetCompletedAt() *time.Time {
	return v.CompletedAt
}

// GetCompletedIssueCountHistory returns listTeamsTeamsTeamConnectionNodesTeamActiveCycle.CompletedIssueCountHistory, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamActiveCycle) GetCompletedIssueCountHistory() []*float64 {
	return v.CompletedIssueCountHistory
}

// GetCompletedScopeHistory returns listTeamsTeamsTeamConnectionNodesTeamActiveCycle.CompletedScopeHistory, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamActiveCycle) GetCompletedScopeHistory() []*float64 {
	return v.CompletedScopeHistory
}

// GetCreatedAt returns listTeamsTeamsTeamConnectionNodesTeamActiveCycle.CreatedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamActiveCycle) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetDescription returns listTeamsTeamsTeamConnectionNodesTeamActiveCycle.Description, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamActiveCycle) GetDescription() *string {
	return v.Description
}

// GetEndsAt returns listTeamsTeamsTeamConnectionNodesTeamActiveCycle.EndsAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamActiveCycle) GetEndsAt() *time.Time { return v.EndsAt }

// GetInProgressScopeHistory returns listTeamsTeamsTeamConnectionNodesTeamActiveCycle.InProgressScopeHistory, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamActiveCycle) GetInProgressScopeHistory() []*float64 {
	return v.InProgressScopeHistory
}

// GetIssueCountHistory returns listTeamsTeamsTeamConnectionNodesTeamActiveCycle.IssueCountHistory, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamActiveCycle) GetIssueCountHistory() []*float64 {
	return v.IssueCountHistory
}

// GetName returns listTeamsTeamsTeamConnectionNodesTeamActiveCycle.Name, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamActiveCycle) GetName() *string { return v.Name }

// GetNumber returns listTeamsTeamsTeamConnectionNodesTeamActiveCycle.Number, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamActiveCycle) GetNumber() *float64 { return v.Number }

// GetProgress returns listTeamsTeamsTeamConnectionNodesTeamActiveCycle.Progress, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamActiveCycle) GetProgress() *float64 { return v.Progress }

// GetScopeHistory returns listTeamsTeamsTeamConnectionNodesTeamActiveCycle.ScopeHistory, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamActiveCycle) GetScopeHistory() []*float64 {
	return v.ScopeHistory
}

// GetStartsAt returns listTeamsTeamsTeamConnectionNodesTeamActiveCycle.StartsAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamActiveCycle) GetStartsAt() *time.Time {
	return v.StartsAt
}

// GetUpdatedAt returns listTeamsTeamsTeamConnectionNodesTeamActiveCycle.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamActiveCycle) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

func (v *listTeamsTeamsTeamConnectionNodesTeamActiveCycle) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listTeamsTeamsTeamConnectionNodesTeamActiveCycle
		ArchivedAt     json.RawMessage `json:"archivedAt"`
		AutoArchivedAt json.RawMessage `json:"autoArchivedAt"`
		CompletedAt    json.RawMessage `json:"completedAt"`
		CreatedAt      json.RawMessage `json:"createdAt"`
		EndsAt         json.RawMessage `json:"endsAt"`
		StartsAt       json.RawMessage `json:"startsAt"`
		UpdatedAt      json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listTeamsTeamsTeamConnectionNodesTeamActiveCycle = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamActiveCycle.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.AutoArchivedAt
		src := firstPass.AutoArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamActiveCycle.AutoArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CompletedAt
		src := firstPass.CompletedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamActiveCycle.CompletedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamActiveCycle.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.EndsAt
		src := firstPass.EndsAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamActiveCycle.EndsAt: %w", err)
			}
		}
	}

	{
		dst := &v.StartsAt
		src := firstPass.StartsAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamActiveCycle.StartsAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamActiveCycle.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistTeamsTeamsTeamConnectionNodesTeamActiveCycle struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AutoArchivedAt json.RawMessage `json:"autoArchivedAt"`

	CompletedAt json.RawMessage `json:"completedAt"`

	CompletedIssueCountHistory []*float64 `json:"completedIssueCountHistory"`

	CompletedScopeHistory []*float64 `json:"completedScopeHistory"`

	CreatedAt json.RawMessage `json:"createdAt"`

	Description *string `json:"description"`

	EndsAt json.RawMessage `json:"endsAt"`

	InProgressScopeHistory []*float64 `json:"inProgressScopeHistory"`

	IssueCountHistory []*float64 `json:"issueCountHistory"`

	Name *string `json:"name"`

	Number *float64 `json:"number"`

	Progress *float64 `json:"progress"`

	ScopeHistory []*float64 `json:"scopeHistory"`

	StartsAt json.RawMessage `json:"startsAt"`

	UpdatedAt json.RawMessage `json:"updatedAt"`
}

func (v *listTeamsTeamsTeamConnectionNodesTeamActiveCycle) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listTeamsTeamsTeamConnectionNodesTeamActiveCycle) __premarshalJSON() (*__premarshallistTeamsTeamsTeamConnectionNodesTeamActiveCycle, error) {
	var retval __premarshallistTeamsTeamsTeamConnectionNodesTeamActiveCycle

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamActiveCycle.ArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.AutoArchivedAt
		src := v.AutoArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamActiveCycle.AutoArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CompletedAt
		src := v.CompletedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamActiveCycle.CompletedAt: %w", err)
			}
		}
	}
	retval.CompletedIssueCountHistory = v.CompletedIssueCountHistory
	retval.CompletedScopeHistory = v.CompletedScopeHistory
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamActiveCycle.CreatedAt: %w", err)
			}
		}
	}
	retval.Description = v.Description
	{

		dst := &retval.EndsAt
		src := v.EndsAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamActiveCycle.EndsAt: %w", err)
			}
		}
	}
	retval.InProgressScopeHistory = v.InProgressScopeHistory
	retval.IssueCountHistory = v.IssueCountHistory
	retval.Name = v.Name
	retval.Number = v.Number
	retval.Progress = v.Progress
	retval.ScopeHistory = v.ScopeHistory
	{

		dst := &retval.StartsAt
		src := v.StartsAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamActiveCycle.StartsAt: %w", err)
			}
		}
	}
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamActiveCycle.UpdatedAt: %w", err)
			}
		}
	}
	return &retval, nil
}

// listTeamsTeamsTeamConnectionNodesTeamDefaultIssueStateWorkflowState includes the requested fields of the GraphQL type WorkflowState.
// The GraphQL type's documentation follows.
//
// A state in a team workflow.
type listTeamsTeamsTeamConnectionNodesTeamDefaultIssueStateWorkflowState struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The state's UI color as a HEX string.
	Color *string `json:"color"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Description of the state.
	Description *string `json:"description"`
	// The state's name.
	Name *string `json:"name"`
	// The position of the state in the team flow.
	Position *float64 `json:"position"`
	// The type of the state.
	Type *string `json:"type"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
}

// GetId returns listTeamsTeamsTeamConnectionNodesTeamDefaultIssueStateWorkflowState.Id, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamDefaultIssueStateWorkflowState) GetId() *string {
	return v.Id
}

// GetArchivedAt returns listTeamsTeamsTeamConnectionNodesTeamDefaultIssueStateWorkflowState.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamDefaultIssueStateWorkflowState) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetColor returns listTeamsTeamsTeamConnectionNodesTeamDefaultIssueStateWorkflowState.Color, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamDefaultIssueStateWorkflowState) GetColor() *string {
	return v.Color
}

// GetCreatedAt returns listTeamsTeamsTeamConnectionNodesTeamDefaultIssueStateWorkflowState.CreatedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamDefaultIssueStateWorkflowState) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetDescription returns listTeamsTeamsTeamConnectionNodesTeamDefaultIssueStateWorkflowState.Description, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamDefaultIssueStateWorkflowState) GetDescription() *string {
	return v.Description
}

// GetName returns listTeamsTeamsTeamConnectionNodesTeamDefaultIssueStateWorkflowState.Name, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamDefaultIssueStateWorkflowState) GetName() *string {
	return v.Name
}

// GetPosition returns listTeamsTeamsTeamConnectionNodesTeamDefaultIssueStateWorkflowState.Position, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamDefaultIssueStateWorkflowState) GetPosition() *float64 {
	return v.Position
}

// GetType returns listTeamsTeamsTeamConnectionNodesTeamDefaultIssueStateWorkflowState.Type, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamDefaultIssueStateWorkflowState) GetType() *string {
	return v.Type
}

// GetUpdatedAt returns listTeamsTeamsTeamConnectionNodesTeamDefaultIssueStateWorkflowState.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamDefaultIssueStateWorkflowState) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

func (v *listTeamsTeamsTeamConnectionNodesTeamDefaultIssueStateWorkflowState) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listTeamsTeamsTeamConnectionNodesTeamDefaultIssueStateWorkflowState
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listTeamsTeamsTeamConnectionNodesTeamDefaultIssueStateWorkflowState = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamDefaultIssueStateWorkflowState.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamDefaultIssueStateWorkflowState.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamDefaultIssueStateWorkflowState.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistTeamsTeamsTeamConnectionNodesTeamDefaultIssueStateWorkflowState struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	Color *string `json:"color"`

	CreatedAt json.RawMessage `json:"createdAt"`

	Description *string `json:"description"`

	Name *string `json:"name"`

	Position *float64 `json:"position"`

	Type *string `json:"type"`

	UpdatedAt json.RawMessage `json:"updatedAt"`
}

func (v *listTeamsTeamsTeamConnectionNodesTeamDefaultIssueStateWorkflowState) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listTeamsTeamsTeamConnectionNodesTeamDefaultIssueStateWorkflowState) __premarshalJSON() (*__premarshallistTeamsTeamsTeamConnectionNodesTeamDefaultIssueStateWorkflowState, error) {
	var retval __premarshallistTeamsTeamsTeamConnectionNodesTeamDefaultIssueStateWorkflowState

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamDefaultIssueStateWorkflowState.ArchivedAt: %w", err)
			}
		}
	}
	retval.Color = v.Color
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamDefaultIssueStateWorkflowState.CreatedAt: %w", err)
			}
		}
	}
	retval.Description = v.Description
	retval.Name = v.Name
	retval.Position = v.Position
	retval.Type = v.Type
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamDefaultIssueStateWorkflowState.UpdatedAt: %w", err)
			}
		}
	}
	return &retval, nil
}

// listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForMembersTemplate includes the requested fields of the GraphQL type Template.
// The GraphQL type's documentation follows.
//
// A template object used for creating entities faster.
type listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForMembersTemplate struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// Template description.
	Description *string `json:"description"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// The entity type this template is for.
	Type *string `json:"type"`
	// The name of the template.
	Name *string `json:"name"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// Template data.
	TemplateData *json.RawMessage `json:"templateData"`
}

// GetId returns listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForMembersTemplate.Id, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForMembersTemplate) GetId() *string {
	return v.Id
}

// GetArchivedAt returns listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForMembersTemplate.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForMembersTemplate) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetDescription returns listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForMembersTemplate.Description, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForMembersTemplate) GetDescription() *string {
	return v.Description
}

// GetCreatedAt returns listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForMembersTemplate.CreatedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForMembersTemplate) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetType returns listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForMembersTemplate.Type, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForMembersTemplate) GetType() *string {
	return v.Type
}

// GetName returns listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForMembersTemplate.Name, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForMembersTemplate) GetName() *string {
	return v.Name
}

// GetUpdatedAt returns listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForMembersTemplate.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForMembersTemplate) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

// GetTemplateData returns listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForMembersTemplate.TemplateData, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForMembersTemplate) GetTemplateData() *json.RawMessage {
	return v.TemplateData
}

func (v *listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForMembersTemplate) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForMembersTemplate
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForMembersTemplate = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForMembersTemplate.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForMembersTemplate.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForMembersTemplate.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForMembersTemplate struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	Description *string `json:"description"`

	CreatedAt json.RawMessage `json:"createdAt"`

	Type *string `json:"type"`

	Name *string `json:"name"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	TemplateData *json.RawMessage `json:"templateData"`
}

func (v *listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForMembersTemplate) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForMembersTemplate) __premarshalJSON() (*__premarshallistTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForMembersTemplate, error) {
	var retval __premarshallistTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForMembersTemplate

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForMembersTemplate.ArchivedAt: %w", err)
			}
		}
	}
	retval.Description = v.Description
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForMembersTemplate.CreatedAt: %w", err)
			}
		}
	}
	retval.Type = v.Type
	retval.Name = v.Name
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForMembersTemplate.UpdatedAt: %w", err)
			}
		}
	}
	retval.TemplateData = v.TemplateData
	return &retval, nil
}

// listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForNonMembersTemplate includes the requested fields of the GraphQL type Template.
// The GraphQL type's documentation follows.
//
// A template object used for creating entities faster.
type listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForNonMembersTemplate struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// Template description.
	Description *string `json:"description"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// The entity type this template is for.
	Type *string `json:"type"`
	// The name of the template.
	Name *string `json:"name"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// Template data.
	TemplateData *json.RawMessage `json:"templateData"`
}

// GetId returns listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForNonMembersTemplate.Id, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForNonMembersTemplate) GetId() *string {
	return v.Id
}

// GetArchivedAt returns listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForNonMembersTemplate.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForNonMembersTemplate) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetDescription returns listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForNonMembersTemplate.Description, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForNonMembersTemplate) GetDescription() *string {
	return v.Description
}

// GetCreatedAt returns listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForNonMembersTemplate.CreatedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForNonMembersTemplate) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetType returns listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForNonMembersTemplate.Type, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForNonMembersTemplate) GetType() *string {
	return v.Type
}

// GetName returns listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForNonMembersTemplate.Name, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForNonMembersTemplate) GetName() *string {
	return v.Name
}

// GetUpdatedAt returns listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForNonMembersTemplate.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForNonMembersTemplate) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

// GetTemplateData returns listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForNonMembersTemplate.TemplateData, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForNonMembersTemplate) GetTemplateData() *json.RawMessage {
	return v.TemplateData
}

func (v *listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForNonMembersTemplate) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForNonMembersTemplate
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForNonMembersTemplate = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForNonMembersTemplate.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForNonMembersTemplate.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForNonMembersTemplate.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForNonMembersTemplate struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	Description *string `json:"description"`

	CreatedAt json.RawMessage `json:"createdAt"`

	Type *string `json:"type"`

	Name *string `json:"name"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	TemplateData *json.RawMessage `json:"templateData"`
}

func (v *listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForNonMembersTemplate) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForNonMembersTemplate) __premarshalJSON() (*__premarshallistTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForNonMembersTemplate, error) {
	var retval __premarshallistTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForNonMembersTemplate

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForNonMembersTemplate.ArchivedAt: %w", err)
			}
		}
	}
	retval.Description = v.Description
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForNonMembersTemplate.CreatedAt: %w", err)
			}
		}
	}
	retval.Type = v.Type
	retval.Name = v.Name
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamDefaultTemplateForNonMembersTemplate.UpdatedAt: %w", err)
			}
		}
	}
	retval.TemplateData = v.TemplateData
	return &retval, nil
}

// listTeamsTeamsTeamConnectionNodesTeamDraftWorkflowState includes the requested fields of the GraphQL type WorkflowState.
// The GraphQL type's documentation follows.
//
// A state in a team workflow.
type listTeamsTeamsTeamConnectionNodesTeamDraftWorkflowState struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The state's UI color as a HEX string.
	Color *string `json:"color"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Description of the state.
	Description *string `json:"description"`
	// The state's name.
	Name *string `json:"name"`
	// The position of the state in the team flow.
	Position *float64 `json:"position"`
	// The type of the state.
	Type *string `json:"type"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
}

// GetId returns listTeamsTeamsTeamConnectionNodesTeamDraftWorkflowState.Id, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamDraftWorkflowState) GetId() *string { return v.Id }

// GetArchivedAt returns listTeamsTeamsTeamConnectionNodesTeamDraftWorkflowState.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamDraftWorkflowState) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetColor returns listTeamsTeamsTeamConnectionNodesTeamDraftWorkflowState.Color, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamDraftWorkflowState) GetColor() *string { return v.Color }

// GetCreatedAt returns listTeamsTeamsTeamConnectionNodesTeamDraftWorkflowState.CreatedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamDraftWorkflowState) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetDescription returns listTeamsTeamsTeamConnectionNodesTeamDraftWorkflowState.Description, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamDraftWorkflowState) GetDescription() *string {
	return v.Description
}

// GetName returns listTeamsTeamsTeamConnectionNodesTeamDraftWorkflowState.Name, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamDraftWorkflowState) GetName() *string { return v.Name }

// GetPosition returns listTeamsTeamsTeamConnectionNodesTeamDraftWorkflowState.Position, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamDraftWorkflowState) GetPosition() *float64 {
	return v.Position
}

// GetType returns listTeamsTeamsTeamConnectionNodesTeamDraftWorkflowState.Type, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamDraftWorkflowState) GetType() *string { return v.Type }

// GetUpdatedAt returns listTeamsTeamsTeamConnectionNodesTeamDraftWorkflowState.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamDraftWorkflowState) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

func (v *listTeamsTeamsTeamConnectionNodesTeamDraftWorkflowState) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listTeamsTeamsTeamConnectionNodesTeamDraftWorkflowState
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listTeamsTeamsTeamConnectionNodesTeamDraftWorkflowState = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamDraftWorkflowState.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamDraftWorkflowState.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamDraftWorkflowState.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistTeamsTeamsTeamConnectionNodesTeamDraftWorkflowState struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	Color *string `json:"color"`

	CreatedAt json.RawMessage `json:"createdAt"`

	Description *string `json:"description"`

	Name *string `json:"name"`

	Position *float64 `json:"position"`

	Type *string `json:"type"`

	UpdatedAt json.RawMessage `json:"updatedAt"`
}

func (v *listTeamsTeamsTeamConnectionNodesTeamDraftWorkflowState) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listTeamsTeamsTeamConnectionNodesTeamDraftWorkflowState) __premarshalJSON() (*__premarshallistTeamsTeamsTeamConnectionNodesTeamDraftWorkflowState, error) {
	var retval __premarshallistTeamsTeamsTeamConnectionNodesTeamDraftWorkflowState

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamDraftWorkflowState.ArchivedAt: %w", err)
			}
		}
	}
	retval.Color = v.Color
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamDraftWorkflowState.CreatedAt: %w", err)
			}
		}
	}
	retval.Description = v.Description
	retval.Name = v.Name
	retval.Position = v.Position
	retval.Type = v.Type
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamDraftWorkflowState.UpdatedAt: %w", err)
			}
		}
	}
	return &retval, nil
}

// listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings includes the requested fields of the GraphQL type IntegrationsSettings.
// The GraphQL type's documentation follows.
//
// The configuration of all integrations for a project or a team.
type listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Whether to send a Slack message when a new issue is added to triage.
	SlackIssueAddedToTriage *bool `json:"slackIssueAddedToTriage"`
	// Whether to send a Slack message when a new issue is created for the project or the team.
	SlackIssueCreated *bool `json:"slackIssueCreated"`
	// Whether to send a Slack message when a comment is created on any of the project or team's issues.
	SlackIssueNewComment *bool `json:"slackIssueNewComment"`
	// Whether to send a Slack message when an SLA is breached
	SlackIssueSlaBreached *bool `json:"slackIssueSlaBreached"`
	// Whether to send a Slack message when an SLA is at high risk
	SlackIssueSlaHighRisk *bool `json:"slackIssueSlaHighRisk"`
	// Whether to send a Slack message when any of the project or team's issues has a change in status.
	SlackIssueStatusChangedAll *bool `json:"slackIssueStatusChangedAll"`
	// Whether to send a Slack message when any of the project or team's issues change to completed or cancelled.
	SlackIssueStatusChangedDone *bool `json:"slackIssueStatusChangedDone"`
	// Whether to send a Slack message when a project update is created.
	SlackProjectUpdateCreated *bool `json:"slackProjectUpdateCreated"`
	// Whether to send a new project update to team Slack channels.
	SlackProjectUpdateCreatedToTeam *bool `json:"slackProjectUpdateCreatedToTeam"`
	// Whether to send a new project update to workspace Slack channel.
	SlackProjectUpdateCreatedToWorkspace *bool `json:"slackProjectUpdateCreatedToWorkspace"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
}

// GetId returns listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings.Id, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings) GetId() *string { return v.Id }

// GetArchivedAt returns listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetCreatedAt returns listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings.CreatedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetSlackIssueAddedToTriage returns listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings.SlackIssueAddedToTriage, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings) GetSlackIssueAddedToTriage() *bool {
	return v.SlackIssueAddedToTriage
}

// GetSlackIssueCreated returns listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings.SlackIssueCreated, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings) GetSlackIssueCreated() *bool {
	return v.SlackIssueCreated
}

// GetSlackIssueNewComment returns listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings.SlackIssueNewComment, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings) GetSlackIssueNewComment() *bool {
	return v.SlackIssueNewComment
}

// GetSlackIssueSlaBreached returns listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings.SlackIssueSlaBreached, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings) GetSlackIssueSlaBreached() *bool {
	return v.SlackIssueSlaBreached
}

// GetSlackIssueSlaHighRisk returns listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings.SlackIssueSlaHighRisk, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings) GetSlackIssueSlaHighRisk() *bool {
	return v.SlackIssueSlaHighRisk
}

// GetSlackIssueStatusChangedAll returns listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings.SlackIssueStatusChangedAll, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings) GetSlackIssueStatusChangedAll() *bool {
	return v.SlackIssueStatusChangedAll
}

// GetSlackIssueStatusChangedDone returns listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings.SlackIssueStatusChangedDone, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings) GetSlackIssueStatusChangedDone() *bool {
	return v.SlackIssueStatusChangedDone
}

// GetSlackProjectUpdateCreated returns listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings.SlackProjectUpdateCreated, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings) GetSlackProjectUpdateCreated() *bool {
	return v.SlackProjectUpdateCreated
}

// GetSlackProjectUpdateCreatedToTeam returns listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings.SlackProjectUpdateCreatedToTeam, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings) GetSlackProjectUpdateCreatedToTeam() *bool {
	return v.SlackProjectUpdateCreatedToTeam
}

// GetSlackProjectUpdateCreatedToWorkspace returns listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings.SlackProjectUpdateCreatedToWorkspace, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings) GetSlackProjectUpdateCreatedToWorkspace() *bool {
	return v.SlackProjectUpdateCreatedToWorkspace
}

// GetUpdatedAt returns listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

func (v *listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	CreatedAt json.RawMessage `json:"createdAt"`

	SlackIssueAddedToTriage *bool `json:"slackIssueAddedToTriage"`

	SlackIssueCreated *bool `json:"slackIssueCreated"`

	SlackIssueNewComment *bool `json:"slackIssueNewComment"`

	SlackIssueSlaBreached *bool `json:"slackIssueSlaBreached"`

	SlackIssueSlaHighRisk *bool `json:"slackIssueSlaHighRisk"`

	SlackIssueStatusChangedAll *bool `json:"slackIssueStatusChangedAll"`

	SlackIssueStatusChangedDone *bool `json:"slackIssueStatusChangedDone"`

	SlackProjectUpdateCreated *bool `json:"slackProjectUpdateCreated"`

	SlackProjectUpdateCreatedToTeam *bool `json:"slackProjectUpdateCreatedToTeam"`

	SlackProjectUpdateCreatedToWorkspace *bool `json:"slackProjectUpdateCreatedToWorkspace"`

	UpdatedAt json.RawMessage `json:"updatedAt"`
}

func (v *listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings) __premarshalJSON() (*__premarshallistTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings, error) {
	var retval __premarshallistTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings.ArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings.CreatedAt: %w", err)
			}
		}
	}
	retval.SlackIssueAddedToTriage = v.SlackIssueAddedToTriage
	retval.SlackIssueCreated = v.SlackIssueCreated
	retval.SlackIssueNewComment = v.SlackIssueNewComment
	retval.SlackIssueSlaBreached = v.SlackIssueSlaBreached
	retval.SlackIssueSlaHighRisk = v.SlackIssueSlaHighRisk
	retval.SlackIssueStatusChangedAll = v.SlackIssueStatusChangedAll
	retval.SlackIssueStatusChangedDone = v.SlackIssueStatusChangedDone
	retval.SlackProjectUpdateCreated = v.SlackProjectUpdateCreated
	retval.SlackProjectUpdateCreatedToTeam = v.SlackProjectUpdateCreatedToTeam
	retval.SlackProjectUpdateCreatedToWorkspace = v.SlackProjectUpdateCreatedToWorkspace
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamIntegrationsSettings.UpdatedAt: %w", err)
			}
		}
	}
	return &retval, nil
}

// listTeamsTeamsTeamConnectionNodesTeamMarkedAsDuplicateWorkflowState includes the requested fields of the GraphQL type WorkflowState.
// The GraphQL type's documentation follows.
//
// A state in a team workflow.
type listTeamsTeamsTeamConnectionNodesTeamMarkedAsDuplicateWorkflowState struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The state's UI color as a HEX string.
	Color *string `json:"color"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Description of the state.
	Description *string `json:"description"`
	// The state's name.
	Name *string `json:"name"`
	// The position of the state in the team flow.
	Position *float64 `json:"position"`
	// The type of the state.
	Type *string `json:"type"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
}

// GetId returns listTeamsTeamsTeamConnectionNodesTeamMarkedAsDuplicateWorkflowState.Id, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamMarkedAsDuplicateWorkflowState) GetId() *string {
	return v.Id
}

// GetArchivedAt returns listTeamsTeamsTeamConnectionNodesTeamMarkedAsDuplicateWorkflowState.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamMarkedAsDuplicateWorkflowState) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetColor returns listTeamsTeamsTeamConnectionNodesTeamMarkedAsDuplicateWorkflowState.Color, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamMarkedAsDuplicateWorkflowState) GetColor() *string {
	return v.Color
}

// GetCreatedAt returns listTeamsTeamsTeamConnectionNodesTeamMarkedAsDuplicateWorkflowState.CreatedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamMarkedAsDuplicateWorkflowState) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetDescription returns listTeamsTeamsTeamConnectionNodesTeamMarkedAsDuplicateWorkflowState.Description, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamMarkedAsDuplicateWorkflowState) GetDescription() *string {
	return v.Description
}

// GetName returns listTeamsTeamsTeamConnectionNodesTeamMarkedAsDuplicateWorkflowState.Name, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamMarkedAsDuplicateWorkflowState) GetName() *string {
	return v.Name
}

// GetPosition returns listTeamsTeamsTeamConnectionNodesTeamMarkedAsDuplicateWorkflowState.Position, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamMarkedAsDuplicateWorkflowState) GetPosition() *float64 {
	return v.Position
}

// GetType returns listTeamsTeamsTeamConnectionNodesTeamMarkedAsDuplicateWorkflowState.Type, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamMarkedAsDuplicateWorkflowState) GetType() *string {
	return v.Type
}

// GetUpdatedAt returns listTeamsTeamsTeamConnectionNodesTeamMarkedAsDuplicateWorkflowState.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamMarkedAsDuplicateWorkflowState) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

func (v *listTeamsTeamsTeamConnectionNodesTeamMarkedAsDuplicateWorkflowState) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listTeamsTeamsTeamConnectionNodesTeamMarkedAsDuplicateWorkflowState
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listTeamsTeamsTeamConnectionNodesTeamMarkedAsDuplicateWorkflowState = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamMarkedAsDuplicateWorkflowState.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamMarkedAsDuplicateWorkflowState.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamMarkedAsDuplicateWorkflowState.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistTeamsTeamsTeamConnectionNodesTeamMarkedAsDuplicateWorkflowState struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	Color *string `json:"color"`

	CreatedAt json.RawMessage `json:"createdAt"`

	Description *string `json:"description"`

	Name *string `json:"name"`

	Position *float64 `json:"position"`

	Type *string `json:"type"`

	UpdatedAt json.RawMessage `json:"updatedAt"`
}

func (v *listTeamsTeamsTeamConnectionNodesTeamMarkedAsDuplicateWorkflowState) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listTeamsTeamsTeamConnectionNodesTeamMarkedAsDuplicateWorkflowState) __premarshalJSON() (*__premarshallistTeamsTeamsTeamConnectionNodesTeamMarkedAsDuplicateWorkflowState, error) {
	var retval __premarshallistTeamsTeamsTeamConnectionNodesTeamMarkedAsDuplicateWorkflowState

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamMarkedAsDuplicateWorkflowState.ArchivedAt: %w", err)
			}
		}
	}
	retval.Color = v.Color
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamMarkedAsDuplicateWorkflowState.CreatedAt: %w", err)
			}
		}
	}
	retval.Description = v.Description
	retval.Name = v.Name
	retval.Position = v.Position
	retval.Type = v.Type
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamMarkedAsDuplicateWorkflowState.UpdatedAt: %w", err)
			}
		}
	}
	return &retval, nil
}

// listTeamsTeamsTeamConnectionNodesTeamOrganization includes the requested fields of the GraphQL type Organization.
// The GraphQL type's documentation follows.
//
// An organization. Organizations are root-level objects that contain user accounts and teams.
type listTeamsTeamsTeamConnectionNodesTeamOrganization struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// Allowed authentication providers, empty array means all are allowed
	AllowedAuthServices []*string `json:"allowedAuthServices"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Number of issues in the organization.
	CreatedIssueCount *int `json:"createdIssueCount"`
	// The time at which deletion of the organization was requested.
	DeletionRequestedAt *time.Time `json:"-"`
	// How git branches are formatted. If null, default formatting will be used.
	GitBranchFormat *string `json:"gitBranchFormat"`
	// Whether the Git integration linkback messages should be sent to private repositories.
	GitLinkbackMessagesEnabled *bool `json:"gitLinkbackMessagesEnabled"`
	// Whether the Git integration linkback messages should be sent to public repositories.
	GitPublicLinkbackMessagesEnabled *bool `json:"gitPublicLinkbackMessagesEnabled"`
	// The organization's logo URL.
	LogoUrl *string `json:"logoUrl"`
	// The organization's name.
	Name *string `json:"name"`
	// Rolling 30-day total upload volume for the organization, in megabytes.
	PeriodUploadVolume *float64 `json:"periodUploadVolume"`
	// Previously used URL keys for the organization (last 3 are kept and redirected).
	PreviousUrlKeys []*string `json:"previousUrlKeys"`
	// The day at which to prompt for project updates.
	ProjectUpdateRemindersDay *Day `json:"projectUpdateRemindersDay"`
	// The hour at which to prompt for project updates.
	ProjectUpdateRemindersHour *float64 `json:"projectUpdateRemindersHour"`
	// The frequency at which to prompt for project updates.
	ProjectUpdatesReminderFrequency *ProjectUpdateReminderFrequency `json:"projectUpdatesReminderFrequency"`
	// The feature release channel the organization belongs to.
	ReleaseChannel *ReleaseChannel `json:"releaseChannel"`
	// Whether the organization is using a roadmap.
	RoadmapEnabled *bool `json:"roadmapEnabled"`
	// Whether SAML authentication is enabled for organization.
	SamlEnabled *bool `json:"samlEnabled"`
	// Whether SCIM provisioning is enabled for organization.
	ScimEnabled *bool `json:"scimEnabled"`
	// The time at which the trial of the plus plan will end.
	TrialEndsAt *time.Time `json:"-"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// The organization's unique URL key.
	UrlKey *string `json:"urlKey"`
	// Number of active users in the organization.
	UserCount *int `json:"userCount"`
}

// GetId returns listTeamsTeamsTeamConnectionNodesTeamOrganization.Id, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamOrganization) GetId() *string { return v.Id }

// GetAllowedAuthServices returns listTeamsTeamsTeamConnectionNodesTeamOrganization.AllowedAuthServices, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamOrganization) GetAllowedAuthServices() []*string {
	return v.AllowedAuthServices
}

// GetArchivedAt returns listTeamsTeamsTeamConnectionNodesTeamOrganization.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamOrganization) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetCreatedAt returns listTeamsTeamsTeamConnectionNodesTeamOrganization.CreatedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamOrganization) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetCreatedIssueCount returns listTeamsTeamsTeamConnectionNodesTeamOrganization.CreatedIssueCount, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamOrganization) GetCreatedIssueCount() *int {
	return v.CreatedIssueCount
}

// GetDeletionRequestedAt returns listTeamsTeamsTeamConnectionNodesTeamOrganization.DeletionRequestedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamOrganization) GetDeletionRequestedAt() *time.Time {
	return v.DeletionRequestedAt
}

// GetGitBranchFormat returns listTeamsTeamsTeamConnectionNodesTeamOrganization.GitBranchFormat, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamOrganization) GetGitBranchFormat() *string {
	return v.GitBranchFormat
}

// GetGitLinkbackMessagesEnabled returns listTeamsTeamsTeamConnectionNodesTeamOrganization.GitLinkbackMessagesEnabled, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamOrganization) GetGitLinkbackMessagesEnabled() *bool {
	return v.GitLinkbackMessagesEnabled
}

// GetGitPublicLinkbackMessagesEnabled returns listTeamsTeamsTeamConnectionNodesTeamOrganization.GitPublicLinkbackMessagesEnabled, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamOrganization) GetGitPublicLinkbackMessagesEnabled() *bool {
	return v.GitPublicLinkbackMessagesEnabled
}

// GetLogoUrl returns listTeamsTeamsTeamConnectionNodesTeamOrganization.LogoUrl, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamOrganization) GetLogoUrl() *string { return v.LogoUrl }

// GetName returns listTeamsTeamsTeamConnectionNodesTeamOrganization.Name, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamOrganization) GetName() *string { return v.Name }

// GetPeriodUploadVolume returns listTeamsTeamsTeamConnectionNodesTeamOrganization.PeriodUploadVolume, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamOrganization) GetPeriodUploadVolume() *float64 {
	return v.PeriodUploadVolume
}

// GetPreviousUrlKeys returns listTeamsTeamsTeamConnectionNodesTeamOrganization.PreviousUrlKeys, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamOrganization) GetPreviousUrlKeys() []*string {
	return v.PreviousUrlKeys
}

// GetProjectUpdateRemindersDay returns listTeamsTeamsTeamConnectionNodesTeamOrganization.ProjectUpdateRemindersDay, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamOrganization) GetProjectUpdateRemindersDay() *Day {
	return v.ProjectUpdateRemindersDay
}

// GetProjectUpdateRemindersHour returns listTeamsTeamsTeamConnectionNodesTeamOrganization.ProjectUpdateRemindersHour, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamOrganization) GetProjectUpdateRemindersHour() *float64 {
	return v.ProjectUpdateRemindersHour
}

// GetProjectUpdatesReminderFrequency returns listTeamsTeamsTeamConnectionNodesTeamOrganization.ProjectUpdatesReminderFrequency, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamOrganization) GetProjectUpdatesReminderFrequency() *ProjectUpdateReminderFrequency {
	return v.ProjectUpdatesReminderFrequency
}

// GetReleaseChannel returns listTeamsTeamsTeamConnectionNodesTeamOrganization.ReleaseChannel, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamOrganization) GetReleaseChannel() *ReleaseChannel {
	return v.ReleaseChannel
}

// GetRoadmapEnabled returns listTeamsTeamsTeamConnectionNodesTeamOrganization.RoadmapEnabled, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamOrganization) GetRoadmapEnabled() *bool {
	return v.RoadmapEnabled
}

// GetSamlEnabled returns listTeamsTeamsTeamConnectionNodesTeamOrganization.SamlEnabled, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamOrganization) GetSamlEnabled() *bool {
	return v.SamlEnabled
}

// GetScimEnabled returns listTeamsTeamsTeamConnectionNodesTeamOrganization.ScimEnabled, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamOrganization) GetScimEnabled() *bool {
	return v.ScimEnabled
}

// GetTrialEndsAt returns listTeamsTeamsTeamConnectionNodesTeamOrganization.TrialEndsAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamOrganization) GetTrialEndsAt() *time.Time {
	return v.TrialEndsAt
}

// GetUpdatedAt returns listTeamsTeamsTeamConnectionNodesTeamOrganization.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamOrganization) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

// GetUrlKey returns listTeamsTeamsTeamConnectionNodesTeamOrganization.UrlKey, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamOrganization) GetUrlKey() *string { return v.UrlKey }

// GetUserCount returns listTeamsTeamsTeamConnectionNodesTeamOrganization.UserCount, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamOrganization) GetUserCount() *int { return v.UserCount }

func (v *listTeamsTeamsTeamConnectionNodesTeamOrganization) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listTeamsTeamsTeamConnectionNodesTeamOrganization
		ArchivedAt          json.RawMessage `json:"archivedAt"`
		CreatedAt           json.RawMessage `json:"createdAt"`
		DeletionRequestedAt json.RawMessage `json:"deletionRequestedAt"`
		TrialEndsAt         json.RawMessage `json:"trialEndsAt"`
		UpdatedAt           json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listTeamsTeamsTeamConnectionNodesTeamOrganization = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamOrganization.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamOrganization.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.DeletionRequestedAt
		src := firstPass.DeletionRequestedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamOrganization.DeletionRequestedAt: %w", err)
			}
		}
	}

	{
		dst := &v.TrialEndsAt
		src := firstPass.TrialEndsAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamOrganization.TrialEndsAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamOrganization.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistTeamsTeamsTeamConnectionNodesTeamOrganization struct {
	Id *string `json:"id"`

	AllowedAuthServices []*string `json:"allowedAuthServices"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CreatedIssueCount *int `json:"createdIssueCount"`

	DeletionRequestedAt json.RawMessage `json:"deletionRequestedAt"`

	GitBranchFormat *string `json:"gitBranchFormat"`

	GitLinkbackMessagesEnabled *bool `json:"gitLinkbackMessagesEnabled"`

	GitPublicLinkbackMessagesEnabled *bool `json:"gitPublicLinkbackMessagesEnabled"`

	LogoUrl *string `json:"logoUrl"`

	Name *string `json:"name"`

	PeriodUploadVolume *float64 `json:"periodUploadVolume"`

	PreviousUrlKeys []*string `json:"previousUrlKeys"`

	ProjectUpdateRemindersDay *Day `json:"projectUpdateRemindersDay"`

	ProjectUpdateRemindersHour *float64 `json:"projectUpdateRemindersHour"`

	ProjectUpdatesReminderFrequency *ProjectUpdateReminderFrequency `json:"projectUpdatesReminderFrequency"`

	ReleaseChannel *ReleaseChannel `json:"releaseChannel"`

	RoadmapEnabled *bool `json:"roadmapEnabled"`

	SamlEnabled *bool `json:"samlEnabled"`

	ScimEnabled *bool `json:"scimEnabled"`

	TrialEndsAt json.RawMessage `json:"trialEndsAt"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	UrlKey *string `json:"urlKey"`

	UserCount *int `json:"userCount"`
}

func (v *listTeamsTeamsTeamConnectionNodesTeamOrganization) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listTeamsTeamsTeamConnectionNodesTeamOrganization) __premarshalJSON() (*__premarshallistTeamsTeamsTeamConnectionNodesTeamOrganization, error) {
	var retval __premarshallistTeamsTeamsTeamConnectionNodesTeamOrganization

	retval.Id = v.Id
	retval.AllowedAuthServices = v.AllowedAuthServices
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamOrganization.ArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamOrganization.CreatedAt: %w", err)
			}
		}
	}
	retval.CreatedIssueCount = v.CreatedIssueCount
	{

		dst := &retval.DeletionRequestedAt
		src := v.DeletionRequestedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamOrganization.DeletionRequestedAt: %w", err)
			}
		}
	}
	retval.GitBranchFormat = v.GitBranchFormat
	retval.GitLinkbackMessagesEnabled = v.GitLinkbackMessagesEnabled
	retval.GitPublicLinkbackMessagesEnabled = v.GitPublicLinkbackMessagesEnabled
	retval.LogoUrl = v.LogoUrl
	retval.Name = v.Name
	retval.PeriodUploadVolume = v.PeriodUploadVolume
	retval.PreviousUrlKeys = v.PreviousUrlKeys
	retval.ProjectUpdateRemindersDay = v.ProjectUpdateRemindersDay
	retval.ProjectUpdateRemindersHour = v.ProjectUpdateRemindersHour
	retval.ProjectUpdatesReminderFrequency = v.ProjectUpdatesReminderFrequency
	retval.ReleaseChannel = v.ReleaseChannel
	retval.RoadmapEnabled = v.RoadmapEnabled
	retval.SamlEnabled = v.SamlEnabled
	retval.ScimEnabled = v.ScimEnabled
	{

		dst := &retval.TrialEndsAt
		src := v.TrialEndsAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamOrganization.TrialEndsAt: %w", err)
			}
		}
	}
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamOrganization.UpdatedAt: %w", err)
			}
		}
	}
	retval.UrlKey = v.UrlKey
	retval.UserCount = v.UserCount
	return &retval, nil
}

// listTeamsTeamsTeamConnectionNodesTeamReviewWorkflowState includes the requested fields of the GraphQL type WorkflowState.
// The GraphQL type's documentation follows.
//
// A state in a team workflow.
type listTeamsTeamsTeamConnectionNodesTeamReviewWorkflowState struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The state's UI color as a HEX string.
	Color *string `json:"color"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Description of the state.
	Description *string `json:"description"`
	// The state's name.
	Name *string `json:"name"`
	// The position of the state in the team flow.
	Position *float64 `json:"position"`
	// The type of the state.
	Type *string `json:"type"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
}

// GetId returns listTeamsTeamsTeamConnectionNodesTeamReviewWorkflowState.Id, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamReviewWorkflowState) GetId() *string { return v.Id }

// GetArchivedAt returns listTeamsTeamsTeamConnectionNodesTeamReviewWorkflowState.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamReviewWorkflowState) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetColor returns listTeamsTeamsTeamConnectionNodesTeamReviewWorkflowState.Color, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamReviewWorkflowState) GetColor() *string { return v.Color }

// GetCreatedAt returns listTeamsTeamsTeamConnectionNodesTeamReviewWorkflowState.CreatedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamReviewWorkflowState) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetDescription returns listTeamsTeamsTeamConnectionNodesTeamReviewWorkflowState.Description, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamReviewWorkflowState) GetDescription() *string {
	return v.Description
}

// GetName returns listTeamsTeamsTeamConnectionNodesTeamReviewWorkflowState.Name, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamReviewWorkflowState) GetName() *string { return v.Name }

// GetPosition returns listTeamsTeamsTeamConnectionNodesTeamReviewWorkflowState.Position, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamReviewWorkflowState) GetPosition() *float64 {
	return v.Position
}

// GetType returns listTeamsTeamsTeamConnectionNodesTeamReviewWorkflowState.Type, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamReviewWorkflowState) GetType() *string { return v.Type }

// GetUpdatedAt returns listTeamsTeamsTeamConnectionNodesTeamReviewWorkflowState.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamReviewWorkflowState) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

func (v *listTeamsTeamsTeamConnectionNodesTeamReviewWorkflowState) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listTeamsTeamsTeamConnectionNodesTeamReviewWorkflowState
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listTeamsTeamsTeamConnectionNodesTeamReviewWorkflowState = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamReviewWorkflowState.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamReviewWorkflowState.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamReviewWorkflowState.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistTeamsTeamsTeamConnectionNodesTeamReviewWorkflowState struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	Color *string `json:"color"`

	CreatedAt json.RawMessage `json:"createdAt"`

	Description *string `json:"description"`

	Name *string `json:"name"`

	Position *float64 `json:"position"`

	Type *string `json:"type"`

	UpdatedAt json.RawMessage `json:"updatedAt"`
}

func (v *listTeamsTeamsTeamConnectionNodesTeamReviewWorkflowState) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listTeamsTeamsTeamConnectionNodesTeamReviewWorkflowState) __premarshalJSON() (*__premarshallistTeamsTeamsTeamConnectionNodesTeamReviewWorkflowState, error) {
	var retval __premarshallistTeamsTeamsTeamConnectionNodesTeamReviewWorkflowState

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamReviewWorkflowState.ArchivedAt: %w", err)
			}
		}
	}
	retval.Color = v.Color
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamReviewWorkflowState.CreatedAt: %w", err)
			}
		}
	}
	retval.Description = v.Description
	retval.Name = v.Name
	retval.Position = v.Position
	retval.Type = v.Type
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamReviewWorkflowState.UpdatedAt: %w", err)
			}
		}
	}
	return &retval, nil
}

// listTeamsTeamsTeamConnectionNodesTeamStartWorkflowState includes the requested fields of the GraphQL type WorkflowState.
// The GraphQL type's documentation follows.
//
// A state in a team workflow.
type listTeamsTeamsTeamConnectionNodesTeamStartWorkflowState struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The state's UI color as a HEX string.
	Color *string `json:"color"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Description of the state.
	Description *string `json:"description"`
	// The state's name.
	Name *string `json:"name"`
	// The position of the state in the team flow.
	Position *float64 `json:"position"`
	// The type of the state.
	Type *string `json:"type"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
}

// GetId returns listTeamsTeamsTeamConnectionNodesTeamStartWorkflowState.Id, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamStartWorkflowState) GetId() *string { return v.Id }

// GetArchivedAt returns listTeamsTeamsTeamConnectionNodesTeamStartWorkflowState.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamStartWorkflowState) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetColor returns listTeamsTeamsTeamConnectionNodesTeamStartWorkflowState.Color, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamStartWorkflowState) GetColor() *string { return v.Color }

// GetCreatedAt returns listTeamsTeamsTeamConnectionNodesTeamStartWorkflowState.CreatedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamStartWorkflowState) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetDescription returns listTeamsTeamsTeamConnectionNodesTeamStartWorkflowState.Description, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamStartWorkflowState) GetDescription() *string {
	return v.Description
}

// GetName returns listTeamsTeamsTeamConnectionNodesTeamStartWorkflowState.Name, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamStartWorkflowState) GetName() *string { return v.Name }

// GetPosition returns listTeamsTeamsTeamConnectionNodesTeamStartWorkflowState.Position, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamStartWorkflowState) GetPosition() *float64 {
	return v.Position
}

// GetType returns listTeamsTeamsTeamConnectionNodesTeamStartWorkflowState.Type, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamStartWorkflowState) GetType() *string { return v.Type }

// GetUpdatedAt returns listTeamsTeamsTeamConnectionNodesTeamStartWorkflowState.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamStartWorkflowState) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

func (v *listTeamsTeamsTeamConnectionNodesTeamStartWorkflowState) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listTeamsTeamsTeamConnectionNodesTeamStartWorkflowState
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listTeamsTeamsTeamConnectionNodesTeamStartWorkflowState = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamStartWorkflowState.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamStartWorkflowState.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamStartWorkflowState.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistTeamsTeamsTeamConnectionNodesTeamStartWorkflowState struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	Color *string `json:"color"`

	CreatedAt json.RawMessage `json:"createdAt"`

	Description *string `json:"description"`

	Name *string `json:"name"`

	Position *float64 `json:"position"`

	Type *string `json:"type"`

	UpdatedAt json.RawMessage `json:"updatedAt"`
}

func (v *listTeamsTeamsTeamConnectionNodesTeamStartWorkflowState) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listTeamsTeamsTeamConnectionNodesTeamStartWorkflowState) __premarshalJSON() (*__premarshallistTeamsTeamsTeamConnectionNodesTeamStartWorkflowState, error) {
	var retval __premarshallistTeamsTeamsTeamConnectionNodesTeamStartWorkflowState

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamStartWorkflowState.ArchivedAt: %w", err)
			}
		}
	}
	retval.Color = v.Color
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamStartWorkflowState.CreatedAt: %w", err)
			}
		}
	}
	retval.Description = v.Description
	retval.Name = v.Name
	retval.Position = v.Position
	retval.Type = v.Type
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamStartWorkflowState.UpdatedAt: %w", err)
			}
		}
	}
	return &retval, nil
}

// listTeamsTeamsTeamConnectionNodesTeamTriageIssueStateWorkflowState includes the requested fields of the GraphQL type WorkflowState.
// The GraphQL type's documentation follows.
//
// A state in a team workflow.
type listTeamsTeamsTeamConnectionNodesTeamTriageIssueStateWorkflowState struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The state's UI color as a HEX string.
	Color *string `json:"color"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Description of the state.
	Description *string `json:"description"`
	// The state's name.
	Name *string `json:"name"`
	// The position of the state in the team flow.
	Position *float64 `json:"position"`
	// The type of the state.
	Type *string `json:"type"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
}

// GetId returns listTeamsTeamsTeamConnectionNodesTeamTriageIssueStateWorkflowState.Id, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamTriageIssueStateWorkflowState) GetId() *string {
	return v.Id
}

// GetArchivedAt returns listTeamsTeamsTeamConnectionNodesTeamTriageIssueStateWorkflowState.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamTriageIssueStateWorkflowState) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetColor returns listTeamsTeamsTeamConnectionNodesTeamTriageIssueStateWorkflowState.Color, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamTriageIssueStateWorkflowState) GetColor() *string {
	return v.Color
}

// GetCreatedAt returns listTeamsTeamsTeamConnectionNodesTeamTriageIssueStateWorkflowState.CreatedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamTriageIssueStateWorkflowState) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetDescription returns listTeamsTeamsTeamConnectionNodesTeamTriageIssueStateWorkflowState.Description, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamTriageIssueStateWorkflowState) GetDescription() *string {
	return v.Description
}

// GetName returns listTeamsTeamsTeamConnectionNodesTeamTriageIssueStateWorkflowState.Name, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamTriageIssueStateWorkflowState) GetName() *string {
	return v.Name
}

// GetPosition returns listTeamsTeamsTeamConnectionNodesTeamTriageIssueStateWorkflowState.Position, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamTriageIssueStateWorkflowState) GetPosition() *float64 {
	return v.Position
}

// GetType returns listTeamsTeamsTeamConnectionNodesTeamTriageIssueStateWorkflowState.Type, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamTriageIssueStateWorkflowState) GetType() *string {
	return v.Type
}

// GetUpdatedAt returns listTeamsTeamsTeamConnectionNodesTeamTriageIssueStateWorkflowState.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionNodesTeamTriageIssueStateWorkflowState) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

func (v *listTeamsTeamsTeamConnectionNodesTeamTriageIssueStateWorkflowState) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listTeamsTeamsTeamConnectionNodesTeamTriageIssueStateWorkflowState
		ArchivedAt json.RawMessage `json:"archivedAt"`
		CreatedAt  json.RawMessage `json:"createdAt"`
		UpdatedAt  json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listTeamsTeamsTeamConnectionNodesTeamTriageIssueStateWorkflowState = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamTriageIssueStateWorkflowState.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamTriageIssueStateWorkflowState.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listTeamsTeamsTeamConnectionNodesTeamTriageIssueStateWorkflowState.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistTeamsTeamsTeamConnectionNodesTeamTriageIssueStateWorkflowState struct {
	Id *string `json:"id"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	Color *string `json:"color"`

	CreatedAt json.RawMessage `json:"createdAt"`

	Description *string `json:"description"`

	Name *string `json:"name"`

	Position *float64 `json:"position"`

	Type *string `json:"type"`

	UpdatedAt json.RawMessage `json:"updatedAt"`
}

func (v *listTeamsTeamsTeamConnectionNodesTeamTriageIssueStateWorkflowState) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listTeamsTeamsTeamConnectionNodesTeamTriageIssueStateWorkflowState) __premarshalJSON() (*__premarshallistTeamsTeamsTeamConnectionNodesTeamTriageIssueStateWorkflowState, error) {
	var retval __premarshallistTeamsTeamsTeamConnectionNodesTeamTriageIssueStateWorkflowState

	retval.Id = v.Id
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamTriageIssueStateWorkflowState.ArchivedAt: %w", err)
			}
		}
	}
	retval.Color = v.Color
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamTriageIssueStateWorkflowState.CreatedAt: %w", err)
			}
		}
	}
	retval.Description = v.Description
	retval.Name = v.Name
	retval.Position = v.Position
	retval.Type = v.Type
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listTeamsTeamsTeamConnectionNodesTeamTriageIssueStateWorkflowState.UpdatedAt: %w", err)
			}
		}
	}
	return &retval, nil
}

// listTeamsTeamsTeamConnectionPageInfo includes the requested fields of the GraphQL type PageInfo.
type listTeamsTeamsTeamConnectionPageInfo struct {
	// Indicates if there are more results when paginating forward.
	HasNextPage *bool `json:"hasNextPage"`
	// Cursor representing the last result in the paginated results.
	EndCursor *string `json:"endCursor"`
}

// GetHasNextPage returns listTeamsTeamsTeamConnectionPageInfo.HasNextPage, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionPageInfo) GetHasNextPage() *bool { return v.HasNextPage }

// GetEndCursor returns listTeamsTeamsTeamConnectionPageInfo.EndCursor, and is useful for accessing the field via an interface.
func (v *listTeamsTeamsTeamConnectionPageInfo) GetEndCursor() *string { return v.EndCursor }

// listUsersResponse is returned by listUsers on success.
type listUsersResponse struct {
	// All users for the organization.
	Users *listUsersUsersUserConnection `json:"users"`
}

// GetUsers returns listUsersResponse.Users, and is useful for accessing the field via an interface.
func (v *listUsersResponse) GetUsers() *listUsersUsersUserConnection { return v.Users }

// listUsersUsersUserConnection includes the requested fields of the GraphQL type UserConnection.
type listUsersUsersUserConnection struct {
	PageInfo *listUsersUsersUserConnectionPageInfo    `json:"pageInfo"`
	Nodes    []*listUsersUsersUserConnectionNodesUser `json:"nodes"`
}

// GetPageInfo returns listUsersUsersUserConnection.PageInfo, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnection) GetPageInfo() *listUsersUsersUserConnectionPageInfo {
	return v.PageInfo
}

// GetNodes returns listUsersUsersUserConnection.Nodes, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnection) GetNodes() []*listUsersUsersUserConnectionNodesUser {
	return v.Nodes
}

// listUsersUsersUserConnectionNodesUser includes the requested fields of the GraphQL type User.
// The GraphQL type's documentation follows.
//
// A user that has access to the the resources of an organization.
type listUsersUsersUserConnectionNodesUser struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// Whether the user account is active or disabled (suspended).
	Active *bool `json:"active"`
	// Whether the user is an organization administrator.
	Admin *bool `json:"admin"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// An URL to the user's avatar image.
	AvatarUrl *string `json:"avatarUrl"`
	// [DEPRECATED] Hash for the user to be used in calendar URLs.
	CalendarHash *string `json:"calendarHash"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Number of issues created.
	CreatedIssueCount *int `json:"createdIssueCount"`
	// A short description of the user, either its title or bio.
	Description *string `json:"description"`
	// Reason why is the account disabled.
	DisableReason *string `json:"disableReason"`
	// The user's display (nick) name. Unique within each organization.
	DisplayName *string `json:"displayName"`
	// The user's email address.
	Email *string `json:"email"`
	// Whether the user is a guest in the workspace and limited to accessing a subset of teams.
	Guest *bool `json:"guest"`
	// Unique hash for the user to be used in invite URLs.
	InviteHash *string `json:"inviteHash"`
	// Whether the user is the currently authenticated user.
	IsMe *bool `json:"isMe"`
	// The last time the user was seen online. If null, the user is currently online.
	LastSeen *time.Time `json:"-"`
	// The user's full name.
	Name *string `json:"name"`
	// The emoji to represent the user current status.
	StatusEmoji *string `json:"statusEmoji"`
	// The label of the user current status.
	StatusLabel *string `json:"statusLabel"`
	// A date at which the user current status should be cleared.
	StatusUntilAt *time.Time `json:"-"`
	// The local timezone of the user.
	Timezone *string `json:"timezone"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// User's profile URL.
	Url *string `json:"url"`
	// Organization the user belongs to.
	Organization *listUsersUsersUserConnectionNodesUserOrganization `json:"organization"`
}

// GetId returns listUsersUsersUserConnectionNodesUser.Id, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUser) GetId() *string { return v.Id }

// GetActive returns listUsersUsersUserConnectionNodesUser.Active, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUser) GetActive() *bool { return v.Active }

// GetAdmin returns listUsersUsersUserConnectionNodesUser.Admin, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUser) GetAdmin() *bool { return v.Admin }

// GetArchivedAt returns listUsersUsersUserConnectionNodesUser.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUser) GetArchivedAt() *time.Time { return v.ArchivedAt }

// GetAvatarUrl returns listUsersUsersUserConnectionNodesUser.AvatarUrl, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUser) GetAvatarUrl() *string { return v.AvatarUrl }

// GetCalendarHash returns listUsersUsersUserConnectionNodesUser.CalendarHash, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUser) GetCalendarHash() *string { return v.CalendarHash }

// GetCreatedAt returns listUsersUsersUserConnectionNodesUser.CreatedAt, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUser) GetCreatedAt() *time.Time { return v.CreatedAt }

// GetCreatedIssueCount returns listUsersUsersUserConnectionNodesUser.CreatedIssueCount, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUser) GetCreatedIssueCount() *int {
	return v.CreatedIssueCount
}

// GetDescription returns listUsersUsersUserConnectionNodesUser.Description, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUser) GetDescription() *string { return v.Description }

// GetDisableReason returns listUsersUsersUserConnectionNodesUser.DisableReason, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUser) GetDisableReason() *string { return v.DisableReason }

// GetDisplayName returns listUsersUsersUserConnectionNodesUser.DisplayName, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUser) GetDisplayName() *string { return v.DisplayName }

// GetEmail returns listUsersUsersUserConnectionNodesUser.Email, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUser) GetEmail() *string { return v.Email }

// GetGuest returns listUsersUsersUserConnectionNodesUser.Guest, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUser) GetGuest() *bool { return v.Guest }

// GetInviteHash returns listUsersUsersUserConnectionNodesUser.InviteHash, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUser) GetInviteHash() *string { return v.InviteHash }

// GetIsMe returns listUsersUsersUserConnectionNodesUser.IsMe, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUser) GetIsMe() *bool { return v.IsMe }

// GetLastSeen returns listUsersUsersUserConnectionNodesUser.LastSeen, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUser) GetLastSeen() *time.Time { return v.LastSeen }

// GetName returns listUsersUsersUserConnectionNodesUser.Name, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUser) GetName() *string { return v.Name }

// GetStatusEmoji returns listUsersUsersUserConnectionNodesUser.StatusEmoji, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUser) GetStatusEmoji() *string { return v.StatusEmoji }

// GetStatusLabel returns listUsersUsersUserConnectionNodesUser.StatusLabel, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUser) GetStatusLabel() *string { return v.StatusLabel }

// GetStatusUntilAt returns listUsersUsersUserConnectionNodesUser.StatusUntilAt, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUser) GetStatusUntilAt() *time.Time { return v.StatusUntilAt }

// GetTimezone returns listUsersUsersUserConnectionNodesUser.Timezone, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUser) GetTimezone() *string { return v.Timezone }

// GetUpdatedAt returns listUsersUsersUserConnectionNodesUser.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUser) GetUpdatedAt() *time.Time { return v.UpdatedAt }

// GetUrl returns listUsersUsersUserConnectionNodesUser.Url, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUser) GetUrl() *string { return v.Url }

// GetOrganization returns listUsersUsersUserConnectionNodesUser.Organization, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUser) GetOrganization() *listUsersUsersUserConnectionNodesUserOrganization {
	return v.Organization
}

func (v *listUsersUsersUserConnectionNodesUser) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listUsersUsersUserConnectionNodesUser
		ArchivedAt    json.RawMessage `json:"archivedAt"`
		CreatedAt     json.RawMessage `json:"createdAt"`
		LastSeen      json.RawMessage `json:"lastSeen"`
		StatusUntilAt json.RawMessage `json:"statusUntilAt"`
		UpdatedAt     json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listUsersUsersUserConnectionNodesUser = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listUsersUsersUserConnectionNodesUser.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listUsersUsersUserConnectionNodesUser.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.LastSeen
		src := firstPass.LastSeen
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listUsersUsersUserConnectionNodesUser.LastSeen: %w", err)
			}
		}
	}

	{
		dst := &v.StatusUntilAt
		src := firstPass.StatusUntilAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listUsersUsersUserConnectionNodesUser.StatusUntilAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listUsersUsersUserConnectionNodesUser.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistUsersUsersUserConnectionNodesUser struct {
	Id *string `json:"id"`

	Active *bool `json:"active"`

	Admin *bool `json:"admin"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	AvatarUrl *string `json:"avatarUrl"`

	CalendarHash *string `json:"calendarHash"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CreatedIssueCount *int `json:"createdIssueCount"`

	Description *string `json:"description"`

	DisableReason *string `json:"disableReason"`

	DisplayName *string `json:"displayName"`

	Email *string `json:"email"`

	Guest *bool `json:"guest"`

	InviteHash *string `json:"inviteHash"`

	IsMe *bool `json:"isMe"`

	LastSeen json.RawMessage `json:"lastSeen"`

	Name *string `json:"name"`

	StatusEmoji *string `json:"statusEmoji"`

	StatusLabel *string `json:"statusLabel"`

	StatusUntilAt json.RawMessage `json:"statusUntilAt"`

	Timezone *string `json:"timezone"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	Url *string `json:"url"`

	Organization *listUsersUsersUserConnectionNodesUserOrganization `json:"organization"`
}

func (v *listUsersUsersUserConnectionNodesUser) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listUsersUsersUserConnectionNodesUser) __premarshalJSON() (*__premarshallistUsersUsersUserConnectionNodesUser, error) {
	var retval __premarshallistUsersUsersUserConnectionNodesUser

	retval.Id = v.Id
	retval.Active = v.Active
	retval.Admin = v.Admin
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listUsersUsersUserConnectionNodesUser.ArchivedAt: %w", err)
			}
		}
	}
	retval.AvatarUrl = v.AvatarUrl
	retval.CalendarHash = v.CalendarHash
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listUsersUsersUserConnectionNodesUser.CreatedAt: %w", err)
			}
		}
	}
	retval.CreatedIssueCount = v.CreatedIssueCount
	retval.Description = v.Description
	retval.DisableReason = v.DisableReason
	retval.DisplayName = v.DisplayName
	retval.Email = v.Email
	retval.Guest = v.Guest
	retval.InviteHash = v.InviteHash
	retval.IsMe = v.IsMe
	{

		dst := &retval.LastSeen
		src := v.LastSeen
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listUsersUsersUserConnectionNodesUser.LastSeen: %w", err)
			}
		}
	}
	retval.Name = v.Name
	retval.StatusEmoji = v.StatusEmoji
	retval.StatusLabel = v.StatusLabel
	{

		dst := &retval.StatusUntilAt
		src := v.StatusUntilAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listUsersUsersUserConnectionNodesUser.StatusUntilAt: %w", err)
			}
		}
	}
	retval.Timezone = v.Timezone
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listUsersUsersUserConnectionNodesUser.UpdatedAt: %w", err)
			}
		}
	}
	retval.Url = v.Url
	retval.Organization = v.Organization
	return &retval, nil
}

// listUsersUsersUserConnectionNodesUserOrganization includes the requested fields of the GraphQL type Organization.
// The GraphQL type's documentation follows.
//
// An organization. Organizations are root-level objects that contain user accounts and teams.
type listUsersUsersUserConnectionNodesUserOrganization struct {
	// The unique identifier of the entity.
	Id *string `json:"id"`
	// Allowed authentication providers, empty array means all are allowed
	AllowedAuthServices []*string `json:"allowedAuthServices"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *time.Time `json:"-"`
	// The time at which the entity was created.
	CreatedAt *time.Time `json:"-"`
	// Number of issues in the organization.
	CreatedIssueCount *int `json:"createdIssueCount"`
	// The time at which deletion of the organization was requested.
	DeletionRequestedAt *time.Time `json:"-"`
	// How git branches are formatted. If null, default formatting will be used.
	GitBranchFormat *string `json:"gitBranchFormat"`
	// Whether the Git integration linkback messages should be sent to private repositories.
	GitLinkbackMessagesEnabled *bool `json:"gitLinkbackMessagesEnabled"`
	// Whether the Git integration linkback messages should be sent to public repositories.
	GitPublicLinkbackMessagesEnabled *bool `json:"gitPublicLinkbackMessagesEnabled"`
	// The organization's logo URL.
	LogoUrl *string `json:"logoUrl"`
	// The organization's name.
	Name *string `json:"name"`
	// Rolling 30-day total upload volume for the organization, in megabytes.
	PeriodUploadVolume *float64 `json:"periodUploadVolume"`
	// Previously used URL keys for the organization (last 3 are kept and redirected).
	PreviousUrlKeys []*string `json:"previousUrlKeys"`
	// The day at which to prompt for project updates.
	ProjectUpdateRemindersDay *Day `json:"projectUpdateRemindersDay"`
	// The hour at which to prompt for project updates.
	ProjectUpdateRemindersHour *float64 `json:"projectUpdateRemindersHour"`
	// The frequency at which to prompt for project updates.
	ProjectUpdatesReminderFrequency *ProjectUpdateReminderFrequency `json:"projectUpdatesReminderFrequency"`
	// The feature release channel the organization belongs to.
	ReleaseChannel *ReleaseChannel `json:"releaseChannel"`
	// Whether the organization is using a roadmap.
	RoadmapEnabled *bool `json:"roadmapEnabled"`
	// Whether SAML authentication is enabled for organization.
	SamlEnabled *bool `json:"samlEnabled"`
	// Whether SCIM provisioning is enabled for organization.
	ScimEnabled *bool `json:"scimEnabled"`
	// The time at which the trial of the plus plan will end.
	TrialEndsAt *time.Time `json:"-"`
	// The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
	// for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
	// been updated after creation.
	UpdatedAt *time.Time `json:"-"`
	// The organization's unique URL key.
	UrlKey *string `json:"urlKey"`
	// Number of active users in the organization.
	UserCount *int `json:"userCount"`
}

// GetId returns listUsersUsersUserConnectionNodesUserOrganization.Id, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUserOrganization) GetId() *string { return v.Id }

// GetAllowedAuthServices returns listUsersUsersUserConnectionNodesUserOrganization.AllowedAuthServices, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUserOrganization) GetAllowedAuthServices() []*string {
	return v.AllowedAuthServices
}

// GetArchivedAt returns listUsersUsersUserConnectionNodesUserOrganization.ArchivedAt, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUserOrganization) GetArchivedAt() *time.Time {
	return v.ArchivedAt
}

// GetCreatedAt returns listUsersUsersUserConnectionNodesUserOrganization.CreatedAt, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUserOrganization) GetCreatedAt() *time.Time {
	return v.CreatedAt
}

// GetCreatedIssueCount returns listUsersUsersUserConnectionNodesUserOrganization.CreatedIssueCount, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUserOrganization) GetCreatedIssueCount() *int {
	return v.CreatedIssueCount
}

// GetDeletionRequestedAt returns listUsersUsersUserConnectionNodesUserOrganization.DeletionRequestedAt, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUserOrganization) GetDeletionRequestedAt() *time.Time {
	return v.DeletionRequestedAt
}

// GetGitBranchFormat returns listUsersUsersUserConnectionNodesUserOrganization.GitBranchFormat, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUserOrganization) GetGitBranchFormat() *string {
	return v.GitBranchFormat
}

// GetGitLinkbackMessagesEnabled returns listUsersUsersUserConnectionNodesUserOrganization.GitLinkbackMessagesEnabled, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUserOrganization) GetGitLinkbackMessagesEnabled() *bool {
	return v.GitLinkbackMessagesEnabled
}

// GetGitPublicLinkbackMessagesEnabled returns listUsersUsersUserConnectionNodesUserOrganization.GitPublicLinkbackMessagesEnabled, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUserOrganization) GetGitPublicLinkbackMessagesEnabled() *bool {
	return v.GitPublicLinkbackMessagesEnabled
}

// GetLogoUrl returns listUsersUsersUserConnectionNodesUserOrganization.LogoUrl, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUserOrganization) GetLogoUrl() *string { return v.LogoUrl }

// GetName returns listUsersUsersUserConnectionNodesUserOrganization.Name, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUserOrganization) GetName() *string { return v.Name }

// GetPeriodUploadVolume returns listUsersUsersUserConnectionNodesUserOrganization.PeriodUploadVolume, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUserOrganization) GetPeriodUploadVolume() *float64 {
	return v.PeriodUploadVolume
}

// GetPreviousUrlKeys returns listUsersUsersUserConnectionNodesUserOrganization.PreviousUrlKeys, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUserOrganization) GetPreviousUrlKeys() []*string {
	return v.PreviousUrlKeys
}

// GetProjectUpdateRemindersDay returns listUsersUsersUserConnectionNodesUserOrganization.ProjectUpdateRemindersDay, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUserOrganization) GetProjectUpdateRemindersDay() *Day {
	return v.ProjectUpdateRemindersDay
}

// GetProjectUpdateRemindersHour returns listUsersUsersUserConnectionNodesUserOrganization.ProjectUpdateRemindersHour, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUserOrganization) GetProjectUpdateRemindersHour() *float64 {
	return v.ProjectUpdateRemindersHour
}

// GetProjectUpdatesReminderFrequency returns listUsersUsersUserConnectionNodesUserOrganization.ProjectUpdatesReminderFrequency, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUserOrganization) GetProjectUpdatesReminderFrequency() *ProjectUpdateReminderFrequency {
	return v.ProjectUpdatesReminderFrequency
}

// GetReleaseChannel returns listUsersUsersUserConnectionNodesUserOrganization.ReleaseChannel, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUserOrganization) GetReleaseChannel() *ReleaseChannel {
	return v.ReleaseChannel
}

// GetRoadmapEnabled returns listUsersUsersUserConnectionNodesUserOrganization.RoadmapEnabled, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUserOrganization) GetRoadmapEnabled() *bool {
	return v.RoadmapEnabled
}

// GetSamlEnabled returns listUsersUsersUserConnectionNodesUserOrganization.SamlEnabled, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUserOrganization) GetSamlEnabled() *bool {
	return v.SamlEnabled
}

// GetScimEnabled returns listUsersUsersUserConnectionNodesUserOrganization.ScimEnabled, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUserOrganization) GetScimEnabled() *bool {
	return v.ScimEnabled
}

// GetTrialEndsAt returns listUsersUsersUserConnectionNodesUserOrganization.TrialEndsAt, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUserOrganization) GetTrialEndsAt() *time.Time {
	return v.TrialEndsAt
}

// GetUpdatedAt returns listUsersUsersUserConnectionNodesUserOrganization.UpdatedAt, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUserOrganization) GetUpdatedAt() *time.Time {
	return v.UpdatedAt
}

// GetUrlKey returns listUsersUsersUserConnectionNodesUserOrganization.UrlKey, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUserOrganization) GetUrlKey() *string { return v.UrlKey }

// GetUserCount returns listUsersUsersUserConnectionNodesUserOrganization.UserCount, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionNodesUserOrganization) GetUserCount() *int { return v.UserCount }

func (v *listUsersUsersUserConnectionNodesUserOrganization) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*listUsersUsersUserConnectionNodesUserOrganization
		ArchivedAt          json.RawMessage `json:"archivedAt"`
		CreatedAt           json.RawMessage `json:"createdAt"`
		DeletionRequestedAt json.RawMessage `json:"deletionRequestedAt"`
		TrialEndsAt         json.RawMessage `json:"trialEndsAt"`
		UpdatedAt           json.RawMessage `json:"updatedAt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.listUsersUsersUserConnectionNodesUserOrganization = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.ArchivedAt
		src := firstPass.ArchivedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listUsersUsersUserConnectionNodesUserOrganization.ArchivedAt: %w", err)
			}
		}
	}

	{
		dst := &v.CreatedAt
		src := firstPass.CreatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listUsersUsersUserConnectionNodesUserOrganization.CreatedAt: %w", err)
			}
		}
	}

	{
		dst := &v.DeletionRequestedAt
		src := firstPass.DeletionRequestedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listUsersUsersUserConnectionNodesUserOrganization.DeletionRequestedAt: %w", err)
			}
		}
	}

	{
		dst := &v.TrialEndsAt
		src := firstPass.TrialEndsAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listUsersUsersUserConnectionNodesUserOrganization.TrialEndsAt: %w", err)
			}
		}
	}

	{
		dst := &v.UpdatedAt
		src := firstPass.UpdatedAt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = utils.UnmarshalDateTime(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal listUsersUsersUserConnectionNodesUserOrganization.UpdatedAt: %w", err)
			}
		}
	}
	return nil
}

type __premarshallistUsersUsersUserConnectionNodesUserOrganization struct {
	Id *string `json:"id"`

	AllowedAuthServices []*string `json:"allowedAuthServices"`

	ArchivedAt json.RawMessage `json:"archivedAt"`

	CreatedAt json.RawMessage `json:"createdAt"`

	CreatedIssueCount *int `json:"createdIssueCount"`

	DeletionRequestedAt json.RawMessage `json:"deletionRequestedAt"`

	GitBranchFormat *string `json:"gitBranchFormat"`

	GitLinkbackMessagesEnabled *bool `json:"gitLinkbackMessagesEnabled"`

	GitPublicLinkbackMessagesEnabled *bool `json:"gitPublicLinkbackMessagesEnabled"`

	LogoUrl *string `json:"logoUrl"`

	Name *string `json:"name"`

	PeriodUploadVolume *float64 `json:"periodUploadVolume"`

	PreviousUrlKeys []*string `json:"previousUrlKeys"`

	ProjectUpdateRemindersDay *Day `json:"projectUpdateRemindersDay"`

	ProjectUpdateRemindersHour *float64 `json:"projectUpdateRemindersHour"`

	ProjectUpdatesReminderFrequency *ProjectUpdateReminderFrequency `json:"projectUpdatesReminderFrequency"`

	ReleaseChannel *ReleaseChannel `json:"releaseChannel"`

	RoadmapEnabled *bool `json:"roadmapEnabled"`

	SamlEnabled *bool `json:"samlEnabled"`

	ScimEnabled *bool `json:"scimEnabled"`

	TrialEndsAt json.RawMessage `json:"trialEndsAt"`

	UpdatedAt json.RawMessage `json:"updatedAt"`

	UrlKey *string `json:"urlKey"`

	UserCount *int `json:"userCount"`
}

func (v *listUsersUsersUserConnectionNodesUserOrganization) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *listUsersUsersUserConnectionNodesUserOrganization) __premarshalJSON() (*__premarshallistUsersUsersUserConnectionNodesUserOrganization, error) {
	var retval __premarshallistUsersUsersUserConnectionNodesUserOrganization

	retval.Id = v.Id
	retval.AllowedAuthServices = v.AllowedAuthServices
	{

		dst := &retval.ArchivedAt
		src := v.ArchivedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listUsersUsersUserConnectionNodesUserOrganization.ArchivedAt: %w", err)
			}
		}
	}
	{

		dst := &retval.CreatedAt
		src := v.CreatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listUsersUsersUserConnectionNodesUserOrganization.CreatedAt: %w", err)
			}
		}
	}
	retval.CreatedIssueCount = v.CreatedIssueCount
	{

		dst := &retval.DeletionRequestedAt
		src := v.DeletionRequestedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listUsersUsersUserConnectionNodesUserOrganization.DeletionRequestedAt: %w", err)
			}
		}
	}
	retval.GitBranchFormat = v.GitBranchFormat
	retval.GitLinkbackMessagesEnabled = v.GitLinkbackMessagesEnabled
	retval.GitPublicLinkbackMessagesEnabled = v.GitPublicLinkbackMessagesEnabled
	retval.LogoUrl = v.LogoUrl
	retval.Name = v.Name
	retval.PeriodUploadVolume = v.PeriodUploadVolume
	retval.PreviousUrlKeys = v.PreviousUrlKeys
	retval.ProjectUpdateRemindersDay = v.ProjectUpdateRemindersDay
	retval.ProjectUpdateRemindersHour = v.ProjectUpdateRemindersHour
	retval.ProjectUpdatesReminderFrequency = v.ProjectUpdatesReminderFrequency
	retval.ReleaseChannel = v.ReleaseChannel
	retval.RoadmapEnabled = v.RoadmapEnabled
	retval.SamlEnabled = v.SamlEnabled
	retval.ScimEnabled = v.ScimEnabled
	{

		dst := &retval.TrialEndsAt
		src := v.TrialEndsAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listUsersUsersUserConnectionNodesUserOrganization.TrialEndsAt: %w", err)
			}
		}
	}
	{

		dst := &retval.UpdatedAt
		src := v.UpdatedAt
		if src != nil {
			var err error
			*dst, err = json.Marshal(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal listUsersUsersUserConnectionNodesUserOrganization.UpdatedAt: %w", err)
			}
		}
	}
	retval.UrlKey = v.UrlKey
	retval.UserCount = v.UserCount
	return &retval, nil
}

// listUsersUsersUserConnectionPageInfo includes the requested fields of the GraphQL type PageInfo.
type listUsersUsersUserConnectionPageInfo struct {
	// Indicates if there are more results when paginating forward.
	HasNextPage *bool `json:"hasNextPage"`
	// Cursor representing the last result in the paginated results.
	EndCursor *string `json:"endCursor"`
}

// GetHasNextPage returns listUsersUsersUserConnectionPageInfo.HasNextPage, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionPageInfo) GetHasNextPage() *bool { return v.HasNextPage }

// GetEndCursor returns listUsersUsersUserConnectionPageInfo.EndCursor, and is useful for accessing the field via an interface.
func (v *listUsersUsersUserConnectionPageInfo) GetEndCursor() *string { return v.EndCursor }

// The query or mutation executed by getAttachment.
const getAttachment_Operation = `
query getAttachment ($attachmentId: String!) {
	attachment(id: $attachmentId) {
		id
		archivedAt
		createdAt
		groupBySource
		metadata
		source
		sourceType
		subtitle
		title
		updatedAt
		url
		creator {
			id
			active
			admin
			archivedAt
			avatarUrl
			calendarHash
			createdAt
			createdIssueCount
			description
			disableReason
			displayName
			email
			guest
			inviteHash
			isMe
			lastSeen
			name
			statusEmoji
			statusLabel
			statusUntilAt
			timezone
			updatedAt
			url
		}
		issue {
			id
			createdAt
			updatedAt
			archivedAt
			number
			title
			description
			priority
			estimate
			sortOrder
			startedAt
			completedAt
			canceledAt
			autoClosedAt
			autoArchivedAt
			dueDate
			trashed
			snoozedUntilAt
			previousIdentifiers
			subIssueSortOrder
			priorityLabel
			identifier
			url
			branchName
			customerTicketCount
		}
	}
}
`

func getAttachment(
	ctx_ context.Context,
	client_ graphql.Client,
	attachmentId *string,
) (*getAttachmentResponse, error) {
	req_ := &graphql.Request{
		OpName: "getAttachment",
		Query:  getAttachment_Operation,
		Variables: &__getAttachmentInput{
			AttachmentId: attachmentId,
		},
	}
	var err_ error

	var data_ getAttachmentResponse
	resp_ := &graphql.Response{Data: &data_}

	err_ = client_.MakeRequest(
		ctx_,
		req_,
		resp_,
	)

	return &data_, err_
}

// The query or mutation executed by getComment.
const getComment_Operation = `
query getComment ($commentId: String!) {
	comment(id: $commentId) {
		id
		archivedAt
		body
		bodyData
		createdAt
		editedAt
		reactionData
		updatedAt
		url
		user {
			id
			active
			admin
			archivedAt
			avatarUrl
			calendarHash
			createdAt
			createdIssueCount
			description
			disableReason
			displayName
			email
			guest
			inviteHash
			isMe
			lastSeen
			name
			statusEmoji
			statusLabel
			statusUntilAt
			timezone
			updatedAt
			url
		}
		parent {
			id
			archivedAt
			body
			bodyData
			createdAt
			editedAt
			reactionData
			updatedAt
			url
		}
		issue {
			id
			createdAt
			updatedAt
			archivedAt
			number
			title
			description
			priority
			estimate
			sortOrder
			startedAt
			completedAt
			canceledAt
			autoClosedAt
			autoArchivedAt
			dueDate
			trashed
			snoozedUntilAt
			previousIdentifiers
			subIssueSortOrder
			priorityLabel
			identifier
			url
			branchName
			customerTicketCount
		}
	}
}
`

func getComment(
	ctx_ context.Context,
	client_ graphql.Client,
	commentId *string,
) (*getCommentResponse, error) {
	req_ := &graphql.Request{
		OpName: "getComment",
		Query:  getComment_Operation,
		Variables: &__getCommentInput{
			CommentId: commentId,
		},
	}
	var err_ error

	var data_ getCommentResponse
	resp_ := &graphql.Response{Data: &data_}

	err_ = client_.MakeRequest(
		ctx_,
		req_,
		resp_,
	)

	return &data_, err_
}

// The query or mutation executed by getIntegration.
const getIntegration_Operation = `
query getIntegration ($integrationId: String!) {
	integration(id: $integrationId) {
		id
		archivedAt
		createdAt
		service
		updatedAt
		team {
			id
			archivedAt
			autoArchivePeriod
			autoClosePeriod
			autoCloseStateId
			color
			createdAt
			cycleCalenderUrl
			cycleCooldownTime
			cycleDuration
			cycleIssueAutoAssignCompleted
			cycleIssueAutoAssignStarted
			cycleLockToActive
			cycleStartDay
			cyclesEnabled
			defaultIssueEstimate
			defaultTemplateForMembersId
			defaultTemplateForNonMembersId
			description
			groupIssueHistory
			icon
			inviteHash
			issueEstimationAllowZero
			issueEstimationExtended
			issueEstimationType
			issueOrderingNoPriorityFirst
			issueSortOrderDefaultToBottom
			key
			name
			private
			requirePriorityToLeaveTriage
			slackIssueComments
			slackIssueStatuses
			slackNewIssue
			timezone
			triageEnabled
			upcomingCycleCount
			updatedAt
		}
		creator {
			id
			active
			admin
			archivedAt
			avatarUrl
			calendarHash
			createdAt
			createdIssueCount
			description
			disableReason
			displayName
			email
			guest
			inviteHash
			isMe
			lastSeen
			name
			statusEmoji
			statusLabel
			statusUntilAt
			timezone
			updatedAt
			url
		}
		organization {
			id
			allowedAuthServices
			archivedAt
			createdAt
			createdIssueCount
			deletionRequestedAt
			gitBranchFormat
			gitLinkbackMessagesEnabled
			gitPublicLinkbackMessagesEnabled
			logoUrl
			name
			periodUploadVolume
			previousUrlKeys
			projectUpdateRemindersDay
			projectUpdateRemindersHour
			projectUpdatesReminderFrequency
			releaseChannel
			roadmapEnabled
			samlEnabled
			scimEnabled
			trialEndsAt
			updatedAt
			urlKey
			userCount
		}
	}
}
`

func getIntegration(
	ctx_ context.Context,
	client_ graphql.Client,
	integrationId *string,
) (*getIntegrationResponse, error) {
	req_ := &graphql.Request{
		OpName: "getIntegration",
		Query:  getIntegration_Operation,
		Variables: &__getIntegrationInput{
			IntegrationId: integrationId,
		},
	}
	var err_ error

	var data_ getIntegrationResponse
	resp_ := &graphql.Response{Data: &data_}

	err_ = client_.MakeRequest(
		ctx_,
		req_,
		resp_,
	)

	return &data_, err_
}

// The query or mutation executed by getIssue.
const getIssue_Operation = `
query getIssue ($issueId: String!) {
	issue(id: $issueId) {
		id
		createdAt
		updatedAt
		archivedAt
		number
		title
		description
		priority
		estimate
		sortOrder
		startedAt
		completedAt
		canceledAt
		autoClosedAt
		autoArchivedAt
		dueDate
		trashed
		snoozedUntilAt
		previousIdentifiers
		subIssueSortOrder
		priorityLabel
		identifier
		url
		branchName
		customerTicketCount
		team {
			id
			archivedAt
			autoArchivePeriod
			autoClosePeriod
			autoCloseStateId
			color
			createdAt
			cycleCalenderUrl
			cycleCooldownTime
			cycleDuration
			cycleIssueAutoAssignCompleted
			cycleIssueAutoAssignStarted
			cycleLockToActive
			cycleStartDay
			cyclesEnabled
			defaultIssueEstimate
			defaultTemplateForMembersId
			defaultTemplateForNonMembersId
			description
			groupIssueHistory
			icon
			inviteHash
			issueEstimationAllowZero
			issueEstimationExtended
			issueEstimationType
			issueOrderingNoPriorityFirst
			issueSortOrderDefaultToBottom
			key
			name
			private
			requirePriorityToLeaveTriage
			slackIssueComments
			slackIssueStatuses
			slackNewIssue
			timezone
			triageEnabled
			upcomingCycleCount
			updatedAt
		}
		cycle {
			id
			archivedAt
			autoArchivedAt
			completedAt
			completedIssueCountHistory
			completedScopeHistory
			createdAt
			description
			endsAt
			inProgressScopeHistory
			issueCountHistory
			name
			number
			progress
			scopeHistory
			startsAt
			updatedAt
		}
		project {
			id
			archivedAt
			autoArchivedAt
			canceledAt
			color
			completedAt
			completedIssueCountHistory
			completedScopeHistory
			createdAt
			description
			icon
			inProgressScopeHistory
			issueCountHistory
			name
			progress
			projectUpdateRemindersPausedUntilAt
			scope
			scopeHistory
			slackIssueComments
			slackIssueStatuses
			slackNewIssue
			slugId
			sortOrder
			startDate
			startedAt
			state
			targetDate
			updatedAt
			url
		}
		creator {
			id
			active
			admin
			archivedAt
			avatarUrl
			calendarHash
			createdAt
			createdIssueCount
			description
			disableReason
			displayName
			email
			guest
			inviteHash
			isMe
			lastSeen
			name
			statusEmoji
			statusLabel
			statusUntilAt
			timezone
			updatedAt
			url
		}
		assignee {
			id
			active
			admin
			archivedAt
			avatarUrl
			calendarHash
			createdAt
			createdIssueCount
			description
			disableReason
			displayName
			email
			guest
			inviteHash
			isMe
			lastSeen
			name
			statusEmoji
			statusLabel
			statusUntilAt
			timezone
			updatedAt
			url
		}
		snoozedBy {
			id
			active
			admin
			archivedAt
			avatarUrl
			calendarHash
			createdAt
			createdIssueCount
			description
			disableReason
			displayName
			email
			guest
			inviteHash
			isMe
			lastSeen
			name
			statusEmoji
			statusLabel
			statusUntilAt
			timezone
			updatedAt
			url
		}
		state {
			id
			archivedAt
			color
			createdAt
			description
			name
			position
			type
			updatedAt
		}
		parent {
			id
			createdAt
			updatedAt
			archivedAt
			number
			title
			description
			priority
			estimate
			sortOrder
			startedAt
			completedAt
			canceledAt
			autoClosedAt
			autoArchivedAt
			dueDate
			trashed
			snoozedUntilAt
			previousIdentifiers
		}
		projectMilestone {
			archivedAt
			createdAt
			description
			id
			name
			sortOrder
			updatedAt
		}
	}
}
`

func getIssue(
	ctx_ context.Context,
	client_ graphql.Client,
	issueId *string,
) (*getIssueResponse, error) {
	req_ := &graphql.Request{
		OpName: "getIssue",
		Query:  getIssue_Operation,
		Variables: &__getIssueInput{
			IssueId: issueId,
		},
	}
	var err_ error

	var data_ getIssueResponse
	resp_ := &graphql.Response{Data: &data_}

	err_ = client_.MakeRequest(
		ctx_,
		req_,
		resp_,
	)

	return &data_, err_
}

// The query or mutation executed by getIssueIds.
const getIssueIds_Operation = `
query getIssueIds ($issueLabelId: String!, $first: Int, $after: String, $includeArchived: Boolean!) {
	issueLabel(id: $issueLabelId) {
		id
		issues(first: $first, after: $after, includeArchived: $includeArchived) {
			pageInfo {
				hasNextPage
				endCursor
			}
			nodes {
				id
			}
		}
	}
}
`

func getIssueIds(
	ctx_ context.Context,
	client_ graphql.Client,
	issueLabelId *string,
	first int,
	after string,
	includeArchived bool,
) (*getIssueIdsResponse, error) {
	req_ := &graphql.Request{
		OpName: "getIssueIds",
		Query:  getIssueIds_Operation,
		Variables: &__getIssueIdsInput{
			IssueLabelId:    issueLabelId,
			First:           first,
			After:           after,
			IncludeArchived: includeArchived,
		},
	}
	var err_ error

	var data_ getIssueIdsResponse
	resp_ := &graphql.Response{Data: &data_}

	err_ = client_.MakeRequest(
		ctx_,
		req_,
		resp_,
	)

	return &data_, err_
}

// The query or mutation executed by getIssueLabel.
const getIssueLabel_Operation = `
query getIssueLabel ($issueLabelId: String!, $firstIssue: Int, $includeArchived: Boolean!) {
	issueLabel(id: $issueLabelId) {
		id
		archivedAt
		color
		createdAt
		description
		name
		updatedAt
		issues(first: $firstIssue, includeArchived: $includeArchived) {
			pageInfo {
				hasNextPage
				endCursor
			}
			nodes {
				id
			}
		}
		team {
			id
			archivedAt
			autoArchivePeriod
			autoClosePeriod
			autoCloseStateId
			color
			createdAt
			cycleCalenderUrl
			cycleCooldownTime
			cycleDuration
			cycleIssueAutoAssignCompleted
			cycleIssueAutoAssignStarted
			cycleLockToActive
			cycleStartDay
			cyclesEnabled
			defaultIssueEstimate
			defaultTemplateForMembersId
			defaultTemplateForNonMembersId
			description
			groupIssueHistory
			icon
			inviteHash
			issueEstimationAllowZero
			issueEstimationExtended
			issueEstimationType
			issueOrderingNoPriorityFirst
			issueSortOrderDefaultToBottom
			key
			name
			private
			requirePriorityToLeaveTriage
			slackIssueComments
			slackIssueStatuses
			slackNewIssue
			timezone
			triageEnabled
			upcomingCycleCount
			updatedAt
		}
		creator {
			id
			active
			admin
			archivedAt
			avatarUrl
			calendarHash
			createdAt
			createdIssueCount
			description
			disableReason
			displayName
			email
			guest
			inviteHash
			isMe
			lastSeen
			name
			statusEmoji
			statusLabel
			statusUntilAt
			timezone
			updatedAt
			url
		}
		organization {
			id
			allowedAuthServices
			archivedAt
			createdAt
			createdIssueCount
			deletionRequestedAt
			gitBranchFormat
			gitLinkbackMessagesEnabled
			gitPublicLinkbackMessagesEnabled
			logoUrl
			name
			periodUploadVolume
			previousUrlKeys
			projectUpdateRemindersDay
			projectUpdateRemindersHour
			projectUpdatesReminderFrequency
			releaseChannel
			roadmapEnabled
			samlEnabled
			scimEnabled
			trialEndsAt
			updatedAt
			urlKey
			userCount
		}
		parent {
			id
			archivedAt
			color
			createdAt
			description
			name
			updatedAt
		}
	}
}
`

func getIssueLabel(
	ctx_ context.Context,
	client_ graphql.Client,
	issueLabelId *string,
	firstIssue int,
	includeArchived bool,
) (*getIssueLabelResponse, error) {
	req_ := &graphql.Request{
		OpName: "getIssueLabel",
		Query:  getIssueLabel_Operation,
		Variables: &__getIssueLabelInput{
			IssueLabelId:    issueLabelId,
			FirstIssue:      firstIssue,
			IncludeArchived: includeArchived,
		},
	}
	var err_ error

	var data_ getIssueLabelResponse
	resp_ := &graphql.Response{Data: &data_}

	err_ = client_.MakeRequest(
		ctx_,
		req_,
		resp_,
	)

	return &data_, err_
}

// The query or mutation executed by getOrganization.
const getOrganization_Operation = `
query getOrganization {
	organization {
		id
		allowedAuthServices
		archivedAt
		createdAt
		createdIssueCount
		deletionRequestedAt
		gitBranchFormat
		gitLinkbackMessagesEnabled
		gitPublicLinkbackMessagesEnabled
		logoUrl
		name
		periodUploadVolume
		previousUrlKeys
		projectUpdateRemindersDay
		projectUpdateRemindersHour
		projectUpdatesReminderFrequency
		releaseChannel
		roadmapEnabled
		samlEnabled
		scimEnabled
		trialEndsAt
		updatedAt
		urlKey
		userCount
		projectUpdateRemindersDay
		projectUpdatesReminderFrequency
		releaseChannel
		subscription {
			id
			archivedAt
			canceledAt
			createdAt
			nextBillingAt
			pendingChangeType
			seats
			seatsMaximum
			seatsMinimum
			type
			updatedAt
		}
	}
}
`

func getOrganization(
	ctx_ context.Context,
	client_ graphql.Client,
) (*getOrganizationResponse, error) {
	req_ := &graphql.Request{
		OpName: "getOrganization",
		Query:  getOrganization_Operation,
	}
	var err_ error

	var data_ getOrganizationResponse
	resp_ := &graphql.Response{Data: &data_}

	err_ = client_.MakeRequest(
		ctx_,
		req_,
		resp_,
	)

	return &data_, err_
}

// The query or mutation executed by getProject.
const getProject_Operation = `
query getProject ($projectId: String!) {
	project(id: $projectId) {
		id
		archivedAt
		autoArchivedAt
		canceledAt
		color
		completedAt
		completedIssueCountHistory
		completedScopeHistory
		createdAt
		description
		icon
		inProgressScopeHistory
		issueCountHistory
		name
		progress
		projectUpdateRemindersPausedUntilAt
		scope
		scopeHistory
		slackIssueComments
		slackIssueStatuses
		slackNewIssue
		slugId
		sortOrder
		startDate
		startedAt
		state
		targetDate
		updatedAt
		url
		convertedFromIssue {
			id
			createdAt
			updatedAt
			archivedAt
			number
			title
			description
			priority
			estimate
			sortOrder
			startedAt
			completedAt
			canceledAt
			autoClosedAt
			autoArchivedAt
			dueDate
			trashed
			snoozedUntilAt
			previousIdentifiers
			subIssueSortOrder
			priorityLabel
			identifier
			url
			branchName
			customerTicketCount
		}
		integrationsSettings {
			id
			archivedAt
			createdAt
			slackIssueAddedToTriage
			slackIssueCreated
			slackIssueNewComment
			slackIssueSlaBreached
			slackIssueSlaHighRisk
			slackIssueStatusChangedAll
			slackIssueStatusChangedDone
			slackProjectUpdateCreated
			slackProjectUpdateCreatedToTeam
			slackProjectUpdateCreatedToWorkspace
			updatedAt
		}
		creator {
			id
			active
			admin
			archivedAt
			avatarUrl
			calendarHash
			createdAt
			createdIssueCount
			description
			disableReason
			displayName
			email
			guest
			inviteHash
			isMe
			lastSeen
			name
			statusEmoji
			statusLabel
			statusUntilAt
			timezone
			updatedAt
			url
		}
		lead {
			id
			active
			admin
			archivedAt
			avatarUrl
			calendarHash
			createdAt
			createdIssueCount
			description
			disableReason
			displayName
			email
			guest
			inviteHash
			isMe
			lastSeen
			name
			statusEmoji
			statusLabel
			statusUntilAt
			timezone
			updatedAt
			url
		}
	}
}
`

func getProject(
	ctx_ context.Context,
	client_ graphql.Client,
	projectId *string,
) (*getProjectResponse, error) {
	req_ := &graphql.Request{
		OpName: "getProject",
		Query:  getProject_Operation,
		Variables: &__getProjectInput{
			ProjectId: projectId,
		},
	}
	var err_ error

	var data_ getProjectResponse
	resp_ := &graphql.Response{Data: &data_}

	err_ = client_.MakeRequest(
		ctx_,
		req_,
		resp_,
	)

	return &data_, err_
}

// The query or mutation executed by getTeam.
const getTeam_Operation = `
query getTeam ($teamId: String!) {
	team(id: $teamId) {
		id
		archivedAt
		autoArchivePeriod
		autoClosePeriod
		autoCloseStateId
		color
		createdAt
		cycleCalenderUrl
		cycleCooldownTime
		cycleDuration
		cycleIssueAutoAssignCompleted
		cycleIssueAutoAssignStarted
		cycleLockToActive
		cycleStartDay
		cyclesEnabled
		defaultIssueEstimate
		defaultTemplateForMembersId
		defaultTemplateForNonMembersId
		description
		groupIssueHistory
		icon
		inviteHash
		issueEstimationAllowZero
		issueEstimationExtended
		issueEstimationType
		issueOrderingNoPriorityFirst
		issueSortOrderDefaultToBottom
		key
		name
		private
		requirePriorityToLeaveTriage
		slackIssueComments
		slackIssueStatuses
		slackNewIssue
		timezone
		triageEnabled
		upcomingCycleCount
		updatedAt
		activeCycle {
			id
			archivedAt
			autoArchivedAt
			completedAt
			completedIssueCountHistory
			completedScopeHistory
			createdAt
			description
			endsAt
			inProgressScopeHistory
			issueCountHistory
			name
			number
			progress
			scopeHistory
			startsAt
			updatedAt
		}
		defaultIssueState {
			id
			archivedAt
			color
			createdAt
			description
			name
			position
			type
			updatedAt
		}
		defaultTemplateForMembers {
			id
			archivedAt
			description
			createdAt
			type
			name
			updatedAt
			templateData
		}
		defaultTemplateForNonMembers {
			id
			archivedAt
			description
			createdAt
			type
			name
			updatedAt
			templateData
		}
		draftWorkflowState {
			id
			archivedAt
			color
			createdAt
			description
			name
			position
			type
			updatedAt
		}
		integrationsSettings {
			id
			archivedAt
			createdAt
			slackIssueAddedToTriage
			slackIssueCreated
			slackIssueNewComment
			slackIssueSlaBreached
			slackIssueSlaHighRisk
			slackIssueStatusChangedAll
			slackIssueStatusChangedDone
			slackProjectUpdateCreated
			slackProjectUpdateCreatedToTeam
			slackProjectUpdateCreatedToWorkspace
			updatedAt
		}
		markedAsDuplicateWorkflowState {
			id
			archivedAt
			color
			createdAt
			description
			name
			position
			type
			updatedAt
		}
		organization {
			id
			allowedAuthServices
			archivedAt
			createdAt
			createdIssueCount
			deletionRequestedAt
			gitBranchFormat
			gitLinkbackMessagesEnabled
			gitPublicLinkbackMessagesEnabled
			logoUrl
			name
			periodUploadVolume
			previousUrlKeys
			projectUpdateRemindersDay
			projectUpdateRemindersHour
			projectUpdatesReminderFrequency
			releaseChannel
			roadmapEnabled
			samlEnabled
			scimEnabled
			trialEndsAt
			updatedAt
			urlKey
			userCount
		}
		reviewWorkflowState {
			id
			archivedAt
			color
			createdAt
			description
			name
			position
			type
			updatedAt
		}
		startWorkflowState {
			id
			archivedAt
			color
			createdAt
			description
			name
			position
			type
			updatedAt
		}
		triageIssueState {
			id
			archivedAt
			color
			createdAt
			description
			name
			position
			type
			updatedAt
		}
	}
}
`

func getTeam(
	ctx_ context.Context,
	client_ graphql.Client,
	teamId *string,
) (*getTeamResponse, error) {
	req_ := &graphql.Request{
		OpName: "getTeam",
		Query:  getTeam_Operation,
		Variables: &__getTeamInput{
			TeamId: teamId,
		},
	}
	var err_ error

	var data_ getTeamResponse
	resp_ := &graphql.Response{Data: &data_}

	err_ = client_.MakeRequest(
		ctx_,
		req_,
		resp_,
	)

	return &data_, err_
}

// The query or mutation executed by getTeamMembership.
const getTeamMembership_Operation = `
query getTeamMembership ($teamMembershipId: String!) {
	teamMembership(id: $teamMembershipId) {
		id
		archivedAt
		createdAt
		owner
		sortOrder
		updatedAt
		team {
			id
			archivedAt
			autoArchivePeriod
			autoClosePeriod
			autoCloseStateId
			color
			createdAt
			cycleCalenderUrl
			cycleCooldownTime
			cycleDuration
			cycleIssueAutoAssignCompleted
			cycleIssueAutoAssignStarted
			cycleLockToActive
			cycleStartDay
			cyclesEnabled
			defaultIssueEstimate
			defaultTemplateForMembersId
			defaultTemplateForNonMembersId
			description
			groupIssueHistory
			icon
			inviteHash
			issueEstimationAllowZero
			issueEstimationExtended
			issueEstimationType
			issueOrderingNoPriorityFirst
			issueSortOrderDefaultToBottom
			key
			name
			private
			requirePriorityToLeaveTriage
			slackIssueComments
			slackIssueStatuses
			slackNewIssue
			timezone
			triageEnabled
			upcomingCycleCount
			updatedAt
		}
		user {
			id
			active
			admin
			archivedAt
			avatarUrl
			calendarHash
			createdAt
			createdIssueCount
			description
			disableReason
			displayName
			email
			guest
			inviteHash
			isMe
			lastSeen
			name
			statusEmoji
			statusLabel
			statusUntilAt
			timezone
			updatedAt
			url
		}
	}
}
`

func getTeamMembership(
	ctx_ context.Context,
	client_ graphql.Client,
	teamMembershipId *string,
) (*getTeamMembershipResponse, error) {
	req_ := &graphql.Request{
		OpName: "getTeamMembership",
		Query:  getTeamMembership_Operation,
		Variables: &__getTeamMembershipInput{
			TeamMembershipId: teamMembershipId,
		},
	}
	var err_ error

	var data_ getTeamMembershipResponse
	resp_ := &graphql.Response{Data: &data_}

	err_ = client_.MakeRequest(
		ctx_,
		req_,
		resp_,
	)

	return &data_, err_
}

// The query or mutation executed by getUser.
const getUser_Operation = `
query getUser ($userId: String!) {
	user(id: $userId) {
		id
		active
		admin
		archivedAt
		avatarUrl
		calendarHash
		createdAt
		createdIssueCount
		description
		disableReason
		displayName
		email
		guest
		inviteHash
		isMe
		lastSeen
		name
		statusEmoji
		statusLabel
		statusUntilAt
		timezone
		updatedAt
		url
		organization {
			id
			allowedAuthServices
			archivedAt
			createdAt
			createdIssueCount
			deletionRequestedAt
			gitBranchFormat
			gitLinkbackMessagesEnabled
			gitPublicLinkbackMessagesEnabled
			logoUrl
			name
			periodUploadVolume
			previousUrlKeys
			projectUpdateRemindersDay
			projectUpdateRemindersHour
			projectUpdatesReminderFrequency
			releaseChannel
			roadmapEnabled
			samlEnabled
			scimEnabled
			trialEndsAt
			updatedAt
			urlKey
			userCount
		}
	}
}
`

func getUser(
	ctx_ context.Context,
	client_ graphql.Client,
	userId *string,
) (*getUserResponse, error) {
	req_ := &graphql.Request{
		OpName: "getUser",
		Query:  getUser_Operation,
		Variables: &__getUserInput{
			UserId: userId,
		},
	}
	var err_ error

	var data_ getUserResponse
	resp_ := &graphql.Response{Data: &data_}

	err_ = client_.MakeRequest(
		ctx_,
		req_,
		resp_,
	)

	return &data_, err_
}

// The query or mutation executed by listAttachments.
const listAttachments_Operation = `
query listAttachments ($first: Int, $after: String, $includeArchived: Boolean, $filter: AttachmentFilter) {
	attachments(first: $first, after: $after, filter: $filter, includeArchived: $includeArchived) {
		pageInfo {
			hasNextPage
			endCursor
		}
		nodes {
			id
			archivedAt
			createdAt
			groupBySource
			metadata
			source
			sourceType
			subtitle
			title
			updatedAt
			url
			creator {
				id
				active
				admin
				archivedAt
				avatarUrl
				calendarHash
				createdAt
				createdIssueCount
				description
				disableReason
				displayName
				email
				guest
				inviteHash
				isMe
				lastSeen
				name
				statusEmoji
				statusLabel
				statusUntilAt
				timezone
				updatedAt
				url
			}
			issue {
				id
				createdAt
				updatedAt
				archivedAt
				number
				title
				description
				priority
				estimate
				sortOrder
				startedAt
				completedAt
				canceledAt
				autoClosedAt
				autoArchivedAt
				dueDate
				trashed
				snoozedUntilAt
				previousIdentifiers
				subIssueSortOrder
				priorityLabel
				identifier
				url
				branchName
				customerTicketCount
			}
		}
	}
}
`

func listAttachments(
	ctx_ context.Context,
	client_ graphql.Client,
	first int,
	after string,
	includeArchived bool,
	filter *AttachmentFilter,
) (*listAttachmentsResponse, error) {
	req_ := &graphql.Request{
		OpName: "listAttachments",
		Query:  listAttachments_Operation,
		Variables: &__listAttachmentsInput{
			First:           first,
			After:           after,
			IncludeArchived: includeArchived,
			Filter:          filter,
		},
	}
	var err_ error

	var data_ listAttachmentsResponse
	resp_ := &graphql.Response{Data: &data_}

	err_ = client_.MakeRequest(
		ctx_,
		req_,
		resp_,
	)

	return &data_, err_
}

// The query or mutation executed by listComments.
const listComments_Operation = `
query listComments ($first: Int, $after: String, $includeArchived: Boolean, $filter: CommentFilter) {
	comments(first: $first, after: $after, filter: $filter, includeArchived: $includeArchived) {
		pageInfo {
			hasNextPage
			endCursor
		}
		nodes {
			id
			archivedAt
			body
			bodyData
			createdAt
			editedAt
			reactionData
			updatedAt
			url
			user {
				id
				active
				admin
				archivedAt
				avatarUrl
				calendarHash
				createdAt
				createdIssueCount
				description
				disableReason
				displayName
				email
				guest
				inviteHash
				isMe
				lastSeen
				name
				statusEmoji
				statusLabel
				statusUntilAt
				timezone
				updatedAt
				url
			}
			parent {
				id
				archivedAt
				body
				bodyData
				createdAt
				editedAt
				reactionData
				updatedAt
				url
			}
			issue {
				id
				createdAt
				updatedAt
				archivedAt
				number
				title
				description
				priority
				estimate
				sortOrder
				startedAt
				completedAt
				canceledAt
				autoClosedAt
				autoArchivedAt
				dueDate
				trashed
				snoozedUntilAt
				previousIdentifiers
				subIssueSortOrder
				priorityLabel
				identifier
				url
				branchName
				customerTicketCount
			}
		}
	}
}
`

func listComments(
	ctx_ context.Context,
	client_ graphql.Client,
	first int,
	after string,
	includeArchived bool,
	filter *CommentFilter,
) (*listCommentsResponse, error) {
	req_ := &graphql.Request{
		OpName: "listComments",
		Query:  listComments_Operation,
		Variables: &__listCommentsInput{
			First:           first,
			After:           after,
			IncludeArchived: includeArchived,
			Filter:          filter,
		},
	}
	var err_ error

	var data_ listCommentsResponse
	resp_ := &graphql.Response{Data: &data_}

	err_ = client_.MakeRequest(
		ctx_,
		req_,
		resp_,
	)

	return &data_, err_
}

// The query or mutation executed by listIntegrations.
const listIntegrations_Operation = `
query listIntegrations ($first: Int, $after: String, $includeArchived: Boolean!) {
	integrations(first: $first, after: $after, includeArchived: $includeArchived) {
		pageInfo {
			hasNextPage
			endCursor
		}
		nodes {
			id
			archivedAt
			createdAt
			service
			updatedAt
			team {
				id
				archivedAt
				autoArchivePeriod
				autoClosePeriod
				autoCloseStateId
				color
				createdAt
				cycleCalenderUrl
				cycleCooldownTime
				cycleDuration
				cycleIssueAutoAssignCompleted
				cycleIssueAutoAssignStarted
				cycleLockToActive
				cycleStartDay
				cyclesEnabled
				defaultIssueEstimate
				defaultTemplateForMembersId
				defaultTemplateForNonMembersId
				description
				groupIssueHistory
				icon
				inviteHash
				issueEstimationAllowZero
				issueEstimationExtended
				issueEstimationType
				issueOrderingNoPriorityFirst
				issueSortOrderDefaultToBottom
				key
				name
				private
				requirePriorityToLeaveTriage
				slackIssueComments
				slackIssueStatuses
				slackNewIssue
				timezone
				triageEnabled
				upcomingCycleCount
				updatedAt
			}
			creator {
				id
				active
				admin
				archivedAt
				avatarUrl
				calendarHash
				createdAt
				createdIssueCount
				description
				disableReason
				displayName
				email
				guest
				inviteHash
				isMe
				lastSeen
				name
				statusEmoji
				statusLabel
				statusUntilAt
				timezone
				updatedAt
				url
			}
			organization {
				id
				allowedAuthServices
				archivedAt
				createdAt
				createdIssueCount
				deletionRequestedAt
				gitBranchFormat
				gitLinkbackMessagesEnabled
				gitPublicLinkbackMessagesEnabled
				logoUrl
				name
				periodUploadVolume
				previousUrlKeys
				projectUpdateRemindersDay
				projectUpdateRemindersHour
				projectUpdatesReminderFrequency
				releaseChannel
				roadmapEnabled
				samlEnabled
				scimEnabled
				trialEndsAt
				updatedAt
				urlKey
				userCount
			}
		}
	}
}
`

func listIntegrations(
	ctx_ context.Context,
	client_ graphql.Client,
	first int,
	after string,
	includeArchived bool,
) (*listIntegrationsResponse, error) {
	req_ := &graphql.Request{
		OpName: "listIntegrations",
		Query:  listIntegrations_Operation,
		Variables: &__listIntegrationsInput{
			First:           first,
			After:           after,
			IncludeArchived: includeArchived,
		},
	}
	var err_ error

	var data_ listIntegrationsResponse
	resp_ := &graphql.Response{Data: &data_}

	err_ = client_.MakeRequest(
		ctx_,
		req_,
		resp_,
	)

	return &data_, err_
}

// The query or mutation executed by listIssueLabels.
const listIssueLabels_Operation = `
query listIssueLabels ($first: Int, $firstIssue: Int, $after: String, $includeArchived: Boolean!, $filter: IssueLabelFilter) {
	issueLabels(first: $first, after: $after, filter: $filter, includeArchived: $includeArchived) {
		pageInfo {
			hasNextPage
			endCursor
		}
		nodes {
			id
			archivedAt
			color
			createdAt
			description
			name
			updatedAt
			issues(first: $firstIssue, after: $after, includeArchived: $includeArchived) {
				pageInfo {
					hasNextPage
					endCursor
				}
				nodes {
					id
				}
			}
			team {
				id
				archivedAt
				autoArchivePeriod
				autoClosePeriod
				autoCloseStateId
				color
				createdAt
				cycleCalenderUrl
				cycleCooldownTime
				cycleDuration
				cycleIssueAutoAssignCompleted
				cycleIssueAutoAssignStarted
				cycleLockToActive
				cycleStartDay
				cyclesEnabled
				defaultIssueEstimate
				defaultTemplateForMembersId
				defaultTemplateForNonMembersId
				description
				groupIssueHistory
				icon
				inviteHash
				issueEstimationAllowZero
				issueEstimationExtended
				issueEstimationType
				issueOrderingNoPriorityFirst
				issueSortOrderDefaultToBottom
				key
				name
				private
				requirePriorityToLeaveTriage
				slackIssueComments
				slackIssueStatuses
				slackNewIssue
				timezone
				triageEnabled
				upcomingCycleCount
				updatedAt
			}
			creator {
				id
				active
				admin
				archivedAt
				avatarUrl
				calendarHash
				createdAt
				createdIssueCount
				description
				disableReason
				displayName
				email
				guest
				inviteHash
				isMe
				lastSeen
				name
				statusEmoji
				statusLabel
				statusUntilAt
				timezone
				updatedAt
				url
			}
			organization {
				id
				allowedAuthServices
				archivedAt
				createdAt
				createdIssueCount
				deletionRequestedAt
				gitBranchFormat
				gitLinkbackMessagesEnabled
				gitPublicLinkbackMessagesEnabled
				logoUrl
				name
				periodUploadVolume
				previousUrlKeys
				projectUpdateRemindersDay
				projectUpdateRemindersHour
				projectUpdatesReminderFrequency
				releaseChannel
				roadmapEnabled
				samlEnabled
				scimEnabled
				trialEndsAt
				updatedAt
				urlKey
				userCount
			}
			parent {
				id
				archivedAt
				color
				createdAt
				description
				name
				updatedAt
			}
		}
	}
}
`

func listIssueLabels(
	ctx_ context.Context,
	client_ graphql.Client,
	first int,
	firstIssue int,
	after string,
	includeArchived bool,
	filter *IssueLabelFilter,
) (*listIssueLabelsResponse, error) {
	req_ := &graphql.Request{
		OpName: "listIssueLabels",
		Query:  listIssueLabels_Operation,
		Variables: &__listIssueLabelsInput{
			First:           first,
			FirstIssue:      firstIssue,
			After:           after,
			IncludeArchived: includeArchived,
			Filter:          filter,
		},
	}
	var err_ error

	var data_ listIssueLabelsResponse
	resp_ := &graphql.Response{Data: &data_}

	err_ = client_.MakeRequest(
		ctx_,
		req_,
		resp_,
	)

	return &data_, err_
}

// The query or mutation executed by listIssues.
const listIssues_Operation = `
query listIssues ($first: Int, $after: String, $includeArchived: Boolean, $filter: IssueFilter) {
	issues(first: $first, after: $after, filter: $filter, includeArchived: $includeArchived) {
		pageInfo {
			hasNextPage
			endCursor
		}
		nodes {
			id
			createdAt
			updatedAt
			archivedAt
			number
			title
			description
			priority
			estimate
			sortOrder
			startedAt
			completedAt
			canceledAt
			autoClosedAt
			autoArchivedAt
			dueDate
			trashed
			snoozedUntilAt
			previousIdentifiers
			subIssueSortOrder
			priorityLabel
			identifier
			url
			branchName
			customerTicketCount
			team {
				id
				archivedAt
				autoArchivePeriod
				autoClosePeriod
				autoCloseStateId
				color
				createdAt
				cycleCalenderUrl
				cycleCooldownTime
				cycleDuration
				cycleIssueAutoAssignCompleted
				cycleIssueAutoAssignStarted
				cycleLockToActive
				cycleStartDay
				cyclesEnabled
				defaultIssueEstimate
				defaultTemplateForMembersId
				defaultTemplateForNonMembersId
				description
				groupIssueHistory
				icon
				inviteHash
				issueEstimationAllowZero
				issueEstimationExtended
				issueEstimationType
				issueOrderingNoPriorityFirst
				issueSortOrderDefaultToBottom
				key
				name
				private
				requirePriorityToLeaveTriage
				slackIssueComments
				slackIssueStatuses
				slackNewIssue
				timezone
				triageEnabled
				upcomingCycleCount
				updatedAt
			}
			cycle {
				id
				archivedAt
				autoArchivedAt
				completedAt
				completedIssueCountHistory
				completedScopeHistory
				createdAt
				description
				endsAt
				inProgressScopeHistory
				issueCountHistory
				name
				number
				progress
				scopeHistory
				startsAt
				updatedAt
			}
			project {
				id
				archivedAt
				autoArchivedAt
				canceledAt
				color
				completedAt
				completedIssueCountHistory
				completedScopeHistory
				createdAt
				description
				icon
				inProgressScopeHistory
				issueCountHistory
				name
				progress
				projectUpdateRemindersPausedUntilAt
				scope
				scopeHistory
				slackIssueComments
				slackIssueStatuses
				slackNewIssue
				slugId
				sortOrder
				startDate
				startedAt
				state
				targetDate
				updatedAt
				url
			}
			creator {
				id
				active
				admin
				archivedAt
				avatarUrl
				calendarHash
				createdAt
				createdIssueCount
				description
				disableReason
				displayName
				email
				guest
				inviteHash
				isMe
				lastSeen
				name
				statusEmoji
				statusLabel
				statusUntilAt
				timezone
				updatedAt
				url
			}
			assignee {
				id
				active
				admin
				archivedAt
				avatarUrl
				calendarHash
				createdAt
				createdIssueCount
				description
				disableReason
				displayName
				email
				guest
				inviteHash
				isMe
				lastSeen
				name
				statusEmoji
				statusLabel
				statusUntilAt
				timezone
				updatedAt
				url
			}
			snoozedBy {
				id
				active
				admin
				archivedAt
				avatarUrl
				calendarHash
				createdAt
				createdIssueCount
				description
				disableReason
				displayName
				email
				guest
				inviteHash
				isMe
				lastSeen
				name
				statusEmoji
				statusLabel
				statusUntilAt
				timezone
				updatedAt
				url
			}
			state {
				id
				archivedAt
				color
				createdAt
				description
				name
				position
				type
				updatedAt
			}
			parent {
				id
				createdAt
				updatedAt
				archivedAt
				number
				title
				description
				priority
				estimate
				sortOrder
				startedAt
				completedAt
				canceledAt
				autoClosedAt
				autoArchivedAt
				dueDate
				trashed
				snoozedUntilAt
				previousIdentifiers
			}
			projectMilestone {
				archivedAt
				createdAt
				description
				id
				name
				sortOrder
				updatedAt
			}
		}
	}
}
`

func listIssues(
	ctx_ context.Context,
	client_ graphql.Client,
	first int,
	after string,
	includeArchived bool,
	filter *IssueFilter,
) (*listIssuesResponse, error) {
	req_ := &graphql.Request{
		OpName: "listIssues",
		Query:  listIssues_Operation,
		Variables: &__listIssuesInput{
			First:           first,
			After:           after,
			IncludeArchived: includeArchived,
			Filter:          filter,
		},
	}
	var err_ error

	var data_ listIssuesResponse
	resp_ := &graphql.Response{Data: &data_}

	err_ = client_.MakeRequest(
		ctx_,
		req_,
		resp_,
	)

	return &data_, err_
}

// The query or mutation executed by listProjects.
const listProjects_Operation = `
query listProjects ($first: Int, $after: String, $includeArchived: Boolean, $filter: ProjectFilter) {
	projects(first: $first, after: $after, filter: $filter, includeArchived: $includeArchived) {
		pageInfo {
			hasNextPage
			endCursor
		}
		nodes {
			id
			archivedAt
			autoArchivedAt
			canceledAt
			color
			completedAt
			completedIssueCountHistory
			completedScopeHistory
			createdAt
			description
			icon
			inProgressScopeHistory
			issueCountHistory
			name
			progress
			projectUpdateRemindersPausedUntilAt
			scope
			scopeHistory
			slackIssueComments
			slackIssueStatuses
			slackNewIssue
			slugId
			sortOrder
			startDate
			startedAt
			state
			targetDate
			updatedAt
			url
			convertedFromIssue {
				id
				createdAt
				updatedAt
				archivedAt
				number
				title
				description
				priority
				estimate
				sortOrder
				startedAt
				completedAt
				canceledAt
				autoClosedAt
				autoArchivedAt
				dueDate
				trashed
				snoozedUntilAt
				previousIdentifiers
				subIssueSortOrder
				priorityLabel
				identifier
				url
				branchName
				customerTicketCount
			}
			integrationsSettings {
				id
				archivedAt
				createdAt
				slackIssueAddedToTriage
				slackIssueCreated
				slackIssueNewComment
				slackIssueSlaBreached
				slackIssueSlaHighRisk
				slackIssueStatusChangedAll
				slackIssueStatusChangedDone
				slackProjectUpdateCreated
				slackProjectUpdateCreatedToTeam
				slackProjectUpdateCreatedToWorkspace
				updatedAt
			}
			creator {
				id
				active
				admin
				archivedAt
				avatarUrl
				calendarHash
				createdAt
				createdIssueCount
				description
				disableReason
				displayName
				email
				guest
				inviteHash
				isMe
				lastSeen
				name
				statusEmoji
				statusLabel
				statusUntilAt
				timezone
				updatedAt
				url
			}
			lead {
				id
				active
				admin
				archivedAt
				avatarUrl
				calendarHash
				createdAt
				createdIssueCount
				description
				disableReason
				displayName
				email
				guest
				inviteHash
				isMe
				lastSeen
				name
				statusEmoji
				statusLabel
				statusUntilAt
				timezone
				updatedAt
				url
			}
		}
	}
}
`

func listProjects(
	ctx_ context.Context,
	client_ graphql.Client,
	first int,
	after string,
	includeArchived bool,
	filter *ProjectFilter,
) (*listProjectsResponse, error) {
	req_ := &graphql.Request{
		OpName: "listProjects",
		Query:  listProjects_Operation,
		Variables: &__listProjectsInput{
			First:           first,
			After:           after,
			IncludeArchived: includeArchived,
			Filter:          filter,
		},
	}
	var err_ error

	var data_ listProjectsResponse
	resp_ := &graphql.Response{Data: &data_}

	err_ = client_.MakeRequest(
		ctx_,
		req_,
		resp_,
	)

	return &data_, err_
}

// The query or mutation executed by listTeamMemberships.
const listTeamMemberships_Operation = `
query listTeamMemberships ($first: Int, $after: String, $includeArchived: Boolean!) {
	teamMemberships(first: $first, after: $after, includeArchived: $includeArchived) {
		pageInfo {
			hasNextPage
			endCursor
		}
		nodes {
			id
			archivedAt
			createdAt
			owner
			sortOrder
			updatedAt
			team {
				id
				archivedAt
				autoArchivePeriod
				autoClosePeriod
				autoCloseStateId
				color
				createdAt
				cycleCalenderUrl
				cycleCooldownTime
				cycleDuration
				cycleIssueAutoAssignCompleted
				cycleIssueAutoAssignStarted
				cycleLockToActive
				cycleStartDay
				cyclesEnabled
				defaultIssueEstimate
				defaultTemplateForMembersId
				defaultTemplateForNonMembersId
				description
				groupIssueHistory
				icon
				inviteHash
				issueEstimationAllowZero
				issueEstimationExtended
				issueEstimationType
				issueOrderingNoPriorityFirst
				issueSortOrderDefaultToBottom
				key
				name
				private
				requirePriorityToLeaveTriage
				slackIssueComments
				slackIssueStatuses
				slackNewIssue
				timezone
				triageEnabled
				upcomingCycleCount
				updatedAt
			}
			user {
				id
				active
				admin
				archivedAt
				avatarUrl
				calendarHash
				createdAt
				createdIssueCount
				description
				disableReason
				displayName
				email
				guest
				inviteHash
				isMe
				lastSeen
				name
				statusEmoji
				statusLabel
				statusUntilAt
				timezone
				updatedAt
				url
			}
		}
	}
}
`

func listTeamMemberships(
	ctx_ context.Context,
	client_ graphql.Client,
	first int,
	after string,
	includeArchived bool,
) (*listTeamMembershipsResponse, error) {
	req_ := &graphql.Request{
		OpName: "listTeamMemberships",
		Query:  listTeamMemberships_Operation,
		Variables: &__listTeamMembershipsInput{
			First:           first,
			After:           after,
			IncludeArchived: includeArchived,
		},
	}
	var err_ error

	var data_ listTeamMembershipsResponse
	resp_ := &graphql.Response{Data: &data_}

	err_ = client_.MakeRequest(
		ctx_,
		req_,
		resp_,
	)

	return &data_, err_
}

// The query or mutation executed by listTeams.
const listTeams_Operation = `
query listTeams ($first: Int, $after: String, $includeArchived: Boolean, $filter: TeamFilter) {
	teams(first: $first, after: $after, filter: $filter, includeArchived: $includeArchived) {
		pageInfo {
			hasNextPage
			endCursor
		}
		nodes {
			id
			archivedAt
			autoArchivePeriod
			autoClosePeriod
			autoCloseStateId
			color
			createdAt
			cycleCalenderUrl
			cycleCooldownTime
			cycleDuration
			cycleIssueAutoAssignCompleted
			cycleIssueAutoAssignStarted
			cycleLockToActive
			cycleStartDay
			cyclesEnabled
			defaultIssueEstimate
			defaultTemplateForMembersId
			defaultTemplateForNonMembersId
			description
			groupIssueHistory
			icon
			inviteHash
			issueEstimationAllowZero
			issueEstimationExtended
			issueEstimationType
			issueOrderingNoPriorityFirst
			issueSortOrderDefaultToBottom
			key
			name
			private
			requirePriorityToLeaveTriage
			slackIssueComments
			slackIssueStatuses
			slackNewIssue
			timezone
			triageEnabled
			upcomingCycleCount
			updatedAt
			activeCycle {
				id
				archivedAt
				autoArchivedAt
				completedAt
				completedIssueCountHistory
				completedScopeHistory
				createdAt
				description
				endsAt
				inProgressScopeHistory
				issueCountHistory
				name
				number
				progress
				scopeHistory
				startsAt
				updatedAt
			}
			defaultIssueState {
				id
				archivedAt
				color
				createdAt
				description
				name
				position
				type
				updatedAt
			}
			defaultTemplateForMembers {
				id
				archivedAt
				description
				createdAt
				type
				name
				updatedAt
				templateData
			}
			defaultTemplateForNonMembers {
				id
				archivedAt
				description
				createdAt
				type
				name
				updatedAt
				templateData
			}
			draftWorkflowState {
				id
				archivedAt
				color
				createdAt
				description
				name
				position
				type
				updatedAt
			}
			integrationsSettings {
				id
				archivedAt
				createdAt
				slackIssueAddedToTriage
				slackIssueCreated
				slackIssueNewComment
				slackIssueSlaBreached
				slackIssueSlaHighRisk
				slackIssueStatusChangedAll
				slackIssueStatusChangedDone
				slackProjectUpdateCreated
				slackProjectUpdateCreatedToTeam
				slackProjectUpdateCreatedToWorkspace
				updatedAt
			}
			markedAsDuplicateWorkflowState {
				id
				archivedAt
				color
				createdAt
				description
				name
				position
				type
				updatedAt
			}
			organization {
				id
				allowedAuthServices
				archivedAt
				createdAt
				createdIssueCount
				deletionRequestedAt
				gitBranchFormat
				gitLinkbackMessagesEnabled
				gitPublicLinkbackMessagesEnabled
				logoUrl
				name
				periodUploadVolume
				previousUrlKeys
				projectUpdateRemindersDay
				projectUpdateRemindersHour
				projectUpdatesReminderFrequency
				releaseChannel
				roadmapEnabled
				samlEnabled
				scimEnabled
				trialEndsAt
				updatedAt
				urlKey
				userCount
			}
			reviewWorkflowState {
				id
				archivedAt
				color
				createdAt
				description
				name
				position
				type
				updatedAt
			}
			startWorkflowState {
				id
				archivedAt
				color
				createdAt
				description
				name
				position
				type
				updatedAt
			}
			triageIssueState {
				id
				archivedAt
				color
				createdAt
				description
				name
				position
				type
				updatedAt
			}
		}
	}
}
`

func listTeams(
	ctx_ context.Context,
	client_ graphql.Client,
	first int,
	after string,
	includeArchived bool,
	filter *TeamFilter,
) (*listTeamsResponse, error) {
	req_ := &graphql.Request{
		OpName: "listTeams",
		Query:  listTeams_Operation,
		Variables: &__listTeamsInput{
			First:           first,
			After:           after,
			IncludeArchived: includeArchived,
			Filter:          filter,
		},
	}
	var err_ error

	var data_ listTeamsResponse
	resp_ := &graphql.Response{Data: &data_}

	err_ = client_.MakeRequest(
		ctx_,
		req_,
		resp_,
	)

	return &data_, err_
}

// The query or mutation executed by listUsers.
const listUsers_Operation = `
query listUsers ($first: Int, $after: String, $includeArchived: Boolean, $filter: UserFilter) {
	users(first: $first, after: $after, filter: $filter, includeArchived: $includeArchived) {
		pageInfo {
			hasNextPage
			endCursor
		}
		nodes {
			id
			active
			admin
			archivedAt
			avatarUrl
			calendarHash
			createdAt
			createdIssueCount
			description
			disableReason
			displayName
			email
			guest
			inviteHash
			isMe
			lastSeen
			name
			statusEmoji
			statusLabel
			statusUntilAt
			timezone
			updatedAt
			url
			organization {
				id
				allowedAuthServices
				archivedAt
				createdAt
				createdIssueCount
				deletionRequestedAt
				gitBranchFormat
				gitLinkbackMessagesEnabled
				gitPublicLinkbackMessagesEnabled
				logoUrl
				name
				periodUploadVolume
				previousUrlKeys
				projectUpdateRemindersDay
				projectUpdateRemindersHour
				projectUpdatesReminderFrequency
				releaseChannel
				roadmapEnabled
				samlEnabled
				scimEnabled
				trialEndsAt
				updatedAt
				urlKey
				userCount
			}
		}
	}
}
`

func listUsers(
	ctx_ context.Context,
	client_ graphql.Client,
	first int,
	after string,
	includeArchived bool,
	filter *UserFilter,
) (*listUsersResponse, error) {
	req_ := &graphql.Request{
		OpName: "listUsers",
		Query:  listUsers_Operation,
		Variables: &__listUsersInput{
			First:           first,
			After:           after,
			IncludeArchived: includeArchived,
			Filter:          filter,
		},
	}
	var err_ error

	var data_ listUsersResponse
	resp_ := &graphql.Response{Data: &data_}

	err_ = client_.MakeRequest(
		ctx_,
		req_,
		resp_,
	)

	return &data_, err_
}
